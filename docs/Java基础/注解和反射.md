# 注解



## 什么是注解？

Java.Annotation

![image-20220215162613426](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151627813.png)



```java
// @Override 重写的注解
@Override
public String toString() {
    return "Demo{}";
}
```



## 内置注解

![image-20220215163222991](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151632143.png)

```java
package annotations_reflections;

import java.util.ArrayList;

/**
 * @author miemiehoho
 * @date 2022/2/15 16:29
 */
public class Demo extends Object {

    // @Override 重写的注解
    @Override
    public String toString() {
        return "Demo{}";
    }

    @Deprecated // 废弃
    public static void test01() {

    }

    @SuppressWarnings("all") // 镇压警告
    public void test02() {
        ArrayList arrayList = new ArrayList<>();
    }

    public static void main(String[] args) {
        test01();
    }   
}
```



## 元注解

![image-20220215164453663](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151644789.png)

**元注解是负责解释其他注解的注解**



 @retention注解的生命周期 默认是runtime ，生命周期最长

```java
package annotations_reflections;

import java.lang.annotation.*;

/**
 * @author miemiehoho
 * @date 2022/2/15 16:58
 */
// 测试元注解
@MyAnnotation
public class Demo2 {

    @MyAnnotation
    public void test() {

    }
}

// 定义一个注解
// Target 表示注解可以用在哪些地方
@Target(value = {ElementType.METHOD, ElementType.TYPE})
// Retention 表示注解在哪些地方还有效
// runtime > class > source
@Retention(value = RetentionPolicy.RUNTIME)
// Documented 表示是否将我们的注解生成在 JavaDoc中
@Documented
// Inherited 表示子类可以继承父类
@Inherited
@interface MyAnnotation {

}
```



## 自定义注解

![image-20220215171245822](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151712958.png)

### 如何自定义注解？

使用 `@interface` 自定义注解时，自动继承了 `java.lang.annotation.Annotation` 接口



# 反射

## 什么是反射

Java.Reflection

![image-20220215174959773](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151749932.png)





## 获得反射对象

![image-20220215181057009](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151810172.png)

![image-20220215181613858](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151816957.png)

![image-20220215181648262](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151816360.png)

![image-20220215181734695](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151817767.png)



```java
package annotations_reflections.reflection;

/**
 * @author miemiehoho
 * @date 2022/2/15 18:18
 */
// 什么叫反射
public class Demo {
    public static void main(String[] args) throws ClassNotFoundException {
        // 通过反射获取类的Class对象
        Class c1 = Class.forName("annotations_reflections.reflection.User");
        System.out.println(c1);

        Class c2 = Class.forName("annotations_reflections.reflection.User");
        Class c3 = Class.forName("annotations_reflections.reflection.User");
        Class c4 = Class.forName("annotations_reflections.reflection.User");

        // 一个类在内存中只有一个 Class对象
        // 一个类被加载后，类的整个结构都会被封装在Class 对象中
        System.out.println(c2.hashCode());
        System.out.println(c3.hashCode());
        System.out.println(c4.hashCode());

    }
}

// 实体类:pojo/entity
class User {
    private String name;
    private int id;
    private int age;

    public User() {
    }

    public User(String name, int id, int age) {
        this.name = name;
        this.id = id;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```



## 得到 Class 类的几种方式

![image-20220215182351485](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151823605.png)

![image-20220215182811822](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151828967.png)

![image-20220215183050262](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151830431.png)

![image-20220215183218603](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151832661.png)

```java
package annotations_reflections.reflection;

/**
 * @author miemiehoho
 * @date 2022/2/15 18:47
 */
// 获取Class类实例的多种方式
public class Demo2 {
    public static void main(String[] args) throws ClassNotFoundException {
        Person person = new Student();
        System.out.println("这个人是：" + person.name);

        // 方式一：通过对象获得 Class类的实例
        Class c1 = person.getClass();
        System.out.println(c1.hashCode());

        // 方式二：通过Class类的静态方法 forName() 获得
        Class c2 = Class.forName("annotations_reflections.reflection.Student");
        System.out.println(c2.hashCode());

        // 方式三：通过类的class 属性获取
        Class<Student> c3 = Student.class;
        System.out.println(c3.hashCode());

        // 方式四：对于内置基本数据类型可以直接用类名.Type获取
        Class<Integer> c4 = Integer.TYPE;
        System.out.println(c4);

        // 获得父类
        Class superclass = c1.getSuperclass();
        System.out.println(superclass);
    }
}

class Person {
    public String name;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                '}';
    }

    public Person(String name) {
        this.name = name;
    }

    public Person() {
    }
}

class Student extends Person {
    public Student() {
        this.name = "学生";
    }
}

class Teacher extends Person {
    public Teacher() {
        this.name = "老师";
    }
}
```



## 哪些类型可以有Class对象？

![image-20220215191506663](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202151915756.png)



- **只要元素类型与维度一样，就是同一个Class**



```java
package annotations_reflections.reflection;

import java.lang.annotation.ElementType;

/**
 * @author miemiehoho
 * @date 2022/2/15 20:59
 */
// 所有类型的 Class对象
public class Demo3 {
    public static void main(String[] args) {
        Class c1 = Object.class;// 类
        Class c2 = Comparable.class;// 接口
        Class c3 = String[].class;// 一维数组
        Class c4 = int[][].class;// 二维数组
        Class c5 = Override.class;// 注解
        Class c6 = ElementType.class;// 枚举
        Class c7 = Integer.class;// 基本数据类型
        Class c8 = void.class;// void
        Class c9 = Class.class;// Class

        System.out.println(c1);
        System.out.println(c2);
        System.out.println(c3);
        System.out.println(c4);
        System.out.println(c5);
        System.out.println(c6);
        System.out.println(c7);
        System.out.println(c8);
        System.out.println(c9);

        // 只要元素类型与维度一样，就是同一个Class
        int[] a = new int[10];
        int[] b = new int[100];
        System.out.println(a.getClass().hashCode());
        System.out.println(b.getClass().hashCode());
    }
}
```



## 类加载内存分析

![image-20220215211527008](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202152115140.png)





![image-20220215212630228](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202152126393.png)



![image-20220215212710823](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202152127981.png)

### 关键内容：

1. 加载：Class类生成（方法区）
2. 链接：
   - 为类变量分配内存并设置类变量默认初始值；
   - **常量在准备阶段**就被加载到内存中并且赋予了正确的值
3. 初始化：（static优先级高，先执行，同为static的根据从上到下顺序执行）
   - 合并所有的类变量中的赋值动作和静态代码块中的语句
   - new一个class对象实例



- 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名Non-Heap（非堆）
- 方法区指的是一个规范，1.8的方法区就元空间+部分堆
- 永久代1.7  元空间1.8 都是方法区的不同实现
- class存储在方法区，对象实例存储在堆





### 实例：

```java
package annotations_reflections.reflection;

/**
 * @author miemiehoho
 * @date 2022/2/15 21:59
 */
public class Demo4 {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.m);
        /**
         1. 加载到内存，会产生一个类对应的class对象
         2.链接，链接结束后 m = 0
         3. 初始化:static优先级高，先执行，同为static的根据从上到下顺序执行
         <clinit>(){
         System.out.println("A类静态代码块初始化");
         m = 300;
         m = 100;
         System.out.println("A类无参构造初始化");
         }

         */
    }
}

class A {
//    static int m = 100;

    static {
        System.out.println("A类静态代码块初始化");
        m = 300;
    }

    static int m = 100;

    public A() {
        System.out.println("A类无参构造初始化");
    }
}
```

首先是准备阶段，静态代码块并没有执行，m给予了默认值0，然后初始化的时候从上到下执行，m被赋予=300，然后又=100

- 静态代码块和静态变量只跟顺序有关

- 静态代码块和静态变量，哪个在前，就哪个先赋值，如果这里把静态代码块和静态变量的位置对调，则输出的是300
- new A()应该是初始化实例对象的，类对象的初始化应该在类加载完就完成了，和new没有关系



## 分析类初始化

![image-20220215225751644](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202152257790.png)

```java
package annotations_reflections.reflection;

/**
 * @author miemiehoho
 * @date 2022/2/15 23:08
 */
public class Demo5 {
    static {
        System.out.println("main 类被加载");
    }

    public static void main(String[] args) throws ClassNotFoundException {
        // 1.主动引用
        // new 一个类的对象
//        Son son = new Son();

        // 调用类的静态成员（除了final常量）
//        System.out.println(Son.m);

        // 反射也会产生主动引用
//        Class.forName("annotations_reflections.reflection.Son");

        // 2.被动引用
        // 通过子类引用父类的静态变量，不会导致 子类初始化
//        System.out.println(Son.b);

        // 通过数组定义类引用，不会触发此类的初始化
        // 声明数组相当于去开空间，并不需要去指向对象，故没有创建对象
//        Son[] sons = new Son[5];

        // 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池了）
        System.out.println(Son.M);


        // 当初始化子类时,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化
        // 当调用类是静态方法时(即当使用了字节码invokestatic指令)
        // 如果一个接口定义了default方法,那么直接实现或间接实现该接口的类的初始化,该接口要在其之前初始化
    }
}

class Father {
    static int b = 2;

    static {
        System.out.println("父类被加载");
    }
}

class Son extends Father {
    static {
        System.out.println("子类被加载");
        m = 300;
    }

    static int m = 100;
    static final int M = 1;
}
```



## 类加载器的作用

![image-20220216101107761](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161011943.png)

![image-20220216101946703](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161019855.png)

```java
package annotations_reflections.reflection;

/**
 * @author miemiehoho
 * @date 2022/2/16 10:42
 */
public class Demo6 {

    public static void main(String[] args) throws ClassNotFoundException {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);

        // 获取系统类加载器的父类加载器 - 拓展类加载器
        ClassLoader parent = systemClassLoader.getParent();
        System.out.println(parent);

        // 获取拓展类加载器的父类加载器 - 根加载器
        ClassLoader parentParent = parent.getParent();
        System.out.println(parentParent);

        // 当前类加载器
        Class c = Class.forName("annotations_reflections.reflection.Demo6");
        System.out.println(c.getClassLoader());
        // 测试jdk内部类的类加载器
        Class c2 = Class.forName("java.lang.Object");
        System.out.println(c2.getClassLoader());

        // 获取系统类加载器可以加载的路径
        System.out.println(System.getProperty("java.class.path"));
        // 双亲委派机制：
        // AppClassLoader -> ExtClassLoader ->BootClassLoader
        // 多重检查，保证安全性


        // D:\Programs\Java\jdk1.8.0_311\jre\lib\charsets.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\deploy.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\access-bridge-64.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\cldrdata.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\dnsns.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\jaccess.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\jfxrt.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\localedata.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\nashorn.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\sunec.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\sunjce_provider.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\sunmscapi.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\sunpkcs11.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\ext\zipfs.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\javaws.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\jce.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\jfr.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\jfxswt.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\jsse.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\management-agent.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\plugin.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\resources.jar;
        // D:\Programs\Java\jdk1.8.0_311\jre\lib\rt.jar;
        // D:\13686\OneDrive - 365word\miemiehoho\Project\practice\out\production\practice;
        // C:\Users\13686\.m2\repository\org\projectlombok\lombok\1.18.20\lombok-1.18.20.jar;
        // D:\Programs\IntelliJ IDEA 2021.2.3\lib\idea_rt.jar

    }
}
```



## 获取类的运行时结构

Java.Reflection

![image-20220216111955134](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161119241.png)

- 运行时类型信息简称RTTI，是指不在JVM初始化时获取信息，而在运行时获取。根据RTTi可以动态的获取Class对象来处理你需要处理的类

- 注解底层都是用反射实现的

```java
package annotations_reflections.reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @author miemiehoho
 * @date 2022/2/16 10:54
 */
// 获取运行时类的信息
public class Demo7 {

    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {
        Class c = Class.forName("annotations_reflections.reflection.User");

        User user = new User();

        c = user.getClass();
        // 获得类的名字： 包名 + 类名
        System.out.println(c.getName());
        // 获得类名
        System.out.println(c.getSimpleName());

        // 获得类的属性
        Field[] fields = c.getFields();// 只能找到public属性
        for (Field field : fields) {
            System.out.println(field);
        }

        Field[] declaredFields = c.getDeclaredFields();// 找到类的所有属性，包括私有属性
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }

        System.out.println("========================");
        // 根据属性名获取指定属性
//        Field name = c.getField("name");
        Field name = c.getDeclaredField("name");
        System.out.println(name);

        // 获得类的方法
        System.out.println("======method========");
        Method[] methods = c.getMethods();// 获得本类及其父类的所有public方法
        for (Method method : methods) {
            System.out.println(method);
        }
        System.out.println("======declaredMethod========");
        Method[] declaredMethods = c.getDeclaredMethods();// 获得本类的所有方法
        for (Method declaredMethod : declaredMethods) {
            System.out.println(declaredMethod);
        }


        // 获得指定方法
        // 为什么需要加参数？因为存在重载
        System.out.println("======获得指定方法========");
        Method getName = c.getMethod("getName", null);
        System.out.println(getName);

        Method setName = c.getMethod("setName", String.class);
        System.out.println(setName);

        // 获得指定的构造器
        System.out.println("======获得指定的构造器========");
        System.out.println("======constructor========");
        Constructor[] constructors = c.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }
        System.out.println("=======declaredConstructors================");
        Constructor[] declaredConstructors = c.getDeclaredConstructors();
        for (Constructor declaredConstructor : declaredConstructors) {
            System.out.println(declaredConstructor);
        }

        // 获得指定的构造器
        System.out.println("==========获得指定的构造器=============");
        Constructor constructor = c.getConstructor(String.class, int.class, int.class);
        System.out.println(constructor);

        Constructor declaredConstructor = c.getDeclaredConstructor();
        System.out.println(declaredConstructor);

    }
}

// 实体类:pojo/entity
class User {
    private String name;
    private int id;
    private int age;

    public User() {
    }

    public User(String name, int id, int age) {
        this.name = name;
        this.id = id;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    private void test() {

    }
}
```

## 小结

![image-20220216122319464](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161223549.png)



## 通过反射 动态的创建对象

![image-20220216122441578](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161224722.png)

![image-20220216194604059](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161946225.png)

![image-20220216194633975](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161946117.png)

![image-20220216194727444](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161947553.png)



- 在 JDK9中，newInstance过时代替 c1.getDeclaredConstructor().newInstance();
- 反射的作用和泛型类似，灵活性高，避免写冗余代码，特别写公共部分很实用，因为直接调用相当于写死在代码中了，而这种方式可以从外部传入任意的方法名和参数来执行方法
- 扫描类是因为你不知道用你框架的用户到底会怎么写，例如你现在要写个框架，需要扫描用户写的类，但是你不知道用户写了哪些类。，你需要查看每个类是否满足你的规定，比如有某个方法或者注解，符合标准的，类似于Controller，就把类加入你的调度器或者事件分发器



## 性能对比分析

![image-20220216195003530](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161950682.png)

```java
package annotations_reflections.reflection;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @author miemiehoho
 * @date 2022/2/16 19:50
 */
// 分析性能问题
public class Demo9 {

    // 普通方式调用
    public static void test1() {
        User user = new User();

        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 10_0000_0000; i++) {
            user.getName();
        }
        long endTime = System.currentTimeMillis();
        System.out.println("普通方法执行时间：" + (endTime - startTime) + "ms");
    }

    // 反射方式调用
    public static void test2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        User user = new User();
        Class c = user.getClass();
        Method getName = c.getDeclaredMethod("getName", null);
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 10_0000_0000; i++) {
            getName.invoke(user, null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("反射方式调用方法执行时间：" + (endTime - startTime) + "ms");
    }

    // 反射方式调用,关闭权限检查
    public static void test3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        User user = new User();
        Class c = user.getClass();
        Method getName = c.getDeclaredMethod("getName", null);
        getName.setAccessible(true);
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 10_0000_0000; i++) {
            getName.invoke(user, null);
        }
        long endTime = System.currentTimeMillis();
        System.out.println("反射方式调用,关闭权限检查调用方法执行时间：" + (endTime - startTime) + "ms");
    }

    public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException {
        test1();
        test2();
        test3();
    }

}
```

输出结果：

```
普通方法执行时间：5ms
反射方式调用方法执行时间：1952ms
反射方式调用,关闭权限检查调用方法执行时间：1081ms
```



## 获取泛型信息

![image-20220216195839005](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202161958145.png)

```java
package annotations_reflections.reflection;

import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * @author miemiehoho
 * @date 2022/2/16 20:08
 */
// 通过反射获取泛型
public class Demo10 {

    public void test1(Map<String, User> map, List<User> list) {
        System.out.println("test1");
    }

    public Map<String, User> test2() {
        System.out.println("test2");
        return null;
    }

    public static void main(String[] args) throws NoSuchMethodException {
        Class<Demo10> c = Demo10.class;
        Method test1 = c.getMethod("test1", Map.class, List.class);
        Type[] genericParameterTypes = test1.getGenericParameterTypes();// 获得泛型参数信息
        for (Type genericParameterType : genericParameterTypes) {
            System.out.println("#" + genericParameterType);
            if (genericParameterType instanceof ParameterizedType) {
                // instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例
                Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();
                for (Type actualTypeArgument : actualTypeArguments) {
                    System.out.println(actualTypeArgument);
                }
            }
        }

        // 获得返回值泛型
        System.out.println("============================");
        Method test2 = Demo10.class.getMethod("test2", null);
        Type genericReturnType = test2.getGenericReturnType();
        if (genericReturnType instanceof ParameterizedType) {// 如果返回值类型是参数化类型
            Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();// 强转为参数化类型
            for (Type actualTypeArgument : actualTypeArguments) {
                System.out.println(actualTypeArgument);
            }
        }

    }
}
```



## 获取注解信息

![](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202162018168.png)

![](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202162027204.png)

```java
package annotations_reflections.reflection;

import java.lang.annotation.*;
import java.lang.reflect.Field;

/**
 * @author miemiehoho
 * @date 2022/2/16 20:52
 */
// 练习使用反射操作注解
public class Demo11 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {
        Class c = Class.forName("annotations_reflections.reflection.Student2");

        // 通过反射获得注解
        Annotation[] annotations = c.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation);
        }

        // 获得注解的 value的值
        TableKuang tableKuang = (TableKuang) c.getAnnotation(TableKuang.class);
        String value = tableKuang.value();
        System.out.println(value);

        // 获得类指定的注解
        Field name = c.getDeclaredField("name");
        FieldKuang annotation = name.getAnnotation(FieldKuang.class);
        System.out.println(annotation.columnName());
        System.out.println(annotation.type());
        System.out.println(annotation.length());
    }
}

@TableKuang("db_student")
class Student2 {
    @FieldKuang(columnName = "db_id", type = "int", length = 10)
    private int id;
    @FieldKuang(columnName = "db_age", type = "int", length = 10)
    private int age;
    @FieldKuang(columnName = "db_name", type = "varchar", length = 3)
    private System name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public System getName() {
        return name;
    }

    public void setName(System name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student2{" +
                "id=" + id +
                ", age=" + age +
                ", name=" + name +
                '}';
    }

    public Student2(int id, int age, System name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public Student2() {
    }
}

// 类名的注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface TableKuang {
    String value();
}


// 属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface FieldKuang {
    String columnName();

    String type();

    int length();
}
```