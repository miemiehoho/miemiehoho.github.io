Java语言一开始就支持I/O,最初是通过 java.io包中的类和接口提供支持的。

目前 Java 支持 文件 I/O 和 流式 I/O，流式 I/O 分为输入流和输出流。

所有的数据流都是单向的，使用输入流只能从中读取数据；使用输出流，只能向其写出数据。

![image-20211217090031091](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112170900234.png)

按照处理数据的类型分，数据流又可分为 二进制流 和 文本流，也称 字节流和字符流，它们处理信息的基本单位分别是字节和字符。

不管数据来自何处或流向何处，也不管是什么类型，顺序读写数据的算法基本上是一样的。如果需要从外界获得数据，首先需要建立输入流对象，然后从输入流中读取数据；如果需要将数据输出，需要建立输出流对象，然后向输出流中写出数据。

## 二进制 I/O 流

### File 类

常用操作方法：

![image-20211217091802244](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112170956702.png)

```java
package java_basis.io;

import java.io.File;
import java.io.IOException;

/**
 * @author miemiehoho
 * @date 2021/12/17 9:08
 */
public class FileDemo {
    public static void main(String[] args) {
        try {
            File file = new File("src/java_basis/io/practice.txt");
            System.out.println(file.exists());// 输出文件是否存在
            boolean success = file.createNewFile();// 创建文件是否成功
            System.out.println(success);
            System.out.println(file.exists());
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }
}
```

### 文本 I/O 与 二进制 I/O

文件通常可以分为文本文件和二进制文件。文本文件是包含字符序列的文件，而内容必须按二进制序列处理的文件称为二进制文件

由于二进制 I/O 不需要 进行编码和解码，所以它的优点是处理效率比文本文件高，二进制文件与主机的编码方案无关，因此它是可移植的。

### InputStream类 和 OutputStream类

InputStream类是二进制输入流的根类，OutputStream类是二进制输出流的根类

![image-20211217101022395](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112171010551.png)



**注意：**read() 读取字节的返回值是 **0~255** 的整数值；write() 只把整数**低8位**写入输出流



上述方法都抛出 IOException异常，当程序不能读写数据时抛出该异常，因此使用这些方法要么 try-catch捕获，要么声明方法抛出异常

### 常用 二进制 I/O 流

#### 1. FileInputStream 类 和 FileOutputStream 类

FileInputStream 类 和 FileOutputStream 类用来实现文件的输入输出处理，由它们所提供的方法可以打开本地文件，并进行顺序读写。

 **FileInputStream 类** 常用构造方法：

- FileInputStream(String name) ：内部调用了 File(String pathname) 方法
- FileInputStream(File file)

**FileOutputStream 类** 常用构造方法：

- FileOutputStream(String name)
- FileOutputStream(String name, boolean append)：append 参数为 true则不覆盖原来的内容
- FileOutputStream(File file)

InputStream类 和 OutputStream类 及其子类都实现了 `java.lang.AutoClosable` 接口，因此可以在 `try-with-resources`语句中使用，当流使用后自动将它们关闭。

```java
package java_basis.io;

import java.io.*;

/**
 * @author miemiehoho
 * @date 2021/12/17 10:25
 */
public class OutputDemo {
    public static void main(String[] args) {
        File file = new File("src/java_basis/io/output.txt");
        try (FileOutputStream out = new FileOutputStream(file);
        ) {
            for (int i = 0; i < 10; i++) {
                out.write((int) (Math.random() * 90) + 10000);// 只把整数低8位写入输出流
            }
            out.flush();// 刷新输出流，输出全部缓存内容

        } catch (IOException e) {
            e.printStackTrace();
        }

        try (FileInputStream in = new FileInputStream(new File("src/java_basis/io/output.txt"));
        ) {
            int c = in.read();
            while (c != -1) {
                System.out.print(c + " ");
                c = in.read();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```



#### 2. BufferedlnputStream 类和 BufferedOutputStream 类

BufferedlnputStream 为缓冲输入流， BufferedOutputStream 为缓冲输出流， 这两个类用 来对流实现缓冲功能。使用缓冲流可以**减少读写数据的次数， 加快输入输出的速度**。缓冲流使用**字节数组**实现缓冲，当输入数据时，数据成块地读入数组缓冲区 ， 然后程序再从缓 冲区中读取单个字节； 当输出数据时， 数据先写入数组缓冲区 ， 然后再将整个数组写到输 出流中。

**BufferedlnputStream** 的构造方法：

- BufferedlnputStream(InputStream in) ：使用参数 指定的输入流对象创建一个缓冲 输入流

- BufferedlnputStream(InputStream in, int size) ：通过 size 参数指定缓冲区大小，默认为 512 字节。 


**BufferedOutputStream**  的构造方法：

- BufferedOutputStream(OutputStream out) ：使用参数 指定的输入流对象创建一个缓冲 输出流
- BufferedOutputStream(OutputStream out, int ize) ：通过 size 参数指定缓冲区大小 默认为 **512** 字节 

**使用上面两个类 可以把输入输出流包装成具有缓冲功能的流 从而提高输入输出的效率**

#### 3. DatalnputStream 类和 DataOutputStream 类

DatalnputStream DataOutputStream 类分别是数据输入流和数据输出流。使用这两个 类可以实现基本数据类型的输入输出。

这两个类的构造方法如下：

- DatalnputStream(InputStream instream) 
- DataOutputStream(OutputStream outstream) 

DatalnputStream 类 和 DataOutputStream 类中定 了读写基本类型数据和字符串的方法，这两 类分别实现了 Datalnput和DataOutput 接口中定义的方法

```java
package java_basis.io;

import java.io.*;

/**
 * @author miemiehoho
 * @date 2021/12/17 10:57
 */
public class DataStreamDemo {
    public static void main(String[] args) {

        // 使用了 try-with-resources ，当流使用后自动将流关闭
        try (DataOutputStream out = new DataOutputStream
                (new BufferedOutputStream
                        (new FileOutputStream("src/java_basis/io/data.dat"))
                );) {
            out.writeDouble(123.446);
            out.writeInt(66);
            out.writeUTF("牛逼 PLUS");
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println("数据写入完成");

        try (DataInputStream in = new DataInputStream(
                new BufferedInputStream(new FileInputStream("src/java_basis/io/data.dat")));) {

            while (in.available() > 0) {
                double d = in.readDouble();
                int i = in.readInt();
                String s = in.readUTF();
                System.out.println("d:" + d);
                System.out.println("i:" + i);
                System.out.println("s:" + s);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

在从输入流中读数据时 ， 如果到达输入流的末尾还继续从中读取数据 ， 就会发生 **EOFException** 异常，这个异常可用来检测是否已经到达文件末尾。

#### 4. PrintStream 类

PrintStream 类为打印各种类型的数据提供了方便。 PrintStream 类定义了多个 print(）和 println(）方法，可以打印各种类型的数据。这些方法都是把数据转换成字符串，然后输出。

如果输出到文件中则可以用记事本浏览。 println(）方法输出后换行，print(）方法输出后不换 行。当把对象传递给这两个方法时则先调用对象的 toString(）方法将对象转换为字符串形式， 然后输出。在前面章节大量使用的 System.out 对象就是 PrintStream类的一个实例，用千向 控制台输出数据。

### 标准输入输出流

计算机系统都有标准的输入设备和标准输出设备。对一般系统而言， 标准输入设备通常是键盘， 而标准输出设备是屏幕。 Java 系统事先定义了两个对象 System.in 和 System.out, 分别与系统的标准输入和标准输出相联系，另外还定义了标准错误输出流 System.err 。 

System.in 是 InputStream类的实例。可以使用 read(）方法从键盘上读取字节，也可以将 它包装成数据流读取各种类型的数据和字符串。 System.out 和 System.err 是 PrintStream类的实例 ， 可以使用该类定义的方法输出各种类型数据。

## 文本 I/O 流

以字符为基本单位的文本 I/0 流， 也叫字符 I/0 流

文本 I/0 流的类层次结构图

![image-20211217121902004](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112171219291.png)

### Reader 类 和 Writer 类

抽象类 Reader 和 Writer 分别是文本输入流和输出流的根类， 它们实现字符的读写 。

Reader 类和 Writer 类的方法在发生 I/0 错误时都抛出 IOException 异常， 因此在程序 中应该捕获异常或声明抛出异常。

### FileReader 类和 FileWriter 类

FileReader 类是文件输入流， FileWriter 类是文件输出流。当操作的文件中是文本数据时 ， 推荐使用这两个类。

**FileReader** 类构造方法

-  public FileReader(String fileName) ： 用字符串表示的文件构造一个文件输入流对象

- public FileReader(File file) ： 用 File 对象表示的文件构造一个文件输入流对象

**FileWriter** 类构造方法

- public FileWriter(String fileName) ： 用参数 fileName 指定的文件创建一个文件输出流 对象
- public File Writer(File file) ： 用参数 file 指定的 File 对象创建一个文件输出流对象
-  public FileWriter(String fileName, boolean append) ： 使用该构造方法创建文件输出流 对象时，如果参数 append 指定为 true, 则可以向文件末尾追加数据，否则覆盖文件 原来的数据。

FileReader 类是 lnputStreamReader 的子类，实现二进制输入流向文本输入流的转换功能 ； FileWriter 类是 OutputStreamWriter 的子类， 实现文本输出流向二进制输出流的转换。

```java
package java_basis.io;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * @author miemiehoho
 * @date 2021/12/17 12:31
 */
public class FileCopyDemo {
    public static void main(String[] args) {
        File inputFile = new File("src/java_basis/io/input.txt");
        File outputFile = new File("src/java_basis/io/output.txt");
        try (
                FileReader in = new FileReader(inputFile);
                FileWriter out = new FileWriter(outputFile);
        ) {
            int c = in.read();
            while (c != -1) {
                out.write(c);
                c = in.read();
            }
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }
}
```

### BufferedReader 类和 BufferedWriter 类

BufferedReader 类和 BufferedWriter 类分别实现了具有缓冲功能的字符输入输出流。这
两个类用来将其他的字符流包装成缓冲字符流，以提高读写数据的效率。

**BufferedReader 类** 的构造方法

- public BufferedReader(Reader in) ： 使用默认的缓冲区大小创建缓冲字符输入流
- public BufferedReader(Reader in, int sz) ： 使用指定的缓冲区大小创建缓冲字符输入流

BufferedReader 类除覆盖了父类 Reader 类的方法外，还定义了下面的常用方法：

- public String readLine(） ： 从输入流中读取一行文本

**BufferedWriter 类** 的构造方法

- BufferedWriter(Writer out) ： 使用默认的缓冲区大小创建缓冲字符输出流
- BufferedWriter(Writer out, int sz) ： 使用指定的缓冲区大小创建缓冲字符输出流

除继承 Writer 类的方法外， 该类提供了一个 void newLine(） 方法， 用来写一个行分隔符。它是系统属性 line. separator 定义的分隔符。通常 Writer 直接将输出发送到基本的字符 或字节流， 建议在 Writer 上（如 FileWriter 和 OutputStreamWriter) 包装 BufferedWriter 。 例如 ：
`BufferedWriter br = new BufferedWriter ( new FileWriter ("output.txt")) ;`

```java
package java_basis.io;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * 程序逐行读取文本文件， 对每行解析单词数组并统计每个单词数组元素之和，从而统
 * 计文章中单词数量。这里假设单词的分隔符只用空格、 逗号和点号 3 种。
 *
 * @author miemiehoho
 * @date 2021/12/17 12:44
 */
public class WordsCount {
    public static void main(String[] args) {
        try (
                BufferedReader reader = new BufferedReader(new FileReader("src/java_basis/io/article.txt"));
        ) {
            int sum = 0;
            String aLine = reader.readLine();
            while (aLine != null) {
                String[] words = aLine.split("[ ,.]");
                sum += words.length;
                aLine = reader.readLine();
            }
            System.out.println("sum = " + sum);
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }
}
```

#### PrintWriter 类

Print Writer 类实现字符打印输出流

#### 使用 Scanner 对象

使用 Scanner 类从键盘读取数据，在创建 Scanner 对象时将标准输入设备 System.in 作 为其构造方法的参数。使用 Scanner 还可以关联文本文件， 从文本文件中读取数据。

**Scanner 类**的常用的构造方法

- public Scanner(String source) ： 用指定的字符串构造一个 Scanner 对象， 以便从中读取数据
- public Scanner(InputStream source) ： 用指定的输入流构造一个 Scanner 对象，以便从中读取数据

创建 Scanner 对象后 ， 就可以根据分隔符对源数据进行解析。使用 Scanner 类的有关方法可以解析每个标记 ( token)。默认的分隔符是空白 ， 包括回车、换行、空格、制表符等， 也可以指定分隔符。

对每个 nextXxx() 方法， Scanner 类还提供一个 hasNextXxx(）方法,使用该方法可以判断是否还有下一个标记。

```java
package java_basis.io;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Scanner;

/**
 * @author miemiehoho
 * @date 2021/12/17 12:58
 */
public class TextFileDemo {
    public static void main(String[] args) {
        try (
                Scanner scanner = new Scanner(new FileInputStream("src/java_basis/io/number.txt"));
        ) {
            while (scanner.hasNextInt()) {
                System.out.println(scanner.nextInt());
            }
        } catch (IOException e) {
            System.out.println(e.toString());
        }
    }
}
```

### 对象序列化

对象的寿命通常随着创建该对象程序的终止而终止。有时可能需要将对象的状态保存
下来， 在需要时再将其恢复。对象状态的保存和恢复可以通过对象 I/0 流实现。

#### 对象序列化与对象流

**1. Serializable 接口**

将程序中的对象输出到外部设备（如磁盘、 网络）中，称为对象序列化 (serialization) ;
反之， 从外部设备将对象读入程序中称为对象反序列化 ( deserialization) 。 一个类的对象要实现对象序列化，必须实现 java.io.Serializable 接口 ， 该接口的定义如下：
`public interface Serializable{}`

Serializable 接口只是标识性接口，其中没有定义任何方法。 一个类的对象要序列化，除了必须实现 Serializable 接口外，还需要创建对象输出流和对象输入流，然后，通过对象 输出流将对象状态保存下来，通过对象输入流恢复对象的状态

**2. ObjectlnputStream 类和 ObjectOutputStream 类**

在 java.io 包中定义了 ObjectlnputStream和 ObjectOutputStream 两个类， 分别称为对象 输入流和对象输出流。 ObjectlnputStream 类继承了 InputStream 类， 实现了 Objectlnput 接 口，而 Objectlnput 接口又继承了 Datalnput 接口。Obj ectOutputStream类继承了 OutputStream 类， 实现了 ObjectOutput 接口 ， 而 ObjectOutput 接口又继承了 DataOutput 接口。

#### 向 ObjectOutputStream 中写入对象

若将对象写到外部设备需要建立 ObjectOutputStream类的对象， 构造方法为 ：

`public Ob jectOutputStream(OutputStream out)`

参数 out 为一个字节输出流对象。创建了对象输出流后 ， 就可以调用它的 writeObject()方法将一个对象写入流中，该方法格式为 ：

`public final void writeObject(Object obj) throws IOException`

若写入的对象不是可序列化的，该方法会抛出 NotSerializableException 异常。由于ObjectOutputStream 类实现了 DataOutput 接口，该接口中定义多个方法用来写入基本数据 类型， 如 writelnt(）、 writeFloat(）及 writeDouble(）等，可以使用这些方法向对象输出流中写入基本数据类型。

下面代码将一些数据和对象写到对象输出流中：

```java
FileOutputStream fos = new FileOutputStream("data.ser"); 
ObjectOutputStream oop = new ObjectOutputStream(fos); 
oos.writelnt(2010) ; 
oos.writeObject("你好") ; 
oos.writeObject(LocalDate.now());
```

ObjectOutputStream必须建立在另一个字节流上， 该例是建立在 FileOutputStream上的,然后向文件中写入一个整数、字符串“你好”和一个 LocalDate 对象。

#### 从 ObjectlnputStream 中读出对象

若要从外部设备上读取对象， 需建立 ObjectlnputStream 对象，该类的构造方法为 ：

`public ObjectinputStream(InputStream in)`

参数 in 为字节输入流对象,通过调用 ObjectlnputStream 类的方法 readObject(）方法可
以将一个对象读出 ， 该方法的声明格式如下：

`public final Object readObject() throws IOException`

在使用 readObject(）方法读出对象时， 其类型和顺序必须与写入时一致。由于该方法返回 Object 类型， 因此在读出对象时需要适当的类型转换。

Obj ectlnputStream类实现了 Datalnput接口，该接口中定义了读取基本数据类型的方法，如 readlnt()、readFloat() 及 readDouble()，使用这些方法可以从 ObjectlnputStream 流中读取基本数据类型。

下面代码在 InputStream 对象上建立一个对象输入流对象。

```java
FileInputStream fis = new FileinputStream("data.ser"); 
ObjectInputStream oip = new ObjectInputStream(fis); 
int i = ois.readint();
String today = (String)ois.readObject();
LocalDate date = (LocalDate)ois.readObject();
```

与 ObjectOutputStream 一样， ObjectlnputStream 也必须建立在另一个流上，本例中就
是建立在 FilelnputStream 上的。然后使用 readlnt(）方法和 readObject(）方法读出整数、字符串和 LocalDate 对象。

**实现对象的序列化和反序列化代码实例：**

```java
package java_basis.io;

import java.io.Serializable;

/**
 * @author miemiehoho
 * @date 2021/12/17 14:00
 */
public class Customer implements Serializable {
    public int id;
    public String name;
    public String address;

    public Customer(int id, String name, String address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }
}
```

```java
package java_basis.io;

import java.io.*;
import java.time.LocalDate;

/**
 * @author miemiehoho
 * @date 2021/12/17 14:02
 */
public class ObjectSerializeDemo {
    public static void main(String[] args) {
        Customer customer = new Customer(101, "李密", "北京市朝阳区");
        LocalDate today = LocalDate.now();
        // 序列化
        try (
                OutputStream out = new FileOutputStream("src/java_basis/io/customer.dat");
                ObjectOutputStream oos = new ObjectOutputStream(out)
        ) {
            oos.writeObject(customer);
            oos.writeObject(today);
        } catch (IOException e) {
            System.out.println(e.toString());
        }

        // 反序列化
        try (
                InputStream in = new FileInputStream("src/java_basis/io/customer.dat");
                ObjectInputStream ois = new ObjectInputStream(in)
        ) {
            Customer cs = (Customer) ois.readObject();
            System.out.println(cs.id);
            System.out.println(cs.name);
            System.out.println(cs.address);
            LocalDate date = (LocalDate) ois.readObject();
            System.out.println("日期：" + date);
        } catch (IOException e) {
            System.out.println(e.toString());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

**对象序列化**需要注意的事项如下:

- 序列化只能保存对象的非 static 成员，不能保存任何成员方法和 static 成员变量，而且序列化保存的只是变量的值；
- 用 transient 关键字修饰的变量为临时变量，也不能被序列化； 
- 对于成员变量为引用类型时， 引用的对象也被序列化

#### 序列化数组

如果数组中的所有元素都是可序列化的，这个数组就是可序列化的。 一个完整的数组可以用 writeObject(）方法存入文件，之后用 readObject(）方法读取到程序中。

```java
package java_basis.io;

import java.io.*;

/**
 * @author miemiehoho
 * @date 2021/12/17 15:14
 */
public class ArraySerialDemo {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3, 4, 5};
            String[] cities = {"北京", "上海", "广州"};
            // 序列化
            try (
                    OutputStream os = new FileOutputStream("src/java_basis/io/array.dat", true);
                    ObjectOutputStream oos = new ObjectOutputStream(os)
            ) {
                oos.writeObject(numbers);
                oos.writeObject(cities);
            } catch (IOException e) {
                System.out.println(e.toString());
            }
            // 反序列化
            try (
                    InputStream is = new FileInputStream("src/java_basis/io/array.dat");
                    ObjectInputStream ois = new ObjectInputStream(is);
            ) {
                int[] num = (int[]) ois.readObject();
                for (int n : num) {
                    System.out.print(n + " ");
                }
                System.out.println();
                String[] c = (String[]) ois.readObject();
                for (String s : c) {
                    System.out.print(s + ",");
                }
            } catch (IOException e) {
                System.out.println(e.toString());
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

## NIO 和 NIO.2

为了增强 Java I/0 功能， 在 JDK 1.4 中增加了一些新的 APL 称为 NIO (new I/0 ) ,NIO API 是java.nio 包及其子包的一部分。在 JDK 7 中又新引进了一些包， 称作 NI0.2, 用 来对现有技术进行补充。 NI0.2 的接 口和类通过java.nio. file 包及其子包提供。

### 文件系统和路径

一个文件系统可以包含三类对象： 文件、 目录（也称文件夹）和符号链接( symbolic link ) 。

当今的大多数操作系统都支持文件和目录， 并且允许目录包含子目录。处于目录树顶部的 目录称作根目录。 Linux/UNIX 类操作系统只有一个根目录： ”/“ , 且支持符号链接。 Windows 系统可以有多个根目录： “C:\" "D:\" 等 ， 且不支持符号链接。

在文件系统中 ， 文件和目录都是通过路径表示的 ， 路径可以是绝对的 ， 也可以是相对 的。路径通常以根结点开头。图 13-6 显示了一个 Windows 系统中目录树结构。这里的根目录是“D\“。 report.txt 文件表示如下：

`D:\study\user\report.txt`

![image-20211217153147490](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112171531576.png)

这里 ， “D:\ " 表示根结点 ， 反斜线（＼）为路径分隔符。

绝对路径是以根元素为起点的路径。例如 ，D: \study\user\report. txt 就是绝对路径。绝对路径包含 定位文件的所有信息。相对路径是不包含根元素的路径。例如 ， study\com\Hello.java 是相对路径。只通过相对路径不能定位文件， 要准确定位 文件还需要另外的路径信息。

> 在 Solaris OS 和 Linux 系统中，文件系统是单根结构，根结点为 ( / )，路径分隔符为斜线 ( / )

### FileSystem 类

FileSystem 表示一个文件系统， 是一个抽象类， 可以调用 FileSystems 类的getDefault(）静态方法来获取当前的文件系统：

`FileSystem fileSystem = FileSystems.getDefault();`

### Path 对象

在 Java 7 之前,文件和目录用 File 对象表示。由千使用 File 类存在着许多不足， 因此在 Java 7 中应使用 NIO.2 的 java.nio.file.Path 接口代替 File 

Path 对象在文件系统中表示文件或目录。这个接口命名比较恰当 ，表示一个路径， 可以是一个文件、 一个目录，也可以是一个符号链接， 还可以表示一个根目录。

正如名称所示， Path 在文件系统中表示路径。 一个 Path 对象包含构成路径的目录列表和文件名 ， 用来检查、定位和操作文件。在 Windows 系统中 ， Path 对象使用 Windows 语 法表示（如 D:\study\com\demo ) 。

有多种方式创建和操作 Path 实例，可以把一个 Path 对象追加到另一个 Path 对象上、 抽取 Path 对象部分内容、与另一个 Path 对象比较等。

> 对 JDK 7 之前使用 java.io.File 的代码，可以使用 File 类的 toPath(）方法转换成 Path 对象， 从而利用 Path 功能。

#### 1. 创建 Path 实例

Path 实例包含确定文件或目录位置的信息。在创建 Path 实例时， 通常要提供一系列名称， 如根元素或文件名等。 一个 Path 可以只包含路径名或文件名。

可以使用 Paths （注意是复数）类的 get(）方法创建 Path 对象：

```java
Path p1 = Paths.get("D:\\study\\com\\Hello.java");
Path p2 = Paths.get(args[0]);
Path p3 = Paths.get(URI.create("file:///users/joe/FileTest.java"));
```

实际上， Paths 类的 get(）方法是下面代码的简化形式：

`Path p4 = FileSystems.getDefault().getPath("D:\\study\\corn\\Hello.java");`

> 创建一个 Path 对象并不意味着在磁盘中创建一个物理意义上的文件或目录。与 Path 对应的文件或目录可以不存在。为 了 创建文件或目录， 需要使用 Files 类。

#### 2. 检索路径信息

Path 对象可以看作是一个名称序列 ， 每一级目录可以通过索引指定。目录结构的顶层
索引为 0 , 目录结构的底层元素索引是 n-1 , n 是总层数。例如 ， getName(0)方法将返回最顶层目录名称。

```java
public static void main(String[] args) {
    Path path = Paths.get("D:\\study\\user\\report.txt");
    System.out.println("toString: " + path.toString());
    System.out.println("getFileName: " + path.getFileName());
    System.out.println("getName[0]: " + path.getName(0));
    System.out.println("getNameCount: " + path.getNameCount());
    System.out.println("subpath(0,2): " + path.subpath(0, 2));
    System.out.println("getParent: " + path.getParent());
    System.out.println("getRoot: " + path.getRoot());
}
```

上述代码的输出结果如下:

```java
toString: D:\study\user\report.txt
getFileName: report.txt
getName[0]: study
getNameCount: 3
subpath(0,2): study\user
getParent: D:\study\user
getRoot: D:\
```

## Files 类操作

j ava.nio. file.Files 类是一个功能非常强大的类。 该类定义了大量的静态方法用来读、 写 和操纵文件与目录。 Files 类主要操作 Path 对象。

### 创建和删除目录及文件

Files 类提供了下面的方法创建、删除目录和文件。

- public static Path createDirectory(Path dir, FileAttribute<？>…attrs) ： 
  - 创建由 dir指定的 目录，参数 attrs 指定目录的属性，如果不需要设置属性，可忽略该参数。如果创建 的目录已经存在该方法将抛出 FileAlreadyExistsException 异常。
- public static Path createFile(Path file, FileAttribute<？＞…attrs) ： 
  - 创建由 file 指定的文件。 如果文件的父目录不存在， 该方法会抛出一个 IOException 异常。如果已经存在一个同名的文件， 将抛出 FileAlreadyExistsException 异常。
- public static void delete(Path path) ：
  -  删除由 path 指定的目录或文件。 如果 path 是一个 目录，要求目录必须为空。如果 path 不存在， 则抛出 NoSuchFileException 异常。
- public static void deletelfExists(Path path) ： 
  - 如果 path 对象存在则将其删除。如果 path 是目录，要求目录必须为空 ， 如果不为空则抛出 DirectoryNotEmpty Exception 异常。

Files 类提供了两个删除文件或目录的方法。 delete(Path)方法删除文件，如果删除失败 抛出异常。例如，如果文件不存在将抛出 NoSuchFileException 异常，可以捕获有关异常确定删除文件失败的原因。

```java
try {
    Files.delete(path);
} catch (NoSuchFileException x) {
    System.out.println("No such file" + path);
} catch (DirectoryNotEmptyException x) {
    System.err.format(" The directory is not empty");
} catch (IOException x) { //文件许可问题在此捕获 
    System.err.println(x);
}
```

deletelfExists(Path)方法也可删除文件， 但如果文件不存在将不抛出异常。这在多个线程删除文件、又不想抛出异常时特别有用，因为可能一个线程先执行了删除。

### 文件属性操作

可以使用 Files 类的方法检查 Path 对象表示的文件或目录是否存在、是否可读、是否可写、是否可执行等。

- public static boolean exists(Path path, LinkOption…options) ： 
  - 检查 path 所指的文件或目录是否存在。
- public static boolean notExists(Path path, LinkOption…options) ： 
  - 检查 path 所指的文件或目录是否不存在。注意，**! Files.exists(path)与Files.notExists(path)并不等价**。如果 exists(path)与 notExists(path)都返回 false, 表示文件不能检验
- public static boolean isReadable(Path path) ： 
  - 检查 path 所指的文件或目录是否可读
- public static boolean is Writable(Path path) ： 
  - 检查 path 所指的文件或目录是否可写 。 
- public static boolean isExecutable(Path path) ： 
  - 检查 path 所指的文件或目录是否可执行。
- static boolean isRegularFile(Path path, LinkOption…options) ： 
  - 如果指定的 Path 对象是 一 个文件返回 true 。

下面代码检验一个文件是否存在、是否可执行：

```java
Path path = Paths.get("D:\\study\data.ser");
boolean isRegular = Files.isRegularFile(path) && Files.isReadable(path) && Files.isExecutable(path);
```

Files 类中包含了下面一些获得或设置文件一个属性的方法：

- static long size(Path path) ： 
  - 返回指定文件的字节大小。 
- static boolean isDirectory(Path path, LinkOption…options) ：
  -  如果指定的 Path 对象是一 个目录返回 true 。
- static boolean isHidden(Path path) ： 
  - 如果指定的 Path 对象是隐藏的返回 true 。 
- static FileTime getLastModifiedTime(Path path, LinkOption…options) ：
  -  返回指定文件 的最后修改时间。
- static Path setLastModifiedTime(Path path, File Time) ： 
  - 设置指定文件的最后修改时间。
- static UserPrincipal getOwner(Path path, LinkOption…options) ： 
  - 返回指定文件的所有者。
- static Path setOwner(Path path, UserPrincipal) ： 
  - 设置指定文件的所有者。

- static Object getAttribute(Path path, String, LinkOption…options) ： 
  - 返回用字符串指定文件的属性。
- static Path setAttribute(Path path, String, Object obj , LinkOption…options) ： 
  - 设置用字符串指定文件的属性。

下面程序演示了 Files 类几个方法的使用 ：

```java
package java_basis.nio;

import java.io.IOException;
import java.nio.file.*;

/**
 * @author miemiehoho
 * @date 2021/12/17 16:16
 */
public class FileDemo {
    public static void main(String[] args) {
        Path path = Paths.get("D:\\study\\demo");
        Path file = Paths.get("D:\\study\\demo\\report.txt");
        try {
            if (!Files.exists(path)) {
                path = Files.createDirectories(path);// 创建路径
            }
            if (!Files.exists(file)) {
                file = Files.createFile(file);// 创建文件
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(Files.exists(path));
        System.out.println(Files.isReadable(file));
        try {
            Files.delete(path);
        } catch (NoSuchFileException x) {
            System.out.println("NoSuchFile:" + path);
        } catch (DirectoryNotEmptyException x) {
            System.err.println("The directory is not empty");
        } catch (IOException e) {
            // 文件许可问题在此捕获
            e.printStackTrace();
        }
    }
}
```

### 文件和目录的复制与移动

使用 Files类的 copy(）方法可以复制文件和目录， 使用 move(）方法可以移动目录和文件。copy(）方法的一般格式为 ：

`public static Path copy (Path source , Path target, CopyOption··· options)`

source 为源文件： target 为目标文件； 可选的参数 options 为 CopyOption 接口对象， 是java.nio.file 包的一个接口 。 StandardCopyOption 枚举是 CopyOption 接 口 的一个实现， 提供 了下面三个复制选项：

- ATOMIC MOVE: 将移动文件作为一个原子的文件系统操作 。 
- COPY ATTRIBUTES: 将属性复制到新文件中。 
- REPLACE EXISTING: 如果文件存在，将它替换。

在复制文件时， 如果源文件不存在 ， 将产生 NoSuchFileException 异常。如果目标文件存在 ， 将产生 FileAlreadyExistsException 异常。如果要覆盖目标文件 ， 应指定 REPLACE_EXISTING 选项。目录也可以复制， 但目录中的文件不能复制 ， 也就是即使原 来目录中包含文件， 新目录也是空的。

下面代码说明了 copy(）方法的使用：

```java
Path source = Paths.get("D:\\study\\demo\\report.txt"),
        target = Paths.get("D:\\study\\demo\\backup.txt");
try {
    Files.copy(source, target,
            StandardCopyOption.REPLACE_EXISTING);
} catch (NoSuchFileException x) {
    x.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
```

除了复制文件外， Files 类中还定义了在文件和流之间复制的方法：

- public static long copy(InputStream in, Path target, CopyOption…options) ： 
  - 从输入流中 将所有字节复制到目标文件中。
- public static long copy(Path source, OutputStream out) ： 
  - 将源文件中的所有字节复制到 输出流中。

使用 move(）方法可以移动或重命名文件和目录， 格式如下：

`public static Path move (Path source, Path target, CopyOption···options)`

如果目标文件存在， 移动将失败， 除非指定了 REPLACE_EXISTING 选项。空目录也可以被移动。

移动文件代码实例：

```java
Path source = Paths.get("D:\\study\\demo\\report.txt"),
        target = Paths.get("D:\\data\\demo\\report.txt");
try {
    Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
} catch (IOException e) {
    e.printStackTrace();
}
```

### 获取目录的对象

使用 Files 类的 newDirectory Stream(）方法，可以获取目录中的文件、子目录和符号链 接，该方法返回 一 个 DirectoryStream, 使用它可以迭代目录中的所有对象。 new DirectoryStream(）方法的格式如下：

`public static DirectoryStream<Path> newDirectoryStream(Path path)`

DirectoryStream 对象使用之后应该关闭。下面代码片段输出 D:\study 目录中的所有目录和文件名。

```java
Path path = Paths.get("D:\\study");
try {
    DirectoryStream<Path> childs = Files.newDirectoryStream(path);
    for (Path child : childs) {
        System.out.println(child.toString());
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

### 小文件的读写

向es 类提供了从一个较小的二进制文件和文本文件读取与写入的方法。 readAllBytes()方法和 readAllLines())方法分别是从二进制文件和文本文件读取。这些方法可以自动打开和 关闭流， 但不能处理大文件。

使用下面方法可以把字节或行写入文件:

- public static Path write(Path path, byte[] bytes,OpenOption…options) 
- public static Path write(Path path, Iterable<extends CharSequence> lines,Charset cs, OpenOption…options)

第一个方法将字节数组 bytes 写入文件，第二个方法向文件写入若干行。 这两个 write() 方法都带一个可选的 OpenOption 参数， 第二个方法还带一个 Charset 。 OpenOption 接口定 义了打开文件进行写入的选项， StandardOpenOption 枚举实现了该接口并提供了 以下这些值:

- APPEND: 向文件末尾追加新数据,该选项与 WRITE 或 CREATE 同时使用。 
- CREATE: 若文件存在则打开， 若文件不存在则创建新文件。 
- CREATE NEW: 创建一个新文件，如果文件存在则抛出异常。 
- DELETE_ON_CLOSE: 当流关闭时删除文件。 
- DSYNC : 使文件内容与基本存储设备同步。 
- READ： 打开文件进行读取访问。 
- SYNC: 使文件内容和元数据与基本存储设备同步。 
- TRUNCATE EXISTING： 截断文件使其长度为 0 字节，该选项与 WRITE 同时使用。 
- WRITE: 为写数据而打开文件。

使用下面方法可以从文件读取所有字节或行:

- public static byte[] readAllBytes(Path path) ： 从指定的二进制文件中读取所有字节。 
- public static List<String> readAllLines(Path path, Charset cs) ： 从指定的文本文件中读 取所有的行，cs 为使用的字符集。

下面的程序先向文件中写入多行，然后再从文件中读出：

```java
package java_basis.nio;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.*;
import java.util.Arrays;
import java.util.List;

/**
 * @author miemiehoho
 * @date 2021/12/17 16:57
 */
public class FileWriteRead {
    public static void main(String[] args) {
        // 写入文本
        Path textFile = Paths.get("D:\\study\\speeck.txt");
        Charset charset = Charset.forName("UTF-8");
        String line1 = "我正在使用IDEA写代码";
        String line2 = "这让我很舒服。";
        List<String> lines = Arrays.asList(line1, line2);
        try {
            Files.write(textFile, lines, charset, StandardOpenOption.CREATE,
                    StandardOpenOption.TRUNCATE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 读取文本
        List<String> linesRead = null;
        try {
            linesRead = Files.readAllLines(textFile, charset);
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (linesRead != null) {
            for (String line : linesRead) {
                System.out.println(line);
            }
        }
    }
}
```

Charset 抽象类 表示字符集 ， 主要用来对字符进行编码和解码。创建 Charset 最容易的方法是调用 Charset. for Name(）方法， 传递一个字符集名称， 如 US-ASCII 、 UTF-8 等。

#### 使用 Files类 创建流对象

有了 NI0.2 后 ， 就可以调用 Files.newInputStream(）方法， 获得与文件关联的 InputStream 对象来读取数据 ， 调用 Files.newOutputStream(）方法获得与文件关联的 OutputStream对象向文件写数据。 

**newInputStream(）方法**

创建与文件关联的 InputStream 对象使用 Files 类的 newInputStream(）方法， 格式如下 ：

`public static InputStream newinputStream(Path path, OpenOption···options) throws IOException`

从 Files.newInputStream(）方法返回的 InputStream对象没有被缓存 ， 因此可以将它包装 到 BufferedlnputStream 中 以提高性能。

```java
Path path = Paths.get("D:\\study\\output.dat");
try (
        InputStream in = Files.newInputStream(path, StandardOpenOption.READ);
        BufferedInputStream bis = new BufferedInputStream(in)
) {
    // 操作 input 输入流对象
} catch (IOException e) {
    // 处理 e 的异常信息
}
```

**newOutputStream(）方法**

创建与文件关联的 OutputStream 对象使用 Files 类的 newOutputStream(）方法，格式 如下 ：

`public static OutputStream newOutputStream(Path path, OpenOption···options) throws IOException`

从 Files.newOutputStream(）方法返回的 OutputStream 对象没有被缓存，因此可以将它包装到 BufferedOutputStream 中以提高性能。

```java
Path path = Paths.get("D:\\study\\output.dat");
try (
        OutputStream os = Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        BufferedOutputStream bos = new BufferedOutputStream(os);
) {
    // 操作 input 输入流对象
} catch (IOException e) {
    // 处理 e 的异常信息
}
```

**BufferedReader 和 BufferedWriter**

除使用 之前 的方法创建 BufferedReader 和 BufferedWriter 对象外，使用 Files 类 的newBufferedReader(）和 newBufferedWriter(）方法也可创建这两个对象，格式如下：

`public static BufferedReader newBufferedReader (Path path, Charset charset) `

`public static BufferedWriter newBufferedWriter(Path path, Charset charset, OpenOption ···options)`

下面程序向文本文件中写入一行文本，然后读出并输出该文本行。

```java
package java_basis.nio;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

/**
 * @author miemiehoho
 * @date 2021/12/17 20:39
 */
public class TextWriteRead {
    public static void main(String[] args) {
        Path path = Paths.get("D:\\study\\article.txt");
        Charset chinaSet = Charset.forName("GB2312");
        char[] chars = {'\u4F60', '\u597D', ',', '中', '国'};
        // 向文件中写入数据
        try (
                BufferedWriter writer = Files.newBufferedWriter(path, chinaSet)
        ) {
            writer.write(chars);
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 从文件中读出数据
        try (
                BufferedReader reader = Files.newBufferedReader(path,chinaSet)
        ) {
            String line = reader.readLine();
            while (line != null) {
                System.out.println(line);
                line = reader.readLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

程序通过指定的文件创建 BufferedWriter 对象时指定了所使用的字符集， 然后将字符数组写入文件。读取文本时使用 BufferedReader 对象， 创建该对象时也指定了字符集，然 后使用readLine(）方法读取所有行。

## 小结

1. 使用 File 类可以获取文件或目录的属性，可以新建、重命名和删除文件或目录， 但不能对文件进行读写操作。
2. Java 的 I/0 可分为二进制 I/0 和文本 I/0。 二进制 I/0 将数据解释成原始的二进制数值， 文本 I/0 将数据解释成字符序列。文本在文件中存储依赖千文件的编码方式。 Java 自动完成对文本 I/0 的编码和解码。
3. 使用 lnputStream 和 OutputStream 可完成二进制 I/0 。 FilelnputStream 和FileOutputStream 可完成文件 I/0 。 BufferedlnputStream 和 BufferedOutputStream 可以包装任 何一个二进制 I/0 流以提高其性能。 DataInputStream 和 DataOutputStream 类可以用来读写基本类型的数据和字符串。
4. Java 的文本 I/0 需要使用字符输入输出流。 Reader 和 Writer 类是所有字符 I/0 的根类。 FileReader 和 FileWriter 是关联一个文件用于字符 I/0 。 BufferedReader 和 BufferedWriter 可以包装任何一个字符 I/0 流以提高其性能。
5. 可以使用 Scanner 来从一个文本文件中读取字符串和基本数据类型的值， 使用Print Writer 来创建一个文件并且将数据写入文本文件。
6. ObjectlnputStream 和 ObjectOutputStream 类除了可以读写基本类型的数据值和字符串 ， 还可以读写对象。为实现对象的可序列化，对象的定义类必须实现java.io. Serializable 标记接口。
7. 从 Java 7 开始提供的 ］ava.nio.file.Path 表示路径，可替代 File 类。通常使用 Paths类的 get())方法获得 Path 对象。
8. java.nio.file.Files 类是一个功能非常强大的类。该类定义了大量的静态方法用来读、 写和操纵文件与目录。
9. 调用 Files.newlnputStream(）方法， 获得与文件关联的 InputStream 对象来读取数据；调用 Files.newOutputStream(）方法获得与文件关联的 OutputStream 对象向文件写数据。
10. 调用 Files.newBufferedReader(）和 Files.newBufferedWriter(）方法创建 BufferedReader和 BufferedWriter 对象，通过这两个对象可以读写文本数据。
