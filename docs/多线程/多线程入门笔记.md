java如何给一个方法加一个异步线程  

## 线程简介

### 多任务、多线程概念

### 程序、进程、线程概念

 进程是系统分配的，一个进行包含多个线程

Java中的线程有主线程(main)、gc线程

![image-20220129160344944](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291604133.png)

## 线程创建

 main函数是自己写的，是用户线程

gc线程 是垃圾回收线程，是jvm提供的 

### 普通方法调用和多线程的执行逻辑

![image-20220129164403969](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291644130.png)

### 线程三种创建 方式

![image-20220129161011762](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291610693.png)

 

#### 方式一：继承 Thread类

![image-20220129164441242](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291644325.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/29 17:43
 */
public class ThreadTest extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 300; i++) {
            System.out.println("子线程在读书：" + i);
        }
    }

    public static void main(String[] args) {
        // 创建线程对象，调用start方法开启线程
        ThreadTest threadTest = new ThreadTest();
        threadTest.start();
        for (int i = 0; i < 3000; i++) {
            System.out.println("---主线程在干活：" + i);
        }
    }
}
```

##### 总结

- 线程开启不一定立即执行，由cpu调度执行（同时创建多个线程不一定顺序执行）
- Thread 类实现了Runnable接口

#### 方式二：实现Runnable接口

![image-20220129173858532](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291738428.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/29 17:43
 */
public class ThreadTest implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 300; i++) {
            System.out.println("子线程在读书：" + i);
        }
    }

    public static void main(String[] args) {
        // 创建线程对象，通过线程对象开启线程
        new Thread(new ThreadTest()).start();
        for (int i = 0; i < 3000; i++) {
            System.out.println("---主线程在干活：" + i);
        }
    }
}
```

Java是单继承，所以推荐使用 Runnable接口



#### 小结

![image-20220129175119058](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201291751393.png)

#### 初识 并发问题

多个线程操作同一个资源的情况下，产生了线程不安全的问题

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/29 17:59
 */
public class TicketTest implements Runnable {
    private int ticketNum = 10;

    @Override
    public void run() {
        while (ticketNum > 0) {
            // 模拟延时
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "拿到了第：" + ticketNum-- + "张票");
        }
    }

    public static void main(String[] args) {
        TicketTest ticket = new TicketTest();
        new Thread(ticket,"A").start();
        new Thread(ticket,"B").start();
        new Thread(ticket,"C").start();
    }
}
```



```
B拿到了第：10张票
A拿到了第：10张票
C拿到了第：9张票
A拿到了第：8张票
B拿到了第：7张票
C拿到了第：6张票
A拿到了第：5张票
B拿到了第：5张票
C拿到了第：4张票
B拿到了第：3张票
A拿到了第：3张票
C拿到了第：2张票
A拿到了第：1张票
B拿到了第：0张票
C拿到了第：-1张票
```





#### 案例 - 龟兔赛跑

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/29 18:14
 */
public class Race implements Runnable {
    private String winner;

    @Override
    public void run() {
        for (int i = 1; i <= 100; i++) {
            if ("兔子".equals(Thread.currentThread().getName())) {
                i += 9;
            }
            if (i == 80 && "兔子".equals(Thread.currentThread().getName())) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            if (gameOver(i)) {
                break;
            }
            System.out.println(Thread.currentThread().getName() + "跑了" + i + "步");
        }
    }

    private boolean gameOver(int step) {
        if (winner != null) {
            return true;
        }
        if (step >= 100) {
            winner = Thread.currentThread().getName();
            System.out.println("winner is:------" + winner);
            return true;
        }
        return false;
    }

    public static void main(String[] args) {
        Race race = new Race();
        new Thread(race, "兔子").start();
        new Thread(race, "乌龟").start();
    }
}
```



#### 方式三：实现Callable接口

![image-20220130144549882](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301445637.png)

实现Callable的好处：

1. 可以定义返回值
2. 可以抛出异常

```java
package multithread;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

/**
 * @author miemiehoho
 * @date 2022/1/30 14:46
 */
public class CallableTest implements Callable<Boolean> {

    private String url;
    private String name;

    @Override
    public Boolean call() throws Exception {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url, name);
        return true;
    }

    public CallableTest(String url, String name) {
        this.url = url;
        this.name = name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableTest c1 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F0606%252Fa15d45abj00qu9uyp003lc000s8015dc.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040843&t=3e46a9967c3f48cf936664a9c96fa61d", "1.jpg");
        CallableTest c2 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F7c%2F78%2Fc9%2F7c78c9d0fd92023a9b674f749ab46b7b.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040829&t=7014c5a18e48077b92c3af87f5f9bd23", "2.jpg");
        CallableTest c3 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202003%2F05%2F20200305192056_cBatY.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040811&t=266d1172ad9bccd2bac1e02a723b9418", "3.jpg");
        // 创建执行服务
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        // 提交执行
        Future<Boolean> s1 = executorService.submit(c1);
        Future<Boolean> s2 = executorService.submit(c2);
        Future<Boolean> s3 = executorService.submit(c3);
        // 获取结果
        Boolean b1 = s1.get();
        Boolean b2 = s2.get();
        Boolean b3 = s3.get();
        System.out.println(b1);
        System.out.println(b2);
        System.out.println(b3);
        // 关闭服务
        executorService.shutdown();
    }
}

class WebDownloader {

    public void downloader(String url, String name) {
        try {
            FileUtils.copyURLToFile(new URL(url), new File(name));
            System.out.println(name);
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("io异常，downloader方法出错");
        }
    }
}
```



### 静态代理

静态代理：线程底部的一种实现模式

![image-20220130151508682](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301515966.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 15:15
 */
public class StaticProxy {
    public static void main(String[] args) {
        new Thread(() -> System.out.println("创建了一个线程--------")).start();
        new WeddingCompany(new You()).HappyMarry();
    }
}

interface Marry {
    void HappyMarry();
}

// 真实角色，你去结婚
class You implements Marry {
    @Override
    public void HappyMarry() {
        System.out.println("你要结婚了");
    }
}

// 代理角色，帮助你结婚
class WeddingCompany implements Marry {

    // 被代理的角色->真实角色
    private Marry target;

    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        this.target.HappyMarry();
        after();
    }

    private void after() {
        System.out.println("结婚之后收钱");
    }

    private void before() {
        System.out.println("结婚之前准备工作");
    }
}
```

总结：

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色

好处：

1. 代理对象可以做很多真实对象做不了的事情
2. 真实对象专注做自己的事情 



### Lamda 表达式



![image-20220130152740235](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301527371.png)

![image-20220130152759467](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301528398.png)

![image-20220130152830262](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301528426.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 15:28
 */
public class LambdaTest {

    // 3.静态内部类
    static class Like2 implements ILike {

        @Override
        public void lambda() {
            System.out.println("I LIKE Lambda2");
        }
    }

    public static void main(String[] args) {
        ILike like = new Like();
        like.lambda();

        like = new Like2();
        like.lambda();

        // 4.局部内部类
        class Like3 implements ILike {

            @Override
            public void lambda() {
                System.out.println("I LIKE Lambda3");
            }
        }

        like = new Like3();
        like.lambda();

        // 5.匿名内部类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println("I LIKE Lambda4");
            }
        };
        like.lambda();

        // 6.Lambda
        like = () -> {
            System.out.println("I LIKE Lambda5");
        };
        like.lambda();
    }
}

// 1.定义只包含一个抽象方法的接口（也就是函数式接口）
interface ILike {
    void lambda();
}

// 2.实现类
class Like implements ILike {

    @Override
    public void lambda() {
        System.out.println("I LIKE Lambda");
    }
}
```

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 15:28
 */
public class LambdaTest {

    public static void main(String[] args) {
        ILike like = new ILike() {

            @Override
            public void lambda(int a, int b) {
                System.out.println(a);
                System.out.println(b);
            }
        };
        like.lambda(521,520);

        like = (a,b)->{
            System.out.println(a);
            System.out.println(b);
        };

        like.lambda(521,520);
    }
}

interface ILike {
    void lambda(int a, int b);
}
```

**函数式接口的定义**：任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。

**总结：**

1. lambda表达式只能有一行代码的情况下才能简化成一行，如果有多行，必须用代码块
2. lambda表达式前提接口是函数式接口
3. 多个参数也可以去掉参数类型，要去掉就都去掉，必须加括号

## 线程停止

#### 线程状态

![image-20220130170903282](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301709856.png)

![image-20220130170936375](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301709418.png)

#### 线程方法

![image-20220130171027389](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301710824.png)

#### 停止线程

![image-20220130171115755](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301711571.png)

##### 使用标志位终止线程

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 17:22
 */
public class ThreadStopTest implements Runnable {
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag) {
            System.out.println("run....thread:" + i++);
        }
        System.out.println("线程停止");
    }

    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) {
        ThreadStopTest stopTest = new ThreadStopTest();
        new Thread(stopTest).start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("main:..." + i);
            if (i == 901) {
                stopTest.stop();
            }
        }
    }
}
```

#### 线程休眠 - sleep

![image-20220130173004863](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301730023.png)

**sleep() 方法作用：**

1. 模拟网络延时
2. 倒计时
3. 打印系统时间

#### 线程礼让 - yield

#### ![image-20220130173645380](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301736982.png)

线程礼让**不一定成功**，看cpu心情

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 17:39
 */
public class YieldTest implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + "线程开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName() + "线程结束");
    }

    public static void main(String[] args) {
        YieldTest yieldTest = new YieldTest();
        new Thread(yieldTest, "a").start();
        new Thread(yieldTest, "b").start();
    }
}
```

#### 线程强制执行 - join

![image-20220130174414469](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301744344.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/1/30 17:47
 */
public class JoinTest implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("vip线程来了" + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        JoinTest joinTest = new JoinTest();
        Thread thread = new Thread(joinTest);
        thread.start();
        for (int i = 0; i < 2000; i++) {
            System.out.println("main:" + i);
            if (i == 200) {
                thread.join();
            }
        }
    }
}
```

#### 观测线程状态

![image-20220130175033986](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202201301750218.png)

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/2/7 15:41
 */
public class ThreadStateTest {

    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        System.out.println("//////////////////////");

        Thread.State state = thread.getState();
        System.out.println(state);

        thread.start();
        state = thread.getState();
        System.out.println(state);

        while (state != Thread.State.TERMINATED) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            state = thread.getState();
            System.out.println(state);
        }

    }
}
```

### 线程的优先级

![image-20220207155450613](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071554849.png)

![image-20220207160112653](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071601810.png)



**线程优先级范围：1-10，默认线程优先级：5，main方法优先级：5**

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/2/7 16:08
 */
public class TestPriority {

    public static void main(String[] args) {
        System.out.println("主线程ThreadName:" + Thread.currentThread().getName() + "-->" + Thread.currentThread().getPriority());

        MyPriority thread = new MyPriority();
        Thread t1 = new Thread(thread);
        Thread t2 = new Thread(thread);
        Thread t3 = new Thread(thread);
        Thread t4 = new Thread(thread);
        Thread t5 = new Thread(thread);
        Thread t6 = new Thread(thread);

        t1.start();

        t2.setPriority(4);
        t2.start();

        t3.setPriority(8);
        t3.start();

        t4.setPriority(10);
        t4.start();

        t5.setPriority(6);
        t5.start();

        t6.setPriority(7);
        t6.start();
    }
}

class MyPriority implements Runnable {

    @Override
    public void run() {
        System.out.println("ThreadName:" + Thread.currentThread().getName() + "-->" + Thread.currentThread().getPriority());
    }
}
```



### 守护线程

![image-20220207161410848](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071616513.png)

用户线程：main

守护线程：gc

```java
package multithread;

/**
 * @author miemiehoho
 * @date 2022/2/7 16:30
 */
public class TestDaemon {
    public static void main(String[] args) {
        Thread god = new Thread(new God());
        Thread youu = new Thread(new Youu());
        god.setDaemon(true);
        youu.start();
        god.start();
    }
}

class God implements Runnable {
    @Override
    public void run() {
        while (true) {
            System.out.println("上帝守护者你");
        }
    }
}

class Youu implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 36500; i++) {
            System.out.println("你开心的活着呢");
        }
        System.out.println("===========你 离开了 这个 世界 ===========");
    }
}
```



## 线程同步

### 线程同步机制

![image-20220207163808508](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071638566.png)

![image-20220207164108747](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071641915.png)

![image-20220207164135437](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071641749.png)

![image-20220207164403873](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071644045.png)

![image-20220207164415297](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071644555.png)

### 三大不安全案例

1. 买票
2. 取钱
3. 线程不安全的集合

#### 线程不安全的原因：

多个线程同时操作同一个资源

#### 解决线程安全问题的方法：

同步机制

#### 案例

```java
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/1/29 17:59
 */
public class TicketTest implements Runnable {
    private int ticketNum = 10;
    private boolean flag = true;// 停止方式

    @Override
    public void run() {
        while (flag) {
            buyTicket();
        }
    }

    public void buyTicket() {
        if (ticketNum <= 0) {
            flag = false;
            return;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "拿到了第：" + ticketNum-- + "张票");

    }

    public static void main(String[] args) {
        TicketTest ticket = new TicketTest();
        new Thread(ticket, "A").start();
        new Thread(ticket, "B").start();
        new Thread(ticket, "C").start();
    }
}

```



```java
// 取钱
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/2/7 17:03
 */
public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account("旅游基金", 100);
        Thread you = new Thread(new DrawMoney(account, 50, "you"));
        Thread friend = new Thread(new DrawMoney(account, 100, "friend"));
        you.start();
        friend.start();
    }
}

// 账户
class Account {

    // 卡名
    String name;
    // 余额
    int money;

    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

// 取钱
class DrawMoney extends Thread {

    // 账户
    Account account;
    // 需要取的钱
    int drawMoney;
    // 对象
    String name;

    public DrawMoney(Account account, int drawMoney, String name) {
        super(name);
        this.account = account;
        this.drawMoney = drawMoney;
    }

    @Override
    public void run() {

        // 取钱
        if (account.money - drawMoney < 0) {
            System.out.println(this.getName() + "取钱，钱不够了");
            return;
        }

        // 延时，放大问题的发生性
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        account.money = account.money - drawMoney;

        System.out.println("账户余额为：" + account.money);

        System.out.println(this.getName() + "手里的钱是：" + drawMoney);
    }


}
```



```java
// 线程不安全的集合
package multithread.class03;

import java.util.ArrayList;
import java.util.List;

/**
 * @author miemiehoho
 * @date 2022/2/7 17:24
 */
public class UnsafeList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 100000; i++) {
            new Thread(() -> {
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
```



### 同步方法及同步块

![image-20220207173033813](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071732895.png)

![image-20220207173244830](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071738959.png)

![image-20220207173305672](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071738076.png)



**synchronized 默认锁的是 this**



#### 同步方法

**synchronized 默认锁的是 this**

```java
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/1/29 17:59
 */
public class TicketTest implements Runnable {
    private int ticketNum = 10;
    private boolean flag = true;// 停止方式

    @Override
    public void run() {
        while (flag) {
            buyTicket();
        }
    }

    public synchronized void buyTicket() {
        if (ticketNum <= 0) {
            flag = false;
            return;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName() + "拿到了第：" + ticketNum-- + "张票");

    }

    public static void main(String[] args) {
        TicketTest ticket = new TicketTest();
        new Thread(ticket, "A").start();
        new Thread(ticket, "B").start();
        new Thread(ticket, "C").start();
    }
}
```

#### 同步块

**synchronized 默认锁的是 this**

**锁的对象应该是需要变化的量，是需要增删改的对象**

```java
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/2/7 17:03
 */
public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account("旅游基金", 100);
        Thread you = new Thread(new DrawMoney(account, 50, "you"));
        Thread friend = new Thread(new DrawMoney(account, 100, "friend"));
        you.start();
        friend.start();
    }
}

// 账户
class Account {

    // 卡名
    String name;
    // 余额
    int money;

    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

// 取钱
class DrawMoney extends Thread {

    // 账户
    Account account;
    // 需要取的钱
    int drawMoney;
    // 对象
    String name;

    public DrawMoney(Account account, int drawMoney, String name) {
        super(name);
        this.account = account;
        this.drawMoney = drawMoney;
    }

    @Override
    public void run() {
        synchronized (account) {
            // 取钱
            if (account.money - drawMoney < 0) {
                System.out.println(this.getName() + "取钱，钱不够了");
                return;
            }

            // 延时，放大问题的发生性
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            account.money = account.money - drawMoney;

            System.out.println("账户余额为：" + account.money);

            System.out.println(this.getName() + "手里的钱是：" + drawMoney);
        }
    }


}
```

```java
package multithread.class03;

import java.util.ArrayList;
import java.util.List;

/**
 * @author miemiehoho
 * @date 2022/2/7 17:24
 */
public class UnsafeList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 100000; i++) {
            new Thread(() -> {
                synchronized (list) {
                    list.add(Thread.currentThread().getName());
                }
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
```



### CopyOnWriteArrayList

JUC包下的 线程安全的集合：`CopyOnWriteArrayList`

```java
package multithread.class03;

import java.util.concurrent.CopyOnWriteArrayList;

/**
 * @author miemiehoho
 * @date 2022/2/7 17:59
 */
public class TestJUC {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i < 100000; i++) {
            new Thread(() -> {
                list.add(Thread.currentThread().getName());
            }).start();
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
```

### 死锁

![image-20220207180206739](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071824449.png)

#### 死锁的概念

**多个线程互相抱着对方需要的资源，然后形成僵持**



![image-20220207182415124](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071824345.png)

#### 死锁案例

```java
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/2/7 18:24
 */
public class DeadLock {
    public static void main(String[] args) {
        Makeup m0 = new Makeup(0, "红");
        Makeup m1 = new Makeup(1, "蓝");
        m0.start();
        m1.start();
    }
}

// 口红
class Lipstick {

}

// 镜子
class Mirror {

}

// 化妆
class Makeup extends Thread {
    // 资源只有一份，用static来保证资源只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();

    // 选择
    int choice;
    // 使用化妆品的人
    String name;

    public Makeup(int choice, String name) {
        this.choice = choice;
        this.name = name;
    }

    @Override
    public void run() {
        // 化妆
        makeup();
    }

    // 多个线程互相抱着对方需要的资源，然后形成僵持,产生死锁
    private void makeup() {
        if (choice == 0) {
            synchronized (lipstick) {
                System.out.println(this.name + "获得口红的锁");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (mirror) {
                    System.out.println(this.name + "获得镜子的锁");
                }
            }
        } else {
            synchronized (mirror) {
                System.out.println(this.name + "获得镜子的锁");
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lipstick) {
                    System.out.println(this.name + "获得口红的锁");
                }
            }
        }
    }
}
```

#### 避免死锁

##### 如何避免死锁？

只要避免产生死锁的四个必要条件中的一个或多个就可以避免死锁

```java
package multithread.class03;

/**
 * @author miemiehoho
 * @date 2022/2/7 18:24
 */
public class DeadLock {
    public static void main(String[] args) {
        Makeup m0 = new Makeup(0, "红");
        Makeup m1 = new Makeup(1, "蓝");
        m0.start();
        m1.start();
    }
}

// 口红
class Lipstick {

}

// 镜子
class Mirror {

}

// 化妆
class Makeup extends Thread {
    // 资源只有一份，用static来保证资源只有一份
    static Lipstick lipstick = new Lipstick();
    static Mirror mirror = new Mirror();

    // 选择
    int choice;
    // 使用化妆品的人
    String name;

    public Makeup(int choice, String name) {
        this.choice = choice;
        this.name = name;
    }

    @Override
    public void run() {
        // 化妆
        makeup();
    }

    // 多个线程互相抱着对方需要的资源，然后形成僵持,产生死锁
    private void makeup() {
        if (choice == 0) {
            synchronized (lipstick) {
                System.out.println(this.name + "获得口红的锁");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            synchronized (mirror) {
                System.out.println(this.name + "获得镜子的锁");
            }
        } else {
            synchronized (mirror) {
                System.out.println(this.name + "获得镜子的锁");
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            synchronized (lipstick) {
                System.out.println(this.name + "获得口红的锁");
            }
        }
    }
}
```

### Lock锁

![image-20220207193026241](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202071930396.png)

![image-20220207223355575](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202072233841.png)

![image-20220207220449509](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202072204203.png)



```java
package multithread.class03;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @author miemiehoho
 * @date 2022/2/7 22:06
 */
public class LockTest {
    public static void main(String[] args) {
        LockTest2 test = new LockTest2();
        new Thread(test, "a").start();
        new Thread(test, "b").start();
        new Thread(test, "c").start();
    }
}

class LockTest2 implements Runnable {

    private int ticketNum = 10;

    // 定义lock锁
    private final ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            try {
                lock.lock();
                if (ticketNum <= 0) {
                    break;
                } else {
                    try {
                        Thread.sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + ":" + ticketNum--);
                }
            } finally {
                lock.unlock();
            }
        }
    }
}
```



## 线程协作

### 生产者消费者模式

![image-20220207223719269](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081213993.png)

![image-20220207223824011](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081138406.png)

![image-20220207224212776](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081138010.png)



### 管程法

![image-20220207224832792](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081140641.png)

**管程法：利用容器通信**

```java
package multithread.class04;

/**
 * @author miemiehoho
 * @date 2022/2/7 22:54
 */
// 测试生产者消费者模型--》利用缓冲区解决：管程法

// 生产者、消费者、缓冲区

public class TestPC {
    public static void main(String[] args) {
        SynContainer synContainer = new SynContainer();

        new Productor(synContainer).start();
        new Customer(synContainer).start();

    }
}

// 生产者
class Productor extends Thread {
    SynContainer synContainer;

    public Productor(SynContainer synContainer) {
        this.synContainer = synContainer;
    }

    // 生产
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("生产了" + i + "个产品");
            synContainer.push(new Product(i));
        }
    }
}

// 消费者
class Customer extends Thread {
    SynContainer synContainer;

    public Customer(SynContainer synContainer) {
        this.synContainer = synContainer;
    }

    // 消费
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费者消费的产品id：" + synContainer.pop().id);
        }
    }
}

// 产品
class Product {
    int id;

    public Product(int id) {
        this.id = id;
    }
}

// 缓冲区
class SynContainer {
    // 容器大小
    Product[] products = new Product[10];
    // 容器计数器
    int count = 0;

    // 生产者放入产品
    public synchronized void push(Product product) {
        // 如果容器满了，需要等待消费者消费
        if (count == products.length) {
            // 通知消费者消费，生产等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 如果没有满，需要丢入产品
        products[count] = product;
        count++;

        // 可以通知消费者消费了
        this.notifyAll();
    }

    // 消费者消费产品
    public synchronized Product pop() {
        // 判断能否消费
        if (count == 0) {
            // 等待生产者生产，消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 如果可以消费
        count--;
        Product product = products[count];

        // 消费完了，通知生产者生产
        this.notifyAll();
        return product;
    }
}
```

### 信号灯法

![image-20220208113804106](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081138200.png)

**信号灯法：通过判断标志位通信**

```java
package multithread.class04;

/**
 * @author miemiehoho
 * @date 2022/2/8 11:45
 */
public class TestTV {
    public static void main(String[] args) {
        TV tv = new TV();
        new Actor(tv).start();
        new Watcher(tv).start();

    }
}

// 观众
class Watcher extends Thread {
    TV tv;

    public Watcher(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}

// 演员
class Actor extends Thread {
    TV tv;

    public Actor(TV tv) {
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if (i % 2 == 0) {
                tv.play("快乐小少年");
            } else {
                tv.play("天天上上！");
            }
        }
    }
}

// 节目
class TV {

    // 演员表演，观众等待
    // 观众观看，演员等待

    // 节目名
    String name;
    boolean flag = true;

    // 表演
    public synchronized void play(String name) {
        if (!flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 表演节目
        System.out.println("表演了" + name);
        // 通知观众观看
        this.notifyAll();
        this.name = name;
        this.flag = !flag;
    }

    // 观看
    public synchronized void watch() {
        if (flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了：" + name);
        // 通知演员表演
        this.notifyAll();
        this.flag = !flag;
    }
}
```

## 线程池

![image-20220208121318565](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081213394.png)

![image-20220208122631092](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202202081226168.png)



```java
package multithread.class04;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author miemiehoho
 * @date 2022/2/8 12:27
 */
public class TestPool {
    public static void main(String[] args) {
        // 1.创建服务，创建线程池
        // newFixedThreadPool 参数为线程池大小
        ExecutorService service = Executors.newFixedThreadPool(10);

        // 2. 执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        
        // 3. 关闭链接
        service.shutdown();
    }
}

class MyThread implements Runnable {

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```



```java
package multithread.class01_02;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.concurrent.*;

/**
 * @author miemiehoho
 * @date 2022/1/30 14:46
 */
public class CallableTest implements Callable<Boolean> {

    private String url;
    private String name;

    @Override
    public Boolean call() throws Exception {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.downloader(url, name);
        return true;
    }

    public CallableTest(String url, String name) {
        this.url = url;
        this.name = name;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableTest c1 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%253A%252F%252Fdingyue.ws.126.net%252F2021%252F0606%252Fa15d45abj00qu9uyp003lc000s8015dc.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040843&t=3e46a9967c3f48cf936664a9c96fa61d", "1.jpg");
        CallableTest c2 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F7c%2F78%2Fc9%2F7c78c9d0fd92023a9b674f749ab46b7b.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040829&t=7014c5a18e48077b92c3af87f5f9bd23", "2.jpg");
        CallableTest c3 = new CallableTest(
                "https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fitem%2F202003%2F05%2F20200305192056_cBatY.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646040811&t=266d1172ad9bccd2bac1e02a723b9418", "3.jpg");
        // 创建执行服务
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        // 提交执行
        Future<Boolean> s1 = executorService.submit(c1);
        Future<Boolean> s2 = executorService.submit(c2);
        Future<Boolean> s3 = executorService.submit(c3);
        // 获取结果
        Boolean b1 = s1.get();
        Boolean b2 = s2.get();
        Boolean b3 = s3.get();
        System.out.println(b1);
        System.out.println(b2);
        System.out.println(b3);
        // 关闭服务
        executorService.shutdown();
    }
}

class WebDownloader {

    public void downloader(String url, String name) {
        try {
            FileUtils.copyURLToFile(new URL(url), new File(name));
            System.out.println(name);
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println("io异常，downloader方法出错");
        }
    }
}
```

## 总结

### 多线程的三种创建方式

```java
package multithread.class04;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author miemiehoho
 * @date 2022/2/8 14:24
 */
public class ThreadTest {
    public static void main(String[] args) {
        new MyThread1().start();
        new Thread(new MyThread2()).start();
        FutureTask<Integer> task = new FutureTask<Integer>(new MyThread3());
        new Thread(task).start();
        try {
            Integer i = task.get();
            System.out.println(i);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class MyThread1 extends Thread {
    @Override
    public void run() {
        System.out.println("MyThread1");
    }
}

class MyThread2 implements Runnable {

    @Override
    public void run() {
        System.out.println("MyThread2");
    }
}

class MyThread3 implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        System.out.println("MyThread3");
        return 666;
    }
}
```

### 线程同步的方式

1. synchronized 同步方法、同步代码块
   - 拓展：JUC包下的 线程安全的集合：`CopyOnWriteArrayList`
2. Lock 锁