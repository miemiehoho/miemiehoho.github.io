### 10进制整数打印32进制

```java
public void switchToBase32(int num) {
    for (int i = 31; i >= 0; i--) {
        System.out.print((num & (1 << i)) == 0 ? "0" : "1");
    }
}
```

一个10进制整数左移一位等同于乘2，右移一位等同于除2

- Java中int是有符号整型，第32位用来表示正负，符号位是0表示正数，1表示负数
- 无符号整型能表示的数字范围：$0$ 到 $2^{32}-1$
- 有符号整型能表示的数字范围：$-2^{31}$ 到 $2^{31}-1$

### 32位负数转10进制

最高位为1表示负数，**其余位取反，加1**

取反符号：~

实例：

```
-1的32位表示：11111111111111111111111111111111
```

### 整型最小、最大值

```java
conversion.switchToBase32(Integer.MIN_VALUE);
conversion.switchToBase32(~Integer.MIN_VALUE);
System.out.println(Integer.MIN_VALUE);
System.out.println(~Integer.MIN_VALUE);
```

输出结果：

```java
10000000000000000000000000000000
01111111111111111111111111111111
-2147483648
2147483647
```

### 算术运算与位运算关系

- 负数10进制的值，等于其2进制值取反加1后，前面加一个负号

- +、-、*、/、等等，底层都是用2进制的位运算实现的

**负数2进制定义：**正数2进制取反加1

```java
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = 5;
    conversion.switchToBase32(a);
    conversion.switchToBase32(~a + 1);
}
```

```java
00000000000000000000000000000101
11111111111111111111111111111011
```

**负数要设计成其正数取反加1的原因：**为了让正数和负数的算术运算都能**走一套逻辑**，实例见下面 取反 部分

### 位运算

#### 左移和右移

左移：<<

带符号右移（左边的空位用原来最左侧的数填充）：>>

无符号右移(最边的空位用0填充)：>>>

```java
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = Integer.MAX_VALUE;
    System.out.println("对于正数：");
    conversion.switchToBase32(a >> 1);
    conversion.switchToBase32(a >>> 1);
    int b = Integer.MIN_VALUE;
    System.out.println("================");
    System.out.println("对于负数：");
    conversion.switchToBase32(b >> 1);
    conversion.switchToBase32(b >>> 1);
}
```

输出结果：

```java
对于正数：
00111111111111111111111111111111
00111111111111111111111111111111
================
对于负数：
11000000000000000000000000000000
01000000000000000000000000000000
```

```
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = Integer.MAX_VALUE;
    conversion.switchToBase32(a>>1);
    conversion.switchToBase32(a>>>1);
}
```

#### 取反

对于一个负数：

- 10进制的值，等于其2进制值**取反加1后，前面加一个负号**
- 2进制的值，等于其正数2进制的值**先取反，后加1**

```java
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = -5;
    System.out.println(-a);
    System.out.println(~a + 1);
    conversion.switchToBase32(a);
    conversion.switchToBase32(~a + 1);
}
```

```java
5
5
11111111111111111111111111111011
00000000000000000000000000000101
```

**最小整数取反加1**（取反加1相当于负号）

```java
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = Integer.MIN_VALUE;
    System.out.println("最小整数：" + a);
    conversion.switchToBase32(a);
    System.out.println("取反：");
    conversion.switchToBase32(~a);
    System.out.println("取反加1：");
    conversion.switchToBase32(~a + 1);
}
```

```java
最小整数：-2147483648
10000000000000000000000000000000
取反：
01111111111111111111111111111111
取反加1：
10000000000000000000000000000000
```

**0取反加1**

```java
public static void main(String[] args) {
    DecimalConversion conversion = new DecimalConversion();
    int a = 0;
    System.out.println("零：" + a);
    conversion.switchToBase32(a);
    System.out.println("取反：");
    conversion.switchToBase32(~a);
    System.out.println("取反加1：");
    conversion.switchToBase32(~a + 1);
}
```

```java
零：0
00000000000000000000000000000000
取反：
11111111111111111111111111111111
取反加1：
00000000000000000000000000000000	// 高位溢出了
```



##### 算术运算符

| 操作符 | 描述                              | 例子                               |
| :----- | :-------------------------------- | :--------------------------------- |
| +      | 加法 - 相加运算符两侧的值         | A + B 等于 30                      |
| -      | 减法 - 左操作数减去右操作数       | A – B 等于 -10                     |
| *      | 乘法 - 相乘操作符两侧的值         | A * B等于200                       |
| /      | 除法 - 左操作数除以右操作数       | B / A等于2                         |
| ％     | 取余 - 左操作数除以右操作数的余数 | B%A等于0                           |
| ++     | 自增: 操作数的值增加1             | B++ 或 ++B 等于 21（区别详见下文） |
| --     | 自减: 操作数的值减少1             | B-- 或 --B 等于 19（区别详见下文） |

##### 位运算符

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |





## 位运算的基本知识

### 进制

#### 进制的概念

任何一种进位计数制都有一个基数，基数为 X 的进位计数制称为 X 进制，表示每一个数位上的数运算时都是逢 X 进一

对于一个 X 进制的数，其具体数值由其中的每个数码和数码所在的数位决定。整数部分从右往左的第 m 个数位表示的权重是 $X^m$，其中 m 最小为 0；小数部分从左往右的第 n 个数位表示的权重是 $X^{-n}$，中 n 最小为 1。

十进制的 123.45 可以写成如下形式：

$$
123.45=1×10
^2
 +2×10
 ^1
 +3×10 
^0
 +4×10 
^{−1}
 +5×10 
^{−2}
$$

八进制的 720.5 可以写成如下形式：

$$
720.5 
_{(8)}
​
 =7×8 
^2
 +2×8 
^1
 +0×8 
^0
 +5×8 
^{−1}
$$

#### 常见的进制

日常生活中，最常用的进制是十进制。十进制包括十个数码：0,1,2,3,4,5,6,7,8,9

计算机采用的进制是二进制。二进制包括两个数码：0,1

八进制和十六进制也是常见的进制。

八进制包含八个数码：0,1,2,3,4,5,6,7

十六进制包含十六个数码，除了 0 到 9 以外，还有 $\text{A},\text{B},\text{C},\text{D},\text{E},\text{F}$，分别对应十进制下的 10,11,12,13,14,15

#### 进制间的转换

**非十进制转十进制**
将非十进制数转成十进制数，只要将每个数位的加权和即可。

例如，将八进制数 $720.5_{(8)}$转成十进制：

$$
720.5 
_(8)
​
 =7×8 
^2
 +2×8 
^1
 +0×8 
^0
 +5×8 
^{−1}
 =464.625
$$
**十进制转非十进制**
将十进制数转成 X 进制数，需要对整数部分和小数部分分别转换。

- 对于整数部分，转换方式是将十进制数的整数部分每次除以 X 直到变成 0，并记录每次的余数，反向遍历每次的余数即可得到 X 进制表示。

​		例如，将十进制数 50 转成二进制：

```
50÷2=25 余 0

25÷2=12 余 1

12÷2=6 余 0

6÷2=3 余 0

3÷2=1 余 1

1÷2=0 余 1
```

​		反向遍历每次的余数，依次是 $1,1,0,0,1,0$，因此十进制数 50 转成二进制数是 $110010_{(2)}$

- 对于小数部分，转换方式是将十进制数的小数部分每次乘以 X 直到变成 0，并记录每次的整数部分，正序遍历每次的整数部分即可得到 X 进制表示。

​		例如，将十进制数$0.6875$转成二进制：

```
0.6875×2=1.375 整 1
0.375×2=0.75 整 0
0.75×2=1.5 整 1
0.5×2=1 整 1
```

​		正序遍历每次的整数部分，依次是 $1,0,1,1$，因此十进制数 $0.6875 $转成二进制数是 $0.1011_{(2)}$

​		**需要注意的是，**在一种进制下的有限小数，转成另一种进制之后可能变成无限循环小数。例如，十进制数 0.2 $转成二进制数是0.\dot001\dot1_{(2)}$

#### 其他进制间的转换

如果需要在两个不同的非十进制之间转换，常规的思路是先转成十进制数，再转成目标进制数。在一些特殊情况下，也可以不经过十进制，直接进行转换。

​	例如，将二进制数转成八进制数或十六进制数，以及将八进制数或十六进制数转成二进制数，都	不需要经过十进制。一位八进制数可以表示成三位二进制数，一位十六进制数可以表示成四位二	进制数。



 例如，对于二进制数 $101110010_{(2)}$，按照三位一组进行分组，可以得到$101|110|010$，按照四位一组进行分组，可以得到 $1|0111|0010$,因此转成八进制数是 $562_{(8)}$ ，转成十六进制数是$ 172_{(16)}$

### 整数在计算器中的表示方式

计算机采用的是二进制，二进制包括两个数码：0,1

一位二进制数的可能取值有 2 个，k 位二进制数的可能取值就有 $2^k$ 个。

在计算机中有多种数据类型，表示整数的数据类型就有好几种：

- 1 字节数，即 8 位二进制数，可能取值有$2^8 个$
- 2 字节数，即 16 位二进制数，可能取值有$2^{16} 个$
- 4 字节数，即 32 位二进制数，可能取值有$2^{32} 个$
- 8 字节数，即 64 位二进制数，可能取值有$2^{64} 个$

#### 有符号整数和无符号整数

计算机中的数据类型包括有符号类型和无符号类型，有符号类型的整数称为有符号整数，无符号类型的整数称为无符号整数。

#### 原码、补码和反码

- 反码的引入，解决了原码的减法运算结果错误的问题，但是仍然没有解决同时存在 +0 和 -0 的问题。
- 补码的引入则同时解决了减法运算错误和同时存在 +0 和 -0 的问题，而且可以多表示一个最小值。
- 由于补码具有上述优点，因此计算机采用补码进行运算。

### 位运算的基本知识

#### 位运算概述

计算机采用的是二进制，二进制包括两个数码：0,1。在计算机的底层，一切运算都是基于位运算实现的。

位运算共有 6 种，分别是：与、或、异或、取反、左移和右移，其中左移和右移统称移位运算，移位运算又分为算术移位和逻辑移位。上述位运算中，只有取反是一元运算，其余的都是二元运算。

#### 与、或、异或和取反

与运算的符号是 &，运算规则是：对于每个二进制位，当两个数对应的位都为 1 时，结果才为 1，否则结果为 0。

```
0 & 0=0
0 & 1=0
1 & 0=0
1 & 1=1
```

或运算的符号是 |，运算规则是：对于每个二进制位，当两个数对应的位都为 0 时，结果才为 0，否则结果为 1。

```
0 ∣ 0=0
0 ∣ 1=1
1 ∣ 0=1
1 ∣ 1=1
```

异或运算的符号是 $\oplus$（在代码中用 $\wedge $表示异或），运算规则是：对于每个二进制位，当两个数对应的位相同时，结果为 0，否则结果为 1。

```
0⊕0=0
0⊕1=1
1⊕0=1
1⊕1=0
```

取反运算的符号是$ \sim$，运算规则是：对一个数的每个二进制位进行取反操作，0 变成 1，1 变成 0。

```
∼0=1
∼1=0
```

以下例子显示上述四种位运算符的运算结果，参与运算的数字都采用有符号的 8 位二进制表示。

(加“|” 只是为了方便阅读)

46 的二进制表示是 $0010|1110$

51 的二进制表示是 $0011|0011$

考虑以下位运算的结果：

- 46 & 51的结果是 34，对应的二进制表示是$0010|0010$

- 46 | 51 的结果是 63，对应的二进制表示是$0011|1111$
- 46 ^ 51 的结果是 29，对应的二进制表示是$0001|1101$
- ~ 46 的结果是 -47，对应的二进制表示是$1101|0001$
- ~ 51 的结果是 -52，对应的二进制表示是$1100|1100$

#### 移位运算

移位运算按照移位方向分类可以分成左移和右移，按照是否带符号分类可以分成算术移位和逻辑移位。

左移运算的符号是 <<。左移运算时，将全部二进制位向左移动若干位，高位丢弃，低位补 0。对于左移运算，算术移位和逻辑移位是相同的。

右移运算的符号是 >>。右移运算时，将全部二进制位向右移动若干位，低位丢弃，高位的补位由算术移位或逻辑移位决定：

- 算术右移时，高位补最高位；

- 逻辑右移时，高位补 0

对于 $\texttt{Java} $而言，不存在无符号类型，所有的表示整数的类型都是有符号类型，因此需要区分算术右移和逻辑右移。在 $\texttt{Java}$ 中，算术右移的符号是 $>>$，逻辑右移的符号是 $>>>$。

#### 移位运算与乘除法的关系

移位运算与乘除法有密切的关联性。由于计算机的底层的一切运算都是基于位运算实现的，因此使用移位运算实现乘除法的效率显著高于直接乘除法的效率。

**左移运算：**

![image-20211111212154168](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/image-20211111212154168.png)

**算术右移运算：**

![image-20211111212221660](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/image-20211111212221660.png)

#### 位运算的性质

位运算的性质有很多，此处列举位运算中的与、或、异或和取反的常见性质。假设以下出现的变量都是有符号整数。

![image-20211111212350796](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/image-20211111212350796.png)

利用上述性质，可以巧妙地解决很多位运算的题目