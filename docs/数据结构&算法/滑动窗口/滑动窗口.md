# 总结

# 学习笔记

窗口定义：一种运动轨迹

## 滑动窗口最大值、最小值的更新结构

### 双端队列

#### 求滑动窗口最大值的双端队列更新策略 - 维持一个从左到右递减的双端队列

使用一个队列存储 滑动窗口中的元素的下标。在队列中，这些下标按照从小到大的顺序被存储，并且它们在数组 nums 中对应的值是**严格单调递减**的。

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中（尾插入）。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，如果前者大于等于后者，那么队尾的元素就可以被永久地移除，我们将其弹出队列。我们需要不断地进行此项操作，直到队列为空或者新的元素小于队尾的元素。

由于队列中下标对应的元素是严格单调递减的，因此此时队首下标对应的元素就是滑动窗口中的最大值。但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。

##### 时间复杂度

$O(n)$

每个位置最多进一次队列，出一次队列，所以总代价为 $O(n)$,但**不代表**任何时候的调整代价都是 $O(1)$

##### 空间复杂度

空间复杂度与窗口大小有关，为 $O(k)$

#### 代码实现

#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```java
// 双端队列（单调队列）求滑动窗口最大值
public int[] maxSlidingWindow(int[] nums, int k) {
    LinkedList<Integer> queue = new LinkedList<>();// 单调队列，存放滑动窗口对应值的下标
    int[] ans = new int[nums.length - k + 1];// 答案数组
    int idx = 0;
    for (int i = 0; i < nums.length; i++) {
        // 队尾小于等于 nums[R]的元素出队
        while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) {
            queue.pollLast();
        }
        queue.offerLast(i);
        if (queue.peekFirst() == i - k) {
            queue.pollFirst();
        }
        if (i + 1 - k >= 0) {
            ans[idx++] = nums[queue.peekFirst()];
        }
    }
    return ans;
}
```

#### 求滑动窗口最小值的双端队列更新策略 - 维持一个从左到右递增的双端队列