# 从暴力递归到动态规划

## [相关题目](/docs/数据结构&算法/动态规划/从暴力递归到动态规划-Leetcode.md)

## [题解](/docs/数据结构&算法/动态规划/从暴力递归到动态规划-题解.md)

> ZS语录：不是所有暴力递归都能改成动态规划，但是你们面试遇到的动态规划都来自于暴力递归

# 总结

动态规划中包含3个重要的概念： 1.最优子结构 2.边界 3.状态转移公式 以跳台阶为例，最优子结构为f(10)=f(9) + f(8)，边界是f(1)=1, f(2)=2，状态转移公式f(n)=f(n-1) + f(n-2)

### 求最大公约数

```java
private static long gcd(long m, long n) {
    return n == 0 ? m : gcd(n, m % n);
}
```

### 动态规划优化方法：

斜率优化、四边形不等式优化

### 动态规划减少越界判断小技巧

申请数组时多申请两个空间，这样就可以避免手动的越界判断



## 什么是动态规划

动态规划优势：减少重复尝试，减少暴力展开的过程，空间换时间

从尝试入手解决动态规划

**动态规划 转移 就是 递归中的尝试**

## 动态规划三条主线

### 主线一 从暴力递归改动态规划

先写出用尝试的思路解决问题的递归函数，而不用操心时间复杂度 ，再把影响结果的可变参数组合变成一个结构化的模型

#### 递归问题设计思路

设计递归大问题给小问题的条件要给全（父问题所做的决定对子问题的影响都要体现在子问题的参数上）



#### 记忆化搜索（傻缓存）



#### 记忆化搜索（傻缓存）与动态规划的区别与联系

1. 记忆化搜索不是动态规划
2. 如果记忆化搜索的每个格子值仅仅依赖有限几个格子，那么递归记忆化搜索与动态规划的时间复杂度一样，并且记忆化搜索更好改
3. 如果每个格子依赖的格子数量是枚举的时候，建立动态规划空间感之后可以进一步优化 - 也就是说动态规划比比记忆化搜索存在一个可以继续优化的后招



### 主线二 评价标准（尝试原则）

**做dp题，一定要逼着自己往这两个评价上靠**

1. 尝试的单个可变参数的类型最好是整数
   - 可变参数的可能性决定了dp表的大小，单个可变参数是整数，则dp表的大小在可控范围
   - 可变参数的类型如果是一系列状态（如数组），那么dp表的可能性就非常多了，在面试题目中不可能出现这么难的题目，当然这种难度的题目是存在的，如：大名鼎鼎的Tsp问题、商旅问题，并且这种题无法优化
   - 所有在面试过程遇到的题目，一定要逼自己设计出尝试参数是整型的参数
2. 尝试的可变参数个数一定要尽量少
   - 一个可变参数就是一维表，两个就是二维表，三个就是三位表……，写代码难度随之上升

### 主线三 动态规划常见的四种尝试模型

关于一道题目的尝试方法是没有方法论的，但是，当设计出一种尝试的时候能够迅速评估这种尝试靠不靠谱，是有方法的，如果评估它靠谱，就改动态规划，如果不靠谱，就继续想尝试

#### 模型 1 - 从左往右尝试模型

- 背包问题
- 货币问题（换钱的方法数）

#### 模型 2 - 范围上尝试的模型

- 排成一条线的纸牌博弈问题
- 回文问题（求回文问题大部分都是范围上尝试的模型，甚至可能一个问题多种模型都能解）
  - **字符串回文问题分类方式：**
    1. 根据开头和结尾分类
    2. 根据开头分类
    3. 根据结尾分类

#### 模型 3 - 多样本位置全对应尝试模型

- 最长公共子序列

**思路：**

1. 不由分说，先把一个字符串所有下标对应成行，把另一个字符串所有下标对应成列，做成一张表 `dp[i][j]`,即求str1[0……i]和str2[0……j]的最长公共子序列
2. 可能性分析，列出所有可能性
3. 建立状态转移方程

#### 模型 4 - 寻找业务限制的尝试模型

- 洗咖啡杯





## 动态规划 - 空间压缩技巧

以一张 m*n 的 dp二维表为例，利用空间压缩技巧可以只用一个长度为 n 的数组，去代替 dp二维表，完成计算

例：

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左边的位置 

  1. 申请一个长度为 n 的数组（原来dp二维表的列数）

  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入长度为 n 的 一维数组中

     - 如图，位置 a 一定可以直接获得，位置b即使依赖也只依赖其左边的位置a，因为它是第 0 行，没有上一行，同理根据题目所给信息可以直接获得dp二维表 第 0 行的值

       ![image-20211214091025311](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140910496.png)

  3. 使用这个一维数组自我更新，获得第 1 行的值

     - 如图，位置 a'必然只依赖a，因为它没有左边的位置，用 a‘ 覆盖 a，位置 b' 依赖 a'和b，用 b'覆盖b，同理，可以将一维数组更新成第 1行的值

       ![image-20211214091740040](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140917062.png)

  4. 循环调用步骤3，最终可以获得最后一行的值，就可以获得所求答案

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左上角的位置、它左边的位置 

  1. 申请一个长度为 n 的数组（原来dp二维表的列数），和一个临时变量 t

  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入长度为 n 的 一维数组中

  3. 使用这个一维数组自我更新，获得第 1 行的值

     - 如图，位置 a'必然只依赖a，因为它没有左边的位置，用 a‘ 覆盖 a，并用 临时变量 t 保存 a 的值
     - 位置 b' 依赖 a、a'和b，用 b'覆盖b，同理，将 临时变量 t 更新为 b 的值
     - 将一维数组更新成第 1行的值

     ![image-20211214092412640](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140924810.png)

  4. 循环调用步骤3，最终可以获得最后一行的值，就可以获得所求答案

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左上角的位置、它右上角的位置、它左边的位置

  1. 申请 两 个长度为 n 的数组（原来dp二维表的列数）：甲、乙
  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入 甲 数组中
  3. dp二维表 第 1 行的值，根据 甲数组得到，填入 乙 数组中
  4. dp二维表 第 2行的值，根据 乙数组得到，填入 甲 数组中
  5. 两个数组交替推理，最终可以获得最后一行的值

- 海量数据问题，如果 dp 二维表 是 一个 100w 行 4 列的二维表

  1. 申请一个长度为 4 的数组（原二维表的列数），表示一行
  2. 从第0行，从上往下推理

- 海量数据问题，如果 dp 二维表 是 一个 4 行 100w 列的二维表

  1. 申请一个长度为 4 的数组（原二维表的行数），表示一列

  2. 从第0列，从左往右推理

     ![image-20211214093231894](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140932681.png)

- 在一张二维表中，每个普遍位置都依赖它前 3 行的某个位置

  1. 申请四个一维数组
  2. 用四个数组滚动推理，获得答案



## ZS语录

> ZS语录：
>
> **什么暴力递归可以继续优化?**
>
> 有重复调用同一个子问题的解，这种递归可以优化。如果每一个子问题都是不同的解，无法优化也不用优化。
>
> **暴力递归和动态规划的关系**
>
> 某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划。任何动态规划问题，都一定对应着某一个有解的重复调用的暴力递归。但不是所有的暴力递归，都一定对应着动态规划。
>
> **面试题和动态规划的关系**
>
> 解决一个问题，可能有很多尝试方法，可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式。一个问题可能有若干种动态规划的解法。
>
> **如何找到某个问题的动态规划方式?**
>
> 1)设计暴力递归:重要原则+4种常见尝试模型!重点!
> 2)分析有没有重复解:套路解决
> 3)用记忆化搜索->用严格表结构实现动态规划:套路解决
> 4)看看能否继续优化:套路解决
>
> **面试中设计暴力递归过程的原则**
>
> 1)每一个可变参数的类型，一定不要比int类型更加复杂
>
> 2) 原则1)可以违反，让类型突破到一维线性结构，那必须是单一可变参数
> 3)如果发现原则1)被违反，但不违反原则2)，只需要做到记忆化搜索即可
> 4)可变参数的个数，能少则少
>
> **知道了面试中设计暴力递归过程的原则，然后呢?**
>
> 一定要逼自己找到不违反原则情况下的暴力尝试!
> 如果你找到的暴力尝试，不符合原则，马上舍弃!找新的!
> 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%!
>
> **常见的4种尝试模型**
>
> 1)从左往右的尝试模型
> 2)范围上的尝试模型
> 3)多样本位置全对应的尝试模型
> 4)寻找业务限制的尝试模型
>
> **如何分析有没有重复解**
>
> 列出调用过程，可以只列出前几层，有没有重复解，一看便知
>
> **暴力递归到动态规划的套路**
>
> 1)你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用
> 2)找到哪些参数的变化会影响返回值，对每一个列出变化范围
> 3)参数间的所有的组合数量，意味着表大小
> 4)记忆化搜索的方法就是傻缓存，非常容易得到
> 5)规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解
> 6)对于有枚举行为的决策过程，进一步优化
>
> **动态规划的进一步优化**
>
> 1)空间压缩
>
> 2)状态化简
>
> 3)四边形不等式
>
> 其他优化技巧略



> 暴力递归之所以暴力是因为有大量重复计算在浪费时间
>
> 动态规划就是某一类尝试行为的进一步优化，任何一个动态规划的问题都是以某一个暴力尝试过程中优化后的样子

## 最后总结

三条主线

1. 暴力递归改出来后如何优化
2. 设计暴力递归过程中，如何知道自己设计的东西靠不靠谱
3. 根据固定的四个模型，往下编



# 学习笔记

## 暴力递归

### 无模型

[面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

### 预留问题

打气球（高级班）

### 模型 1 - 从左往右尝试模型

[打印一个字符串的全部子序列，包括空字符串](https://www.nowcoder.com/study/live/716/8/4)

[全排列](https://www.nowcoder.com/study/live/716/8/6)

[数字转换为字符串](https://www.nowcoder.com/study/live/716/8/8)

[背包问题](https://www.nowcoder.com/study/live/716/8/10)

### 模型 2 - 范围上尝试的模型

[排成一条线的纸牌博弈问题](https://www.nowcoder.com/study/live/716/8/11)

[N皇后问题](https://www.nowcoder.com/study/live/716/8/13)

### 递归问题思路

设计递归大问题给小问题的条件要给全（父问题所做的决定对子问题的影响都要体现在子问题的参数上）

## 博弈论问题

#### 人过河问题

#### 海盗分硬币问题

#### 欧拉信封问题

![image-20211212141026685](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112121410118.png)

## 动态规划

动态规划优势：减少重复尝试，减少暴力展开的过程，空间换时间

从尝试入手解决动态规划

**动态规划 转移 就是 递归中的尝试**

### 递归记忆化搜索（傻缓存）与动态规划的区别与联系

1. 记忆化搜索不是动态规划
2. 如果记忆化搜索的每个格子值仅仅依赖有限几个格子，那么递归记忆化搜索与动态规划的时间复杂度一样，并且记忆化搜索更好改
3. 如果每个格子依赖的格子数量是枚举的时候，建立动态规划空间感之后可以进一步优化 - 也就是说动态规划比比记忆化搜索存在一个可以继续优化的后招



> 前言：
>
> 暴力递归到动态规划
>
>  动态规划就是暴力尝试减少重复计算的技巧，而已 
>
> 这种技巧就是一个大型套路 
>
> 先写出用尝试的思路解决问题的递归函数，而不用操心时间复杂度 
>
> 这个过程是无可替代的，没有套路的，只能依靠个人智慧，或者足够多的经验

> ZS语录：
>
> 暴力递归的分析过程，抽象出来就是动态规划的转移方程
>
> 任何一个动态规划都是由暴力尝试的那个尝试的种子改过来的
>
> 只要能够试出由可变参数代表的一个暴力递归，就能改成动态规划
>
> 不是所有暴力递归都能改成动态规划，是所有动态规划都来自某个暴力递归
>
> 动态规划就是把参数组合变成一个结构化的模型



### 可以改成动态规划的常见四种尝试模型

![image-20211212134625725](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112121346609.png)

#### 求斐波那契数列

```java
// 斐波那契数列-暴力递归
public int f(int N) {
    if (N == 1) {
        return 1;
    }
    if (N == 2) {
        return 1;
    }
    return f(N - 1) + f(N - 2);
}
```

> ZS语录：暴力递归之所以暴力，是因为有大量的重复计算过程，在消耗时间，所有的暴力过程都一定是因为有重复计算才暴力的。



## 记忆化搜索



#### 机器人到达指定位置方法数

假设有排成一行的N个位置，记为1~N，开始时机器人在M位置，机器人可以往左或者往右走，如果机器人在1位置，那么下一步机器人只能走到2位置，如果机器人在N位置，那么下一步机器人只能走到N-1位置。规定机器人只能走k步，最终能来到P位置的方法有多少种。

**暴力尝试**

```java
// 暴力递归
public int ways(int N, int M, int K, int P) {
    if (K == 0) {
        return M == P ? 1 : 0;
    }
    int ways = 0;
    if (M != 1) {
        ways += ways(N, M - 1, K - 1, P);
    }
    if (M != N) {
        ways += ways(N, M + 1, K - 1, P);
    }
    return ways;
}
```

**记忆化搜索**

```java
// 记忆化搜索
public int ways(int N, int M, int K, int P) {
    if (N < 2 || M < 1 || K < 1 || P > N) {
        return 0;
    }
    int[][] dp = new int[N + 1][K + 1];// 缓存
    for (int i = 1; i <= N; i++) {
        Arrays.fill(dp[i], -1);
    }
    return walkCache(N, M, K, P, dp);
}

private int walkCache(int N, int M, int K, int P, int[][] dp) {
    if (dp[M][K] != -1) {
        return dp[M][K];
    }
    if (K == 0) {
        dp[M][K] = M == P ? 1 : 0;
        return dp[M][K];
    }
    dp[M][K] = 0;
    if (M != 1) {
        dp[M - 1][K - 1] = walkCache(N, M - 1, K - 1, P, dp);
        dp[M][K] += dp[M - 1][K - 1];
    }
    if (M != N) {
        dp[M + 1][K - 1] = walkCache(N, M + 1, K - 1, P, dp);
        dp[M][K] += dp[M + 1][K - 1];
    }
    return dp[M][K];
}
```

## 动态规划-模型 1 - 从左往右尝试的模型

#### 背包问题

**暴力尝试**

```java
private static final StreamTokenizer st =
        new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

public static int nextInt() {
    try {
        st.nextToken();
        return (int) st.nval;
    } catch (IOException e) {
        throw new RuntimeException();
    }
}

public static void main(String[] args) {
    int N = nextInt();
    int V = nextInt();
    int[] C = new int[N];
    int[] W = new int[N];
    for (int i = 0; i < N; i++) {
        C[i] = nextInt();
        W[i] = nextInt();
    }
    System.out.println(process(C, W, 0, V));
}

/**
 * @param C
 * @param W
 * @param index
 * @param rest  可用容量
 * @return
 */
private static int process(int[] C, int[] W, int index, int rest) {
    if (rest < 0) {
        return -1;
    }
    if (index >= C.length) {
        return 0;
    }
    int c1 = process(C, W, index + 1, rest);
    int c2 = process(C, W, index + 1, rest - W[index]);
    if (c2 != -1) {
        c2 += C[index];
    }
    return c1 > c2 ? c1 : c2;
}
```

**从暴力递归改动态规划**

```java
    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

    public static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int N = nextInt();
        int V = nextInt();
        int[] C = new int[N];
        int[] W = new int[N];
        for (int i = 0; i < N; i++) {
            C[i] = nextInt();
            W[i] = nextInt();
        }
        System.out.println(dpProcess(C, W, V));
    }


    private static int dpProcess(int[] C, int[] W, int bag) {
        int N = C.length;
        int[][] dp = new int[N + 1][bag + 1];
//        Arrays.fill(dp[N],0);
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= bag; rest++) {
                int c1 = dp[index + 1][rest];
                int c2 = 0;
                if (rest >= W[index]) {
                    c2 = C[index] + dp[index + 1][rest - W[index]];
                }
                dp[index][rest] = Math.max(c1, c2);
//                int c1 = process(C, W, index + 1, rest);
//                int c2 = process(C, W, index + 1, rest - W[index]);
//                if (c2 != -1) {
//                    c2 += C[index];
//                }
//                return c1 > c2 ? c1 : c2;
            }
        }
        return dp[0][bag];
    }
```

> ZS语录：所谓的动态规划转移方程，其实就是决策过程中的那个决策，**暴力尝试过程中组织决策的过程，就是动态规划中的动态转移**

#### [数字转换为字符串](https://www.nowcoder.com/study/live/716/8/8)

**暴力递归**

```java
public int translateNumber(String number) {
    char[] chars = number.toCharArray();
    return translate(chars, 0);
}

private int translate(char[] chars, int index) {
    if (index == chars.length) {
        return 1;
    }
    if (chars[index] == '0') {
        return 0;
    }
    if (chars[index] == '1') {
        int res = translate(chars, index + 1);
        if (index + 1 < chars.length) {
            res += translate(chars, index + 2);
        }
        return res;
    }
    if (chars[index] == '2') {
        int res = translate(chars, index + 1);
        if (index + 1 < chars.length && '0' <= chars[index + 1] && chars[index + 1] <= '6') {
            res += translate(chars, index + 2);
        }
        return res;
    }
    return translate(chars, index + 1);
}
```

**从暴力递归改动态规划**

```java
public int translateNumber(String number) {
    char[] chars = number.toCharArray();
    return dpProcess(chars);
}

private int dpProcess(char[] chars) {
    int[] dp = new int[chars.length + 1];
    dp[chars.length] = 1;
    for (int index = chars.length - 1; index >= 0; index--) {
        if (chars[index] == '0') {
            dp[index] = 0;
        } else if (chars[index] == '1') {
            dp[index] = dp[index + 1];
            if (index + 1 < chars.length) {
                dp[index] += dp[index + 2];
            }
        } else if (chars[index] == '2') {
            dp[index] = dp[index + 1];
            if (index + 1 < chars.length && '0' <= chars[index + 1] && chars[index + 1] <= '6') {
                dp[index] += dp[index + 2];
            }
        } else {
            dp[index] = dp[index + 1];
        }
    }
    return dp[0];
}
```

## 动态规划-模型 2 - 范围上尝试的模型

#### [排成一条线的纸牌博弈问题](https://www.nowcoder.com/study/live/716/8/11)

**暴力递归**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        System.out.println(Math.max(f(arr, 0, n - 1), s(arr, 0, n - 1)));
    }
    
    private static int f(int[] arr, int l, int r) {
        if (l == r) {
            return arr[l];
        }
        return Math.max(arr[l] + s(arr, l + 1, r), arr[r] + s(arr, l, r - 1));
    }

    private static int s(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));
    }
}
```

**从暴力递归改动态规划**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        System.out.println(process(arr));
    }

    private static int process(int[] arr) {
        int n = arr.length;
        int[][] f = new int[n][n];
        int[][] s = new int[n][n];
        for (int i = 0; i < n; i++) {
            f[i][i] = arr[i];
        }
        for (int col = 1; col < n; col++) {
            int l = 0;
            int r = col;
            while (l < n && r < n) {
                f[l][r] = Math.max(arr[l] + s[l + 1][r], arr[r] + s[l][r - 1]);
                s[l][r] = Math.min(f[l + 1][r], f[l][r - 1]);
                l++;
                r++;
            }
        }
        return Math.max(f[0][n - 1], s[0][n - 1]);
    }
}
```

#### [象棋中马的跳法](https://www.nowcoder.com/study/live/717/7/8)

![image-20211213095829351](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112130958661.png)

**暴力递归**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int x = nextInt();
        int y = nextInt();
        int k = nextInt();
        System.out.println(process(0, 0, x, y, k));
    }

    private static int process(int i, int j, int x, int y, int k) {
        if (i < 0 || j < 0 || i > 8 || j > 9) {
            return 0;
        }
        if (k == 0) {
            return (i == x && j == y) ? 1 : 0;
        }
        return process(i - 2, j + 1, x, y, k - 1) +
                process(i - 1, j + 2, x, y, k - 1) +
                process(i + 1, j + 2, x, y, k - 1) +
                process(i + 2, j + 1, x, y, k - 1) +
                process(i + 2, j - 1, x, y, k - 1) +
                process(i + 1, j - 2, x, y, k - 1) +
                process(i - 1, j - 2, x, y, k - 1) +
                process(i - 2, j - 1, x, y, k - 1);
    }
}
```

**动态规划**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int x = nextInt();
        int y = nextInt();
        int k = nextInt();
        System.out.println(dpProcess(x, y, k));
    }

    private static int dpProcess(int x, int y, int k) {
        int[][][] dp = new int[k + 1][9][10];
        dp[0][x][y] = 1;
        for (int step = 1; step <= k; step++) {
            for (int i = 0; i < 9; i++) {
                for (int j = 0; j < 10; j++) {
                    dp[step][i][j] = getValue(dp, step - 1, i - 2, j + 1) +
                            getValue(dp, step - 1, i - 1, j + 2) +
                            getValue(dp, step - 1, i + 1, j + 2) +
                            getValue(dp, step - 1, i + 2, j + 1) +
                            getValue(dp, step - 1, i + 2, j - 1) +
                            getValue(dp, step - 1, i + 1, j - 2) +
                            getValue(dp, step - 1, i - 1, j - 2) +
                            getValue(dp, step - 1, i - 2, j - 1);
                }
            }
        }
        return dp[k][0][0];
    }

    private static int getValue(int[][][] dp, int step, int i, int j) {
        if (i < 0 || j < 0 || i > 8 || j > 9) {
            return 0;
        }
        return dp[step][i][j];
    }
}
```



## 标准的从左往右的尝试模型

> ZS语录：
>
> 记忆化搜索方法推严格结构位置的方法，如果没有枚举行为，不需要改，但如果有枚举行为，一定要在把整个空间感建立好之后，看看自己邻近的位置能不能把枚举行为给省掉,这只是众多优化枚举行为中的一种，正式名称为**斜率优化**，前提是建立了空间感之后才能够观察出来
>
> 如果没有枚举行为，记忆化搜索方法就够了，但如果有枚举行为，就要继续往下推

动态规划优化方法：

斜率优化、四边形不等式优化

#### 动态规划减少越界判断小技巧

申请数组时多申请两个空间，这样就可以避免手动的越界判断

#### [换钱的方法数](https://www.nowcoder.com/study/live/717/8/3)

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int aim = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        System.out.println(ways(arr, aim));
    }

    public static int ways(int[] arr, int aim) {
        return process(arr, 0, aim);
    }

    private static int process(int[] arr, int index, int rest) {
        if (index == arr.length) {
            return rest == 0 ? 1 : 0;
        }
        int count = 0;
        for (int i = 0; i * arr[index] <= rest; i++) {
            count += process(arr, index + 1, rest - (i * arr[index]));
        }
        return count%1000000007;
    }
}
```

**动态规划**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int aim = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        System.out.println(ways(arr, aim));
    }

    public static int ways(int[] arr, int aim) {
        return dpProcess(arr, aim);
    }

    private static int dpProcess(int[] arr, int aim) {
        int N = arr.length;
        int[][] dp = new int[N + 1][aim + 1];
        dp[N][0] = 1;
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                dp[index][rest] = dp[index + 1][rest];
                if (rest - arr[index] >= 0) {
                    dp[index][rest] += dp[index][rest - arr[index]];
                }
                dp[index][rest] %= 1000000007;
            }
        }
        return dp[0][aim];
    }
}
```

#### [Bob的生存概率](https://www.nowcoder.com/study/live/717/8/5)

**暴力递归**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int m = nextInt();
        int i = nextInt();
        int j = nextInt();
        int k = nextInt();
        ways(n, m, i, j, k);
    }

    private static void ways(int n, int m, int i, int j, int k) {
        long live = process(n, m, i, j, k);
        long all = (long) Math.pow(4, k);
        long gcd = gcd(live, all);
        System.out.println(live / gcd + "/" + all / gcd);
    }

    /**
     * 返回m和n的最大公约数
     *
     * @param m
     * @param n
     * @return
     */
    private static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    private static long process(int n, int m, int i, int j, int k) {
        if (i < 0 || j < 0 || i == n || j == m) {
            return 0;
        }
        if (k == 0) {
            return 1;
        }
        return process(n, m, i - 1, j, k - 1) +
                process(n, m, i + 1, j, k - 1) +
                process(n, m, i, j - 1, k - 1) +
                process(n, m, i, j + 1, k - 1);
    }
}
```

**动态规划**

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int m = nextInt();
        int i = nextInt();
        int j = nextInt();
        int k = nextInt();
        ways(n, m, i, j, k);
    }

    private static void ways(int n, int m, int i, int j, int k) {
        long live = dpProcess(n, m, i, j, k);
        long all = (long) Math.pow(4, k);
        long gcd = gcd(live, all);
        System.out.println(live / gcd + "/" + all / gcd);
    }

    /**
     * 返回m和n的最大公约数
     *
     * @param m
     * @param n
     * @return
     */
    private static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    private static long dpProcess(int n, int m, int i, int j, int k) {
        long[][][] dp = new long[n + 2][m + 2][k + 1];
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= m; col++) {
                dp[row][col][0] = 1;
            }
        }
        for (int step = 1; step <= k; step++) {
            for (int row = 1; row <= n; row++) {
                for (int col = 1; col <= m; col++) {
                    dp[row][col][step] = dp[row - 1][col][step - 1] +
                            dp[row + 1][col][step - 1] +
                            dp[row][col - 1][step - 1] +
                            dp[row][col + 1][step - 1];
                }
            }
        }
        return dp[i + 1][j + 1][k];
    }

}
```

## 多样本位置全对应尝试模型

#### [最长公共子序列](https://www.nowcoder.com/study/live/718/3/7)（以结尾分类）

子序列定义：可以不连续，但是要从左往右依次选

字符串回文问题分类方式：

1. 根据开头和结尾分类
2. 根据开头分类
3. 根据结尾分类

**思路：**

1. 不由分说，先把一个字符串所有下标对应成行，把另一个字符串所有下标对应成列，做成一张表 `dp[i][j]`,即求str1[0……i]和str2[0……j]的最长公共子序列

2. 最长公共子序列**可能性分析**：

   1. **可能性一：**最长公共子序列既不以 str1[i] 结尾也不以 str2[j] 结尾

      - 则str1[0……i]和str2[0……j]的最长公共子序列等同于str1[0……i-1]和str2[0……j-1]的最长公共子序列，即 `dp[i][j] = dp[i-1][j-1]`

      ![image-20211214200120947](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112142001643.png)

   2. **可能性二：**以 str1[i] 结尾，但不以 str2[j] 结尾

      - `dp[i][j] = dp[i][j-1]`

      ![image-20211214200505465](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112142005536.png)

   3. **可能性三：**不以 str1[i] 结尾，但以 str2[j] 结尾

      - `dp[i][j] = dp[i-1][j]`

   4. **可能性四：**既以 str1[i] 结尾，又以 str2[j] 结尾，成立条件：`str1[i] = str2[j]`

      - `dp[i][j] = dp[i-1][j-1] + 1`

      ![image-20211214200708520](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112142007090.png)

3. 除第一行、第一列外，任意一个普遍位置 `dp[i][j]`,都有转移方程：

   - `dp[i][j] = Max(`

     `dp[i-1][j-1],`	可能性 1

     `dp[i][j-1],`		可能性 2 

     `dp[i-1][j],`		可能性 3

     `dp[i-1][j-1]`		可能性 4（前提条件：：`str1[i] = str2[j]`）

     `)`

4. （可选步骤）简化转移方程：

   - `dp[i][j] = Max(`

     `dp[i][j-1],`		可能性 2 

     `dp[i-1][j],`		可能性 3

     `dp[i-1][j-1]`		可能性 4（前提条件：：`str1[i] = str2[j]`）

     `)`

     简化依据：对于任意一个朴素位置，都依赖其 左边、上边、左上角的位置值，所以可能性 2 一定优于可能性 1，故可以省去可能性1

**暴力递归**

```java
package zs.dp;

public class Solution {
    /**
     * longest common subsequence
     *
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS(String s1, String s2) {
        char[] chars1 = s1.toCharArray();
        char[] chars2 = s2.toCharArray();
        String lcs = process(chars1, 0, chars2, 0, "");
        if ("".equals(lcs)) {
            lcs = "-1";
        }
        return lcs;
    }

    private String process(char[] chars1, int index1, char[] chars2, int index2, String lcs) {
        if (index1 == chars1.length || index2 == chars2.length) {
            return lcs;
        }
        String s0 = lcs, s1 = lcs, s2 = lcs;
        for (int i = index1; i < chars1.length; i++) {
            for (int j = index2; j < chars2.length; j++) {
                if (chars1[i] == chars2[j]) {
                    s1 += chars1[i];
                    s1 = process(chars1, i + 1, chars2, j + 1, s1);//要
                    s2 = process(chars1, i + 1, chars2, j, lcs);// 不要
                }
                s1 = s1.length() > s2.length() ? s1 : s2;
                s0 = s1.length() > s0.length() ? s1 : s0;
                s1 = lcs;
                s2 = lcs;
            }
        }
        return s0;
    }
}
```

 **动态规划**

```java
package zs.dp;

public class Solution {
    /**
     * longest common subsequence
     *
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS(String s1, String s2) {
        char[] chars1 = s1.toCharArray();
        char[] chars2 = s2.toCharArray();
        String lcs = dpProcess(chars1, chars2);
        if ("".equals(lcs)) {
            lcs = "-1";
        }
        return lcs;
    }

    private String dpProcess(char[] chars1, char[] chars2) {
        if (chars1.length == 0 || chars2.length == 0) {
            return "";
        }
        int len1 = chars1.length;
        int len2 = chars2.length;
        String[][] dp = new String[len1][len2];
        dp[0][0] = chars1[0] == chars2[0] ? String.valueOf(chars1[0]) : "";
        for (int i = 1; i < len2; i++) {
            dp[0][i] = chars1[0] == chars2[i] ? String.valueOf(chars1[0]) : dp[0][i - 1];
        }
        for (int i = 1; i < len1; i++) {
            dp[i][0] = chars2[0] == chars1[i] ? String.valueOf(chars2[0]) : dp[i - 1][0];
        }
        for (int i = 1; i < len1; i++) {
            for (int j = 1; j < len2; j++) {
                dp[i][j] = dp[i - 1][j].length() > dp[i][j - 1].length() ? dp[i - 1][j] : dp[i][j - 1];
                if (chars1[i] == chars2[j]) {
                    dp[i][j] = dp[i][j].length() > (dp[i - 1][j - 1] + chars1[i]).length() ? dp[i][j] : dp[i - 1][j - 1] + chars1[i];
                }
            }
        }
        return dp[len1 - 1][len2 - 1];
    }
}
```

## 寻找业务限制的尝试模型

#### 洗咖啡杯

给定一个数组，代表每个人喝完咖啡准备刷杯子的时间
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
返回让所有咖啡杯变干净的最早完成时间
三个参数: int[] arr、int a、 int b

**暴力递归**

```java
package zs.dp;

/**
 * @author miemiehoho
 * @date 2021/12/14 22:29
 */
public class Coffee {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 4, 5, 6, 6, 7, 9, 14, 123123};
        int a = 30;
        int b = 5;
        minTime(arr, a, b);
    }

    public static void minTime(int[] arr, int a, int b) {
        System.out.println(process(arr, a, b, 0, 0));
    }

    /**
     * @param arr      每个人喝完咖啡准备刷杯子的时间
     * @param idx      第 idx 个杯子
     * @param a        咖啡机，一次只能洗一个杯子，时间耗费
     * @param b        每个咖啡杯也可以自己挥发干净，时间耗费
     * @param washLine 咖啡机的可用时间，即洗完杯子的时间
     * @return 返回让所有咖啡杯变干净的最早完成时间
     */
    public static int process(int[] arr, int a, int b, int idx, int washLine) {
        if (idx == arr.length - 1) {
            return Math.min(
                    Math.max(arr[idx], washLine) + a,
                    arr[idx] + b);
        }

        // 洗当前杯子
        int wash = Math.max(arr[idx], washLine) + a;
        int next1 = process(arr, a, b, idx + 1, wash);
        int p1 = Math.max(wash, next1);
        // 不洗当前杯子
        int dry = arr[idx] + b;
        int next2 = process(arr, a, b, idx + 1, washLine);
        int p2 = Math.max(dry, next2);

        return Math.min(p1, p2);
    }
}
```

**动态规划**

```java
package zs.dp;

/**
 * @author miemiehoho
 * @date 2021/12/14 22:29
 */
public class Coffee {
    public static void main(String[] args) {
        int[] arr = new int[]{1, 4, 5, 6, 6, 7, 9, 14, 123123};
        int a = 30;
        int b = 5;
        minTime(arr, a, b);
    }

    public static void minTime(int[] arr, int a, int b) {
        System.out.println(dpProcess(arr, a, b));
    }

    private static int dpProcess(int[] arr, int a, int b) {
        if (a >= b) {// 挥发时间比洗时间短，没必要洗
            return arr[arr.length - 1] + b;
        }
        int N = arr.length;
        int limit = 0;
        for (int i = 0; i < N; i++) {
            limit = Math.max(arr[i], limit) + a;
        }
        int[][] dp = new int[N][limit + 1];
        for (int washLine = 0; washLine <= limit; washLine++) {
            dp[N - 1][washLine] = Math.min(
                    Math.max(arr[N - 1], washLine) + a,
                    arr[N - 1] + b);
        }
        for (int idx = N - 2; idx >= 0; idx--) {
            for (int washLine = 0; washLine <= limit; washLine++) {

                // 洗当前杯子
                int p1 = Integer.MAX_VALUE;
                int wash = Math.max(arr[idx], washLine) + a;
                if (wash <= limit) {
                    p1 = Math.max(wash, dp[idx + 1][wash]);
                }
                // 不洗当前杯子
                int p2 = Math.max(arr[idx] + b, dp[idx + 1][washLine]);

                dp[idx][washLine] = Math.min(p1, p2);
            }
        }
        return dp[0][0];
    }
}
```



### 空间压缩技巧

以一张 m*n 的 dp二维表为例，利用空间压缩技巧可以只用一个长度为 n 的数组，去代替 dp二维表，完成计算

例：

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左边的位置 

  1. 申请一个长度为 n 的数组（原来dp二维表的列数）

  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入长度为 n 的 一维数组中

     - 如图，位置 a 一定可以直接获得，位置b即使依赖也只依赖其左边的位置a，因为它是第 0 行，没有上一行，同理根据题目所给信息可以直接获得dp二维表 第 0 行的值

       ![image-20211214091025311](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140910496.png)

  3. 使用这个一维数组自我更新，获得第 1 行的值

     - 如图，位置 a'必然只依赖a，因为它没有左边的位置，用 a‘ 覆盖 a，位置 b' 依赖 a'和b，用 b'覆盖b，同理，可以将一维数组更新成第 1行的值

       ![image-20211214091740040](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140917062.png)

  4. 循环调用步骤3，最终可以获得最后一行的值，就可以获得所求答案

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左上角的位置、它左边的位置 

  1. 申请一个长度为 n 的数组（原来dp二维表的列数），和一个临时变量 t

  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入长度为 n 的 一维数组中

  3. 使用这个一维数组自我更新，获得第 1 行的值

     - 如图，位置 a'必然只依赖a，因为它没有左边的位置，用 a‘ 覆盖 a，并用 临时变量 t 保存 a 的值
     - 位置 b' 依赖 a、a'和b，用 b'覆盖b，同理，将 临时变量 t 更新为 b 的值
     - 将一维数组更新成第 1行的值

     ![image-20211214092412640](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140924810.png)

  4. 循环调用步骤3，最终可以获得最后一行的值，就可以获得所求答案

- 在一张二维表中，每个普遍位置都依赖它上面的位置、它左上角的位置、它右上角的位置、它左边的位置

  1. 申请 两 个长度为 n 的数组（原来dp二维表的列数）：甲、乙
  2. dp二维表 第 0 行的值，可以根据题目所给信息得到，填入 甲 数组中
  3. dp二维表 第 1 行的值，根据 甲数组得到，填入 乙 数组中
  4. dp二维表 第 2行的值，根据 乙数组得到，填入 甲 数组中
  5. 两个数组交替推理，最终可以获得最后一行的值

- 海量数据问题，如果 dp 二维表 是 一个 100w 行 4 列的二维表

  1. 申请一个长度为 4 的数组（原二维表的列数），表示一行
  2. 从第0行，从上往下推理

- 海量数据问题，如果 dp 二维表 是 一个 4 行 100w 列的二维表

  1. 申请一个长度为 4 的数组（原二维表的行数），表示一列

  2. 从第0列，从左往右推理

     ![image-20211214093231894](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112140932681.png)

- 在一张二维表中，每个普遍位置都依赖它前 3 行的某个位置

  1. 申请四个一维数组
  2. 用四个数组滚动推理，获得答案

### 动态规划尝试方法

**常见4种模型：**

1. 从左往右尝试模型
   - 代表问题：
     - 背包问题
     - 货币问题（换钱的方法数）
2. 范围上尝试的模型
   - 代表问题：
     - 排成一条线的纸牌博弈问题
     - 回文问题（求回文问题大部分都是范围上尝试的模型，甚至可能一个问题多种模型都能解）
3. 两个样本，一个做行，一个做列的模型
   - 代表问题：
     - 最长公共子序列
4. 寻找业务限制的模型

关于一道题目的尝试方法是没有方法论的，但是，当设计出一种尝试的时候能够迅速评估这种尝试靠不靠谱，是有方法的，如果评估它靠谱，就改动态规划，如果不靠谱，就继续想尝试

#### 评价标准（尝试原则）

**做dp题，一定要逼着自己往这两个评价上靠**

1. 尝试的单个可变参数的类型最好是整数
   - 可变参数的可能性决定了dp表的大小，单个可变参数是整数，则dp表的大小在可控范围
   - 可变参数的类型如果是一系列状态（如数组），那么dp表的可能性就非常多了，在面试题目中不可能出现这么难的题目，当然这种难度的题目是存在的，如：大名鼎鼎的Tsp问题、商旅问题，并且这种题无法优化
   - 所有在面试过程遇到的题目，一定要逼自己设计出尝试参数是整型的参数
2. 尝试的可变参数个数一定要尽量少
   - 一个可变参数就是一维表，两个就是二维表，三个就是三位表……，写代码难度随之上升



![image-20211214133138088](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340658.png)





![image-20211214133228830](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340507.png)

https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=17&t=4721.1



![image-20211214133815270](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340011.png)

![image-20211214133834811](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340763.png)



![image-20211214133947876](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340645.png)



![image-20211214134045821](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141340023.png)



![image-20211214134112360](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112141341266.png)



