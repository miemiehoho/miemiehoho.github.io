#### [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

```java
public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
    leftToRight(A.size() - 1, A, B, C);
}

private void leftToRight(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        C.add(A.remove(A.size() - 1));
    } else {// N > 0
        leftToMid(N - 1, A, B, C);
        C.add(A.remove(A.size() - 1));
        midToRight(N - 1, A, B, C);
    }
}

private void leftToMid(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        B.add(A.remove(A.size() - 1));
    } else {
        leftToRight(N - 1, A, B, C);
        B.add(A.remove(A.size() - 1));
        rightToMid(N - 1, A, B, C);
    }
}

private void midToRight(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        C.add(B.remove(B.size() - 1));
    } else {
        midToLeft(N - 1, A, B, C);
        C.add(B.remove(B.size() - 1));
        leftToRight(N - 1, A, B, C);
    }
}

private void rightToMid(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        B.add(C.remove(C.size() - 1));
    } else {
        rightToLeft(N - 1, A, B, C);
        B.add(C.remove(C.size() - 1));
        leftToMid(N - 1, A, B, C);
    }
}

private void midToLeft(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        A.add(B.remove(B.size() - 1));
    } else {
        midToRight(N - 1, A, B, C);
        A.add(B.remove(B.size() - 1));
        rightToLeft(N - 1, A, B, C);
    }
}

private void rightToLeft(int N, List<Integer> A, List<Integer> B, List<Integer> C) {
    if (N == 0) {
        A.add(C.remove(C.size() - 1));
    } else {
        rightToMid(N - 1, A, B, C);
        A.add(C.remove(C.size() - 1));
        midToLeft(N - 1, A, B, C);
    }
}
```

```java
public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
    fromTo(A.size() - 1, A, B, C);
}

private void fromTo(int N, List<Integer> from, List<Integer> other, List<Integer> to) {
    if (N == 0) {
        to.add(from.remove(from.size() - 1));
    } else {// N > 0
        fromTo(N - 1, from, to, other);
        to.add(from.remove(from.size() - 1));
        fromTo(N - 1, other, from, to);
    }
}
```

#### [打印一个字符串的全部子序列，包括空字符串](https://www.nowcoder.com/study/live/716/8/4)

```java
public String[] getAllSubs(String s) {
    List<String> subList = new ArrayList<>();
    allSubs(s, 0, "", subList);
    String[] res = new String[subList.size()];
    for (int i = 0; i < res.length; i++) {
        res[i] = subList.get(i);
    }
    return res;
}

private void allSubs(String s, int i, String path, List<String> subList) {
    if (i == s.length()) {
        subList.add(path);
    } else {
        allSubs(s, i + 1, path, subList);
        allSubs(s, i + 1, path + s.charAt(i), subList);
    }
}
```

#### [数字转换为字符串](https://www.nowcoder.com/study/live/716/8/8)

```java
package zs;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * <p>
     * 用来计算一个数字有多少种不同的转换方法
     *
     * @param number string字符串 给定的数字
     * @return int整型
     */
    public int translateNumber(String number) {
        return translate(number, 0);
    }

    private int translate(String number, int index) {
        if (index == number.length()) {
            return 1;
        }
        if (number.charAt(index) - '0' == 0) {
            return 0;
        }
        int n = 0;
        n += translate(number, index + 1);
        if (index < number.length() - 1 && ((number.charAt(index) - '0') * 10 + number.charAt(index + 1) - '0') <= 26) {
            n += translate(number, index + 2);
        }
        return n;
    }
}
```

```java
package zs.dp;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * <p>
     * 用来计算一个数字有多少种不同的转换方法
     *
     * @param number string字符串 给定的数字
     * @return int整型
     */
    public int translateNumber(String number) {
        char[] chars = number.toCharArray();
        return translate(chars, 0);
    }

    private int translate(char[] chars, int index) {
        if (index == chars.length) {
            return 1;
        }
        if (chars[index] == '0') {
            return 0;
        }
        if (chars[index] == '1') {
            int res = translate(chars, index + 1);
            if (index + 1 < chars.length) {
                res += translate(chars, index + 2);
            }
            return res;
        }
        if (chars[index] == '2') {
            int res = translate(chars, index + 1);
            if (index + 1 < chars.length && '0' <= chars[index + 1] && chars[index + 1] <= '6') {
                res += translate(chars, index + 2);
            }
            return res;
        }
        return translate(chars, index + 1);
    }


}
```

#### [背包问题](https://www.nowcoder.com/study/live/716/8/10)

```java
package zs.dp;

import java.util.Scanner;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int V = scanner.nextInt();
        int[][] list = new int[N][2];
        for (int i = 0; i < N; i++) {
            list[i][0] = scanner.nextInt();
            list[i][1] = scanner.nextInt();
        }
        System.out.println(maxC(0, V, list, 0, 0));
    }

    private static int maxC(int index, int V, int[][] list, int c, int v) {
        if (v > V) {
            return 0;
        }
        if (v == V||index==list.length) {
            return c;
        }
        int c1 = maxC(index + 1, V, list, c + list[index][0], v + list[index][1]);
        int c2 = maxC(index + 1, V, list, c, v);
        return c1 > c2 ? c1 : c2;
    }
}
```

#### ⭐[排成一条线的纸牌博弈问题](https://www.nowcoder.com/study/live/716/8/11)

```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        System.out.println(process(arr));
    }

    private static int process(int[] arr) {
        int n = arr.length;
        int[][] f = new int[n][n];
        int[][] s = new int[n][n];
        for (int i = 0; i < n; i++) {
            f[i][i] = arr[i];
        }
        for (int col = 1; col < n; col++) {
            int l = 0;
            int r = col;
            while (l < n && r < n) {
                f[l][r] = Math.max(arr[l] + s[l + 1][r], arr[r] + s[l][r - 1]);
                s[l][r] = Math.min(f[l + 1][r], f[l][r - 1]);
                l++;
                r++;
            }
        }
        return Math.max(f[0][n - 1], s[0][n - 1]);
    }

    private static int f(int[] arr, int l, int r) {
        if (l == r) {
            return arr[l];
        }
        return Math.max(arr[l] + s(arr, l + 1, r), arr[r] + s(arr, l, r - 1));
    }

    private static int s(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));
    }
}
```

#### ⭐[N皇后问题](https://www.nowcoder.com/study/live/716/8/13)

**朴素解法**

```java
package zs.dp;

import java.util.Scanner;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] queue = new int[n];
        System.out.println(queueN(0, queue, n));
    }

    private static int queueN(int i, int[] queue, int n) {
        if (i == n) {
            return 1;
        }
        int num = 0;
        for (int j = 0; j < n; j++) {
            if (isValid(queue, i, j)) {
                queue[i] = j;
                num += queueN(i + 1, queue, n);
            }
        }
        return num;
    }

    private static boolean isValid(int[] queue, int i, int j) {
        for (int m = 0; m < i; m++) {
            if (queue[m] == j || Math.abs(queue[m] - j) == Math.abs(i - m)) {
                return false;
            }
        }
        return true;
    }
}
```

###### ⭐**位运算解法**

```java
package zs.dp;

import java.util.Scanner;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    // 请不要超过32皇后问题
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (true) {
            int n = scanner.nextInt();
            if (n < 1 || n > 32) {
                System.out.println(-1);
            }
            int limit = n == 32 ? -1 : (1 << n) - 1;
            System.out.println(queueN(limit, 0, 0, 0));
        }
    }

    /**
     * @param limit      固定值，n皇后所处的n行
     * @param colLimit   n皇后列限制
     * @param leftLimit  n皇后左对角线限制
     * @param rightLimit n皇后右对角线限制
     * @return
     */
    private static int queueN(int limit, int colLimit, int leftLimit, int rightLimit) {
        if (colLimit == limit) {// 所有皇后都放好了
            return 1;
        }
        int sum = 0;
        int pos = limit & ~(colLimit | leftLimit | rightLimit);// 所有可供选择的列位置
        int mostRight = 0;// 最右的可以选择列位置
        while (pos != 0) {
            mostRight = pos & (~pos + 1);
            pos = pos - mostRight;// 移除本次选择的列位置
            sum += queueN(limit, colLimit | mostRight, (leftLimit | mostRight) << 1, (rightLimit | mostRight) >>> 1);
        }
        return sum;
    }

}
```







```java
package zs.dp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.Scanner;

/**
 * @author miemiehoho
 * @date 2021/12/9 16:09
 */
public class Main {

    private static final StreamTokenizer st =
            new StreamTokenizer(new BufferedReader(
                    new InputStreamReader(System.in)
            ));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) st.nval;
        } catch (IOException e) {
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int aim = nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = nextInt();
        }
        Arrays.sort(arr);
        System.out.println(process(arr, aim));
    }

    private static int process(int[] arr, int aim) {
        if (aim == 0) {
            return 0;
        }
        if (aim < arr[0]) {
            return -1;
        }
        int minCount = Integer.MAX_VALUE;
        int idx = 0;
        while (idx < arr.length && aim >= arr[idx]) {
            int other = aim % arr[idx];
            int num = aim / arr[idx];
            if (other != 0) {
                int temp = process(arr, other);
                if (temp == -1) {
                    continue;
                }
                num += temp;
            }
            minCount = Math.min(minCount, num);
            idx++;
        }
        return minCount;
    }

}
```