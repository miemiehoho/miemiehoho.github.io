## è®¾è®¡å“ˆå¸Œè¡¨

#### [705. è®¾è®¡å“ˆå¸Œé›†åˆ](https://leetcode-cn.com/problems/design-hashset/)

æ–¹æ³•ä¸€ï¼šç”±äºé¢˜ç›®é™å®šäº†keyçš„æ•°æ®èŒƒå›´ï¼Œä¸”keyåªèƒ½æ˜¯intï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥åˆ©ç”¨booleanæ•°ç»„

```java
public class MyHashSet {
    boolean[] buckets;
    public MyHashSet() {
        buckets = new boolean[1000001];
    }

    public void add(int key) {
        buckets[key] = true;
    }

    public void remove(int key) {
        buckets[key] = false;
    }

    public boolean contains(int key) {
        return buckets[key];
    }
}
```

##### â­æ–¹æ³•äºŒï¼šæ•°ç»„+é“¾è¡¨

```java
/**
 * @author miemiehoho
 * @date 2021/11/1 23:19
 */
public class MyHashSet {
    Node[] nodes;

    public MyHashSet() {
        // Math.pow(2, 13)
        nodes = new Node[8192];
    }

    public void add(int key) {
        // æ ¹æ®keyè·å–hashæ¡¶çš„ä½ç½®
        int hash = hash(key);
        // åˆ¤æ–­hashè¡¨ä¸­æ˜¯å¦å·²å­˜åœ¨
        Node loc = nodes[hash], tmp = loc;
        if (loc != null) {
            Node prev = null;
            while (tmp != null) {
                if (tmp.key == key) {
                    return;
                }
                prev = tmp;
                tmp = tmp.next;
            }
            tmp = prev;
        }
        // å°¾æ’å…¥
        if (tmp != null) {
            tmp.next = new Node(key);
        } else {
            // å¤´æ’å…¥
            nodes[hash] = new Node(key);
        }
    }

    public void remove(int key) {
        // æ ¹æ®keyè·å–hashæ¡¶çš„ä½ç½®
        int hash = hash(key);
        Node loc = nodes[hash], tmp = loc;
        if (loc != null) {
            Node prev = null;
            while (tmp != null) {
                if (tmp.key == key) {
                    if (prev == null) {
                        nodes[hash] = tmp.next;
                        return;
                    }
                    prev.next = tmp.next;
                    return;
                }
                prev = tmp;
                tmp = tmp.next;
            }
        }
    }

    public boolean contains(int key) {
        int hash = hash(key);
        Node loc = nodes[hash];
        while (loc != null) {
            if (loc.key == key) {
                return true;
            }
            loc = loc.next;
        }
        return false;
    }

    public int hash(int key) {
        int hash = Integer.hashCode(key);
        hash ^= (hash >>> 16);
        // å¯¹äºç°ä»£çš„å¤„ç†å™¨æ¥è¯´ï¼Œé™¤æ³•å’Œæ±‚ä½™æ•°ï¼ˆæ¨¡è¿ç®—ï¼‰æ˜¯æœ€æ…¢çš„åŠ¨ä½œã€‚
        // a % b == (b-1) & a å½“bæ˜¯2çš„æŒ‡æ•°æ—¶ç­‰å¼æˆç«‹
        // return hash% nodes.length;
        return (nodes.length - 1) & hash;
    }

    class Node {
        private int key;
        private Node next;

        public Node(int key) {
            this.key = key;
        }
    }
}
```

##### â­æ–¹æ³•ä¸‰ï¼šåˆ†æ¡¶åˆ†ç»„ï¼šbitMap

```java
/**
 * @author miemiehoho
 * @date 2021/11/1 23:19
 */
public class MyHashSet {
    private int[] bitMap;

    public MyHashSet() {
        bitMap = new int[31251];// 100 0000/32+1=31251:å¿…é¡»ä¿è¯æ‰€æœ‰çš„æ•°å­—åœ¨0~100 0000ä¹‹é—´
    }

    public void add(int key) {
        int idx = key >> 5;// æ•°ç»„ä½ç½®
        int bitIdx = key & 31;// æ¯”ç‰¹ä½ç½®
        bitMap[idx] |= 1 << bitIdx;// 1 å·¦ç§» bitIdxä½ï¼Œç„¶åä¸åŸæ¥çš„å€¼è¿›è¡Œæˆ–è¿ç®—
    }

    public void remove(int key) {
        int idx = key >> 5;// æ•°ç»„ä½ç½®
        int bitIdx = key & 31;// æ¯”ç‰¹ä½ç½®
        bitMap[idx] &= ~(1 << bitIdx);// 1 å·¦ç§» bitIdxä½ï¼Œè¿›è¡Œéè¿ç®—ï¼Œç„¶åä¸åŸæ¥çš„å€¼è¿›è¡Œä¸è¿ç®—
    }

    public boolean contains(int key) {
        int idx = key >> 5;// æ•°ç»„ä½ç½®
        int bitIdx = key & 31;// æ¯”ç‰¹ä½ç½®
        return (bitMap[idx] & (1 << bitIdx)) != 0 ? true : false;// 1 å·¦ç§» bitIdxä½ï¼Œç„¶åä¸åŸæ¥çš„å€¼è¿›è¡Œä¸è¿ç®—
    }
}
```

#### [706. è®¾è®¡å“ˆå¸Œæ˜ å°„](https://leetcode-cn.com/problems/design-hashmap/)

æ–¹æ³•ä¸€ï¼šç®€å•æ•°ç»„

```JAVA
public class MyHashMap {
    private int[] map;
    private final int INF = Integer.MAX_VALUE;

    public MyHashMap() {
        map = new int[1000001];
        Arrays.fill(map, INF);
    }

    public void put(int key, int value) {
        map[key] = value;
    }

    public int get(int key) {
        return map[key] == INF ? -1 : map[key];
    }

    public void remove(int key) {
        map[key] = INF;
    }
}
```

##### â­æ–¹æ³•äºŒï¼šé“¾è¡¨è§£æ³•ï¼ˆæ•°ç»„+é“¾è¡¨ï¼‰

```java
/**
 * @author miemiehoho
 * @date 2021/11/2 8:51
 */
public class MyHashMap {
    private Node[] nodes;

    public MyHashMap() {
        nodes = new Node[8192];// Math.pow(2, 13)
    }

    public void put(int key, int value) {
        int hash = hash(key);
        Node loc = nodes[hash];
        if (loc != null) {
            Node prev = null;
            while (loc != null) {
                if (loc.key == key) {
                    loc.value = value;
                    return;
                }
                prev = loc;
                loc = loc.next;
            }
            loc = prev;
        }
        // å°¾æ’å…¥
        if (loc != null) {
            loc.next = new Node(key, value);
        } else {
            nodes[hash] = new Node(key, value);
        }
    }

    public int get(int key) {
        int hash = hash(key);
        Node loc = nodes[hash];
        while (loc != null) {
            if (loc.key == key) {
                return loc.value;
            }
            loc = loc.next;
        }
        return -1;
    }

    public void remove(int key) {
        int hash = hash(key);
        Node loc = nodes[hash];
        Node prev = null;
        while (loc != null) {
            if (loc.key == key) {
                if (prev == null) {
                    nodes[hash] = loc.next;
                    return;
                }
                prev.next = loc.next;
                return;
            }
            prev = loc;
            loc = loc.next;
        }
    }

    private int hash(int key) {
        int hash = Integer.hashCode(key);// è·å–keyçš„hashCode
        hash ^= (hash >>> 16);// hashä¸hashæ— ç¬¦å·å³ç§»16ä½è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼šä¸ºäº†ç¡®ä¿æ•£åˆ—æ€§ï¼Œå¾—åˆ°çš„ç»“æœæ›´åŠ å¹³å‡ï¼Œæ›´åŠ æ•£åˆ—
        return hash & (nodes.length - 1);// lené•¿åº¦æ˜¯2çš„æŒ‡æ•°æ¬¡ï¼Œæ‰€ä»¥ï¼ša%b==a&(b-1)æˆç«‹
    }

    private class Node {
        int key, value;
        Node next;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

##### â­æ–¹æ³•ä¸‰ï¼šå¼€å‘å¯»å€æ³•

TODO:ä¸ºä»€ä¹ˆéœ€è¦æ ‡è®°æ˜¯å¦è¢«åˆ é™¤ï¼Œç›´æ¥ä¸ºnullä¸ºä»€ä¹ˆä¸è¡Œ

```java
package first_round.data_structure.hash_table;

/**
 * @author miemiehoho
 * @date 2021/11/2 8:51
 */
public class MyHashMap {
    private Node[] nodes;
    // äº§ç”Ÿå†²çªæ—¶çš„åç§»é‡
    private int OFFSET = 1;

    public MyHashMap() {
        nodes = new Node[16384];// Math.pow(2, 14)é¢˜ç›®é™å®šï¼šæœ€å¤šè°ƒç”¨ 10000 æ¬¡ putã€get å’Œ remove æ–¹æ³•
    }

    public void put(int key, int value) {
        int hash = hash(key);
        Node node = nodes[hash];
        if (node != null) {
            node.value = value;
            node.isDeleted = false;
            return;
        }
        nodes[hash] = new Node(key, value);
    }

    public int get(int key) {
        int hash = hash(key);
        Node node = nodes[hash];
        if (node != null) {
            return node.isDeleted ? -1 : node.value;
        }
        return -1;
    }

    public void remove(int key) {
        int hash = hash(key);
        Node node = nodes[hash];
        if (node != null) {
            node.isDeleted = true;
        }
    }

    // å½“mapä¸­ä¸åŒ…å«keyçš„æ—¶å€™è¿”å›ä¸€ä¸ªç©ºä½ç½®
    // å½“mapä¸­åŒ…å«keyçš„æ—¶å€™è¿”å›keyæ‰€åœ¨çš„ä½ç½®
    private int hash(int key) {
        int hash = Integer.hashCode(key);// è·å–keyçš„hashCode
        hash ^= (hash >>> 16);// hashä¸hashæ— ç¬¦å·å³ç§»16ä½è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼šä¸ºäº†ç¡®ä¿æ•£åˆ—æ€§ï¼Œå¾—åˆ°çš„ç»“æœæ›´åŠ å¹³å‡ï¼Œæ›´åŠ æ•£åˆ—
        int n = nodes.length - 1;
        int idx = hash & n;// lené•¿åº¦æ˜¯2çš„æŒ‡æ•°æ¬¡ï¼Œæ‰€ä»¥ï¼ša%b=a&(b-1)æˆç«‹
        while (nodes[idx] != null && nodes[idx].key != key) {
            hash += OFFSET;
            idx = hash & n;
        }
        return idx;
    }

    private class Node {
        int key, value;
        boolean isDeleted;

        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

### å®é™…åº”ç”¨-å“ˆå¸Œé›†åˆ

#### [217. å­˜åœ¨é‡å¤å…ƒç´ ](https://leetcode-cn.com/problems/contains-duplicate/)

```java
// å“ˆå¸Œé›†
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int n:nums){
        if (!set.add(n)){
            return true;
        }
    }
    return false;
}
```

```java
// æ’åº
public boolean containsDuplicate(int[] nums) {
    if (nums == null || nums.length == 0) {
        return false;
    }
    Arrays.sort(nums);
    int prev = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (prev == nums[i]) {
            return true;
        }
        prev = nums[i];
    }
    return false;
}
```

##### â­

```java
// stream
public boolean containsDuplicate(int[] nums) {
    return Arrays.stream(nums).distinct().count()!=nums.length;
}
```

#### [136. åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—](https://leetcode-cn.com/problems/single-number/)

```java
// æ’åº
public int singleNumber(int[] nums) {
    Arrays.sort(nums);
    int prev = nums[0];
    for (int i = 1; i < nums.length; i += 2) {
        if (prev != nums[i]) {
            return prev;
        }
        prev = nums[i + 1];
    }
    return prev;
}
```

```java
// Set
public int singleNumber(int[] nums) {
    Set<Integer> set = new HashSet<>();
    for (int n:nums){
        if (set.contains(n)){
            set.remove(n);
            continue;
        }
        set.add(n);
    }
    Iterator<Integer> iterator = set.iterator();
    return iterator.next();
}
```

##### â­

```java
// ä½è¿ç®—:å¼‚æˆ–
public int singleNumber(int[] nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        ans^=nums[i];
    }
    return ans;
}
```

#### [349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```java
// Set
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> resSet = new HashSet<>();
    Set<Integer> set =new HashSet<>();
    for (int n:nums1){
        set.add(n);
    }
    for (int n:nums2){
        if (set.contains(n)){
            resSet.add(n);
        }
    }
    int[] res = new int[resSet.size()];
    Iterator<Integer> iterator = resSet.iterator();
    int idx = 0;
    while (iterator.hasNext()){
        res[idx++] = iterator.next();
    }
    return res;
}
```

```java
// æ’åº+åŒæŒ‡é’ˆ
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> resSet = new HashSet<>();
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int n1 = 0, n2 = 0;
    while (n1 < nums1.length && n2 < nums2.length) {
        if (nums1[n1] == nums2[n2]) {
            resSet.add(nums1[n1]);
            n1++;
            n2++;
        } else if (nums1[n1] < nums2[n2]) {
            n1++;
        } else {
            n2++;
        }
    }
    int[] res = new int[resSet.size()];
    Iterator<Integer> iterator = resSet.iterator();
    int idx = 0;
    while (iterator.hasNext()) {
        res[idx++] = iterator.next();
    }
    return res;
}
```

##### â­

```java
// æ’åº+äºŒåˆ†
public int[] intersection(int[] nums1, int[] nums2) {
    Set<Integer> resSet = new HashSet<>();
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    for (int n : nums1) {
        if (binarySearch(nums2, n)) {
            resSet.add(n);
        }
    }
    int[] res = new int[resSet.size()];
    Iterator<Integer> iterator = resSet.iterator();
    int idx = 0;
    while (iterator.hasNext()) {
        res[idx++] = iterator.next();
    }
    return res;
}

private boolean binarySearch(int[] nums2, int target) {
    int l = 0, r = nums2.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums2[mid] == target) {
            return true;
        }
        if (nums2[mid] > target) {
            r = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return false;
}
```

#### [202. å¿«ä¹æ•°](https://leetcode-cn.com/problems/happy-number/)

##### â­

```java
// æ•°å­¦+é€’å½’
public boolean isHappy(int n) {
    if (n == 1) {
        return true;
    }
    if (n == 2 || n == 3 || n == 4 || n == 5) {
        return false;
    }
    int res = 0;
    while (n != 0) {
        res += Math.pow(n % 10, 2);
        n /= 10;
    }
    return isHappy(res);
}
```

### å®é™…åº”ç”¨-å“ˆå¸Œæ˜ å°„

#### [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)

```java
// HashMap
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{-1, -1};
}
```

#### [205. åŒæ„å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/isomorphic-strings/)

```java
// å“ˆå¸Œè¡¨
public boolean isIsomorphic(String s, String t) {
    Map<Character, Character> mapS = new HashMap<>();
    Map<Character, Character> mapT = new HashMap<>();
    int len = s.length();
    for (int i = 0; i < len; i++) {
        if (mapS.containsKey(s.charAt(i))) {
            if (mapS.get(s.charAt(i)) != t.charAt(i)) {
                return false;
            }
        }
        mapS.put(s.charAt(i), t.charAt(i));
        if (mapT.containsKey(t.charAt(i))){
            if (mapT.get(t.charAt(i))!=s.charAt(i)){
                return false;
            }
        }
        mapT.put(t.charAt(i),s.charAt(i));
    }
    return true;
}
```

#### [599. ä¸¤ä¸ªåˆ—è¡¨çš„æœ€å°ç´¢å¼•æ€»å’Œ](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/)

```java
public String[] findRestaurant(String[] list1, String[] list2) {
    String[] res;
    Map<String, Integer> map = new HashMap<>();
    List<String> list = new ArrayList<>();
    for (int i = 0; i < list1.length; i++) {
        map.put(list1[i], i);
    }
    int sum = Integer.MAX_VALUE;
    for (int i = 0; i < list2.length; i++) {
        if (map.containsKey(list2[i])) {
            int len = i + map.get(list2[i]);
            if (len==sum){
                list.add(list2[i]);
                continue;
            }
            if (len<sum){
                sum = len;
                list.clear();;
                list.add(list2[i]);
            }
        }
    }
    res = new String[list.size()];
    for (int i = 0; i < list.size(); i++) {
        res[i] = list.get(i);
    }
    return res;
}
```

#### [387. å­—ç¬¦ä¸²ä¸­çš„ç¬¬ä¸€ä¸ªå”¯ä¸€å­—ç¬¦](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

```java
public int firstUniqChar(String s) {
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
    }
    for (int i = 0; i < s.length(); i++) {
        if (map.get(s.charAt(i))==1){
            return i;
        }
    }
    return -1;
}
```

#### [350. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

```java
// å“ˆå¸Œè¡¨è®¡æ•°
public int[] intersect(int[] nums1, int[] nums2) {
    List<Integer> resList = new ArrayList<>();
    int[] res;
    Map<Integer, Integer> map = new HashMap<>();
    for (int n : nums1) {
        map.put(n, map.getOrDefault(n, 0) + 1);
    }
    for (int n : nums2) {
        if (map.containsKey(n)) {
            if (map.get(n) > 0) {
                resList.add(n);
                map.replace(n, map.get(n) - 1);
            }
        }
    }
    res = new int[resList.size()];
    for (int i = 0; i < res.length; i++) {
        res[i] = resList.get(i);
    }
    return res;
}
```

##### â­

```java
// æ’åº+åŒæŒ‡é’ˆ
public int[] intersect(int[] nums1, int[] nums2) {
    List<Integer> resList = new ArrayList<>();
    int[] res;
    Arrays.sort(nums1);
    Arrays.sort(nums2);
    int n1 = 0, n2 = 0;
    while (n1 < nums1.length && n2 < nums2.length) {
        if (nums1[n1] == nums2[n2]) {
            resList.add(nums1[n1]);
            n1++;
            n2++;
            continue;
        }
        if (nums1[n1] < nums2[n2]) {
            n1++;
        } else {
            n2++;
        }
    }
    res = new int[resList.size()];
    for (int i = 0; i < res.length; i++) {
        res[i] = resList.get(i);
    }
    return res;
}
```

#### [219. å­˜åœ¨é‡å¤å…ƒç´  II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

```java
// åƒåœ¾æ–¹æ³•
public boolean containsNearbyDuplicate(int[] nums, int k) {
    if (nums == null || nums.length <= 1) {
        return false;
    }
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j <= i + k && j < nums.length; j++) {
            if (nums[i] == nums[j]) {
                return true;
            }
        }
    }
    return false;
}
```

```java
// å“ˆå¸Œé›†åˆ
public boolean containsNearbyDuplicate(int[] nums, int k) {
    if (nums == null || nums.length <= 1) {
        return false;
    }
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if ((i - map.get(nums[i])) <= k) {
                return true;
            }
        }
        map.put(nums[i], i);
    }
    return false;
}
```

#### [359. æ—¥å¿—é€Ÿç‡é™åˆ¶å™¨](https://leetcode-cn.com/problems/logger-rate-limiter/)

```java
// å“ˆå¸Œ
class Logger {
    Map<String, Integer> map;

    public Logger() {
        map = new HashMap<>();
    }

    public boolean shouldPrintMessage(int timestamp, String message) {
        Integer time = map.get(message);
        if (time == null || time <= timestamp+10) {
            map.put(message, timestamp);
            return true;
        }
        return false;
    }
}
```

##### â­

```java
class Pair<K, V> {

    /**
     * Key of this <code>Pair</code>.
     */
    K key;

    /**
     * Value of this this <code>Pair</code>.
     */
    V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
}

// é˜Ÿåˆ—ç»´æŠ¤æ»‘åŠ¨çª—å£+å“ˆå¸Œé›†åˆ¤é‡
// å…³é”®å¥ï¼šæ‰€æœ‰æ¶ˆæ¯éƒ½æŒ‰æ—¶é—´é¡ºåºå‘é€ã€‚å¤šæ¡æ¶ˆæ¯å¯èƒ½åˆ°è¾¾åŒä¸€æ—¶é—´æˆ³
class Logger {
    Queue<Pair<String, Integer>> queue;
    Set<String> set;

    public Logger() {
        queue = new ArrayDeque<>();
        set = new HashSet<>();
    }

    public boolean shouldPrintMessage(int timestamp, String message) {
        // æ¸…é™¤è¿‡æ—¶æ¶ˆæ¯
        while (!queue.isEmpty()&&((queue.peek().value + 10) <= timestamp)) {
                set.remove(queue.peek().key);
                queue.poll();
        }
        // å¦‚æœå“ˆå¸Œé›†åŒ…å«messageï¼Œè¿”falseï¼Œå¦åˆ™æ–°å¢messageåŠ å…¥é˜Ÿåˆ—ï¼Œè¿”true
        if (!set.contains(message)) {
            set.add(message);
            queue.offer(new Pair<>(message, timestamp));
            return true;
        }
        return false;
    }
}
```

### å®é™…åº”ç”¨-è®¾è®¡é”®

#### [49. å­—æ¯å¼‚ä½è¯åˆ†ç»„](https://leetcode-cn.com/problems/group-anagrams/)

```JAVA
// æ’åº
public List<List<String>> groupAnagrams(String[] strs) {
    HashMap<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String key = String.valueOf(chars);
        List<String> strList = map.getOrDefault(key, new ArrayList<>());
        strList.add(str);
        map.put(key, strList);
    }
    return new ArrayList<>(map.values());
}
```

##### â­

```java
// è®¡æ•°
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        int[] counter = new int[26];
        for (int i = 0; i < str.length(); i++) {
            counter[str.charAt(i) - 'a']++;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 26; i++) {
            if (counter[i] != 0) {
                sb.append('a' + i);
                sb.append(counter[i]);
            }
        }
        String key = sb.toString();
        List<String> strList = map.getOrDefault(key, new ArrayList<>());
        strList.add(str);
        map.put(key, strList);
    }
    return new ArrayList<>(map.values());
}
```

#### [249. ç§»ä½å­—ç¬¦ä¸²åˆ†ç»„](https://leetcode-cn.com/problems/group-shifted-strings/)

##### â­

```java
public List<List<String>> groupStrings(String[] strings) {
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strings) {
            char[] chars = str.toCharArray();
            if (chars[0] != 'a') {
                // éœ€è¦å·¦ç§»næ­¥
                int n = chars[0] - 'a';
                for (int i = 0; i < chars.length; i++) {
                    // å†™æ³•ä¸€
                    int c = chars[i] - n;
                    if (c < 'a') {
                        c += 26;
                    }
                    // å†™æ³•äºŒ
//                    chars[i] = (char) ((chars[i] - 'a') >= n ? chars[i] - n : 'z' - (n - (chars[i] - 'a')) + 1);
                    chars[i] = (char) c;
                }
            }
            String key = String.valueOf(chars);
            List<String> strList = map.getOrDefault(key, new ArrayList<>());
            strList.add(str);
            map.put(key, strList);
        }
        return new ArrayList<>(map.values());
    }
```

#### [36. æœ‰æ•ˆçš„æ•°ç‹¬](https://leetcode-cn.com/problems/valid-sudoku/)

```java
// å“ˆå¸Œè¡¨
public boolean isValidSudoku(char[][] board) {
    Map<Integer, Set<Character>> rowMap = new HashMap<>();
    Map<Integer, Set<Character>> colMap = new HashMap<>();
    Map<Integer, Set<Character>> areaMap = new HashMap<>();
    for (int i = 0; i < 9; i++) {
        rowMap.put(i, new HashSet<>());
        colMap.put(i, new HashSet<>());
        areaMap.put(i, new HashSet<>());
    }
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                if (!rowMap.get(i).add(board[i][j])) {
                    return false;
                }
                if (!colMap.get(j).add(board[i][j])) {
                    return false;
                }
                int key = i / 3 * 3 + j / 3;
                if (!areaMap.get(key).add(board[i][j])) {
                    return false;
                }
            }
        }
    }
    return true;
}
```

```java
// æ•°ç»„
public boolean isValidSudoku(char[][] board) {
    Set<Character>[] rowMap = new Set[9];
    Set<Character>[] colMap = new Set[9];
    Set<Character>[] areaMap = new Set[9];
    for (int i = 0; i < 9; i++) {
        rowMap[i] = new HashSet<>();
        colMap[i] = new HashSet<>();
        areaMap[i] = new HashSet<>();
    }
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                if (!rowMap[i].add(board[i][j])) {
                    return false;
                }
                if (!colMap[j].add(board[i][j])) {
                    return false;
                }
                int key = i / 3 * 3 + j / 3;
                if (!areaMap[key].add(board[i][j])) {
                    return false;
                }
            }
        }
    }
    return true;
}
```

##### â­

```java
// ä½è¿ç®—
public boolean isValidSudoku(char[][] board) {
    int[] row = new int[9];
    int[] col = new int[9];
    int[] area = new int[9];
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                int n = board[i][j] - '1';
                int key = i / 3 * 3 + j / 3;
                if (((row[i] >> n) & 1) == 1 || ((col[j] >> n) & 1) == 1 || ((area[key] >> n) & 1) == 1) {
                    return false;
                }
                row[i] |= 1 << n;
                col[j] |= 1 << n;
                area[key] |= 1 << n;
            }
        }
    }
    return true;
}
```

#### [652. å¯»æ‰¾é‡å¤çš„å­æ ‘](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

##### â­

```java
Set<String> set = new HashSet<>();
Map<String, TreeNode> res = new HashMap<>();

public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    DFS(root);
    return new ArrayList<>(res.values());
}

// åç»­éå†
private String DFS(TreeNode root) {
    if (root == null) {
        return "N";
    }
    String left = DFS(root.left);
    String right = DFS(root.right);
    String key = root.val + "," + left + "," + right;
    if (set.contains(key)) {
        res.put(key, root);
    } else {
        set.add(key);
    }
    return key;
}
```

### å°ç»“

#### [771. å®çŸ³ä¸çŸ³å¤´](https://leetcode-cn.com/problems/jewels-and-stones/)

```java
// å“ˆå¸Œ
public int numJewelsInStones(String jewels, String stones) {
    Set<Character> set = new HashSet<>();
    int n = 0;
    for (int i = 0; i < jewels.length(); i++) {
        set.add(jewels.charAt(i));
    }
    for (int i = 0; i < stones.length(); i++) {
        if (set.contains(stones.charAt(i))){
            n++;
        }
    }
    return n;
}
```

##### â­

```java
// æ•°ç»„ä»£æ›¿å“ˆå¸Œé›†
public int numJewelsInStones(String jewels, String stones) {
    int[] chars = new int[123];
    int n = 0;
    for (int i = 0; i < jewels.length(); i++) {
        chars[(int) jewels.charAt(i)] = 1;
    }
    for (int i = 0; i < stones.length(); i++) {
        if (chars[(int)stones.charAt(i)]==1){
            n++;
        }
    }
    return n;
}
```

#### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```java
// åŒæŒ‡é’ˆ+å“ˆå¸Œé›†
public int lengthOfLongestSubstring(String s) {
    char[] chars = s.toCharArray();
    int l = 0, r = 0;
    int len = 0;
    Set<Character> set = new HashSet<>();
    while (r < chars.length) {
        if (set.contains(chars[r])) {
            len = Math.max(len, r - l);
            while (set.contains(chars[r])) {
                set.remove(chars[l++]);
            }
        } else {
            set.add(chars[r++]);
        }
    }
    return Math.max(len,r-l);
}
```

##### â­

```java
// åŒæŒ‡é’ˆ+æ•°ç»„
public int lengthOfLongestSubstring(String s) {
    char[] chars = s.toCharArray();
    int l = 0, r = 0;
    int len = 0;
    int[] last = new int[128];
    Arrays.fill(last, -1);
    while (r < chars.length) {
        l = Math.max(l, last[chars[r]] + 1);
        len = Math.max(len, r - l);
        last[chars[r]] = r++;
    }
    return len;
}
```

#### [170. ä¸¤æ•°ä¹‹å’Œ III - æ•°æ®ç»“æ„è®¾è®¡](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/)

```java
// å“ˆå¸Œæ˜ å°„
class TwoSum {
    Map<Integer, Integer> map;

    public TwoSum() {
        map = new HashMap<>();
    }

    public void add(int number) {
        map.put(number, map.getOrDefault(number, 0) + 1);
    }

    public boolean find(int value) {
        for (int n : map.keySet()) {
            int m = value - n;
            if (map.containsKey(m)) {
                if (m == n && map.get(n) <= 1) {
                    continue;
                }
                return true;
            }
        }
        return false;
    }
}
```

```java
// æ’åº+æ•°ç»„
class TwoSum {
    List<Integer> list;
    boolean isSorted;

    public TwoSum() {
        list = new ArrayList<>();
        isSorted = false;
    }

    public void add(int number) {
        list.add(number);
        isSorted = false;
    }

    public boolean find(int value) {
        if (!isSorted) {
            Collections.sort(list);
        }
        int l = 0, r = 0;
        for (int i = 0; i < list.size(); i++) {
            int m = value - list.get(i);
            if (m >= list.get(i)) {
                l = i + 1;
                r = list.size() - 1;
            } else {
                l = 0;
                r = i - 1;
            }
            while (l <= r) {
                int mid = l + ((r - l) >> 1);
                if (list.get(mid) == m) {
                    return true;
                }
                if (list.get(mid) > m) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
        }
        return false;
    }
}
```

#### [454. å››æ•°ç›¸åŠ  II](https://leetcode-cn.com/problems/4sum-ii/)

##### â­a+b+c+dé—®é¢˜è½¬æ¢ä¸ºA+Bé—®é¢˜

```java
// A+B+C+D+```é—®é¢˜è½¬æ¢ä¸º a+bé—®é¢˜
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer,Integer> map = new HashMap<>();
    for (int i:nums1){
        for (int j:nums2){
            map.put(i+j,map.getOrDefault(i+j,0)+1);
        }
    }
    int res = 0;
    for (int i :nums3){
        for (int j:nums4){
            if (map.containsKey(-i-j)){
                res+=map.get(-i-j);
            }
        }
    }
    return res;
}
```

#### ğŸ†˜ğŸ”[347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode-cn.com/problems/top-k-frequent-elements/)

- å †å’ŒäºŒå‰æœç´¢æ ‘çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(NlogK)
- è®¡æ•°æ’åºï¼ˆæ¡¶æ’åºï¼‰å’Œå¿«æ’å˜å½¢çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(N)
- ç”¨å¿«æ’å˜å½¢æœ€æœ€æœ€é«˜æ•ˆè§£å†³TopKé—®é¢˜

```java
// å°æ ¹å †
public int[] topKFrequent(int[] nums, int k) {
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°
    Map<Integer, Integer> map = new HashMap<>();
    for (int n : nums) {
        map.put(n, map.getOrDefault(n, 0) + 1);
    }
    // å®šä¹‰å°æ ¹å †ï¼Œæ ¹æ®æ•°å­—é¢‘ç‡ä»å°åˆ°å¤§æ’åº
    Queue<Integer> queue = new PriorityQueue<>((v1, v2) -> map.get(v1) - map.get(v2));
    // éå†æ•°ç»„ï¼Œç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸ºkçš„å°æ ¹å †
    // ä¸è¶³Kä¸ªæ•°ç›´æ¥å°†å½“å‰æ•°å­—åŠ å…¥åˆ°å †ä¸­ï¼›å¦åˆ™åˆ¤æ–­å †ä¸­çš„æœ€å°æ¬¡æ•°æ˜¯å¦å°äºå½“å‰æ•°å­—å‡ºç°çš„æ¬¡æ•°
    // è‹¥æ˜¯ï¼Œåˆ™åˆ æ‰å †ä¸­å‡ºç°æ¬¡æ•°æœ€å°‘çš„ä¸€ä¸ªæ•°å­—ï¼Œå°†å½“å‰æ•°å­—åŠ å…¥åˆ°å †ä¸­
    map.forEach((number, times) -> {
        if (queue.size() < k) {
            queue.offer(number);
        } else if (map.get(queue.peek()) < times) {
            queue.poll();
            queue.offer(number);
        }
    });
    // æ„é€ ç»“æœæ•°ç»„
    int[] res = new int[k];
    int idx = 0;
    for (int n : queue) {
        res[idx++] = n;
    }
    return res;
}
```

æœ¬æ–¹æ³•å’Œä¸Šé¢çš„æ–¹æ³•ä¸€ä¸€æ ·ï¼Œåªæ˜¯æŠŠå°æ ¹å †æ¢æˆäº†äºŒå‰æœç´¢æ ‘

```java
// äºŒå‰æœç´¢æ ‘
public int[] topKFrequent(int[] nums, int k) {
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°
    Map<Integer, Integer> map = new HashMap<>();
    for (int n : nums) {
        map.put(n, map.getOrDefault(n, 0) + 1);
    }
    // å®šä¹‰äºŒå‰æœç´¢æ ‘ï¼škeyæ˜¯æ•°å­—å‡ºç°çš„æ¬¡æ•°ï¼Œvalueæ˜¯å‡ºç°äº†keyæ¬¡çš„æ•°å­—åˆ—è¡¨
    TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();
    // ç»´æŠ¤ä¸€ä¸ªæœ‰Kä¸ªæ•°å­—çš„äºŒå‰æœç´¢æ ‘
    int count = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        int number = entry.getKey();
        int times = entry.getValue();
        // ä¸è¶³kä¸ªæ•°ç›´æ¥åŠ å…¥
        if (count < k) {
            treeMap.computeIfAbsent(times, ArrayList::new).add(number);
            count++;
        } else {
            Map.Entry<Integer, List<Integer>> treeMapEntry = treeMap.firstEntry();
            if (times > treeMapEntry.getKey()) {
                treeMap.computeIfAbsent(times, ArrayList::new).add(number);
                List<Integer> list = treeMapEntry.getValue();
                if (list.size() == 1) {
                    treeMap.pollFirstEntry();
                } else {
                    list.remove(list.size() - 1);
                }
            }
        }
    }
    // æ„é€ ç»“æœæ•°ç»„
    int[] res = new int[k];
    int idx = 0;
    for (List<Integer> list : treeMap.values()) {
        for (int i : list) {
            res[idx++] = i;
        }
    }
    return res;
}
```

```java
// è®¡æ•°æ’åºï¼ˆæ¡¶æ’åºï¼‰
public int[] topKFrequent(int[] nums, int k) {
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°
    Map<Integer, Integer> map = new HashMap<>();
    for (int n : nums) {
        map.put(n, map.getOrDefault(n, 0) + 1);
    }
    // ä¸€ä¸ªæ•°å­—æœ€å¤šå‡ºç°nums.lengthæ¬¡ï¼Œæ‰€ä»¥æ„é€ ä¸€ä¸ªé•¿åº¦ä¸º nums.length+1 çš„æ•°ç»„
    // timesList[i]ä¸­å­˜è´®æ‰€æœ‰å‡ºç°æ¬¡æ•°ä¸ºiçš„æ•°å­—
    List<Integer>[] timesList = new List[nums.length + 1];
    for (int i = 0; i < timesList.length; i++) {
        timesList[i] = new ArrayList<>();
    }
    map.forEach((number, times) -> {
        timesList[times].add(number);
    });
    // æŒ‰ç…§å‡ºç°é¢‘æ¬¡ä»å¤§åˆ°å°éå†é¢‘æ¬¡æ•°ç»„ï¼Œæ„é€ ç»“æœæ•°ç»„
    int[] res = new int[k];
    int idx = 0;
    for (int i = timesList.length - 1; i > 0; i--) {
        for (int num : timesList[i]) {
            res[idx++] = num;
            if (idx == k) {
                return res;
            }
        }
    }
    return res;
}
```

```java
// å¿«æ’
class Pair {
    int number;
    int times;

    public Pair(int number, int times) {
        this.number = number;
        this.times = times;
    }
}

public int[] topKFrequent(int[] nums, int k) {
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—çš„å‡ºç°æ¬¡æ•°
    Map<Integer, Integer> map = new HashMap<>();
    for (int i : nums) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }
    Pair[] pairs = new Pair[map.keySet().size()];
    int m = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        pairs[m++] = new Pair(entry.getKey(), entry.getValue());
    }
    quickSort(pairs, 0, pairs.length - 1);
    int n = pairs.length - 1;
    int a = 0;
    int[] res = new int[k];
    for (int i = n; i >= 0; i--) {
        res[a++] = pairs[i].number;
        if (a == k) {
            return res;
        }
    }
    return res;
}

private void quickSort(Pair[] pairs, int left, int right) {
    if (left > right) {
        return;
    }
    int l = left, r = right;
    Pair mid = pairs[l];
    while (l < r) {
        while (l < r && pairs[r].times > mid.times) {
            r--;
        }
        while (l < r && pairs[l].times <= mid.times) {
            l++;
        }
        if (l < r) {
            Pair tmp = pairs[r];
            pairs[r] = pairs[l];
            pairs[l] = tmp;
        }
    }
    pairs[left] = pairs[l];
    pairs[l] = mid;
    quickSort(pairs, left, l - 1);
    quickSort(pairs, l + 1, right);
}
```

```java
// å¿«æ’å˜å½¢
class Pair {
    int number;
    int times;

    public Pair(int number, int times) {
        this.number = number;
        this.times = times;
    }
}

public int[] topKFrequent(int[] nums, int k) {
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—çš„å‡ºç°æ¬¡æ•°
    Map<Integer, Integer> map = new HashMap<>();
    for (int i : nums) {
        map.put(i, map.getOrDefault(i, 0) + 1);
    }
    Pair[] pairs = new Pair[map.keySet().size()];
    int m = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        pairs[m++] = new Pair(entry.getKey(), entry.getValue());
    }
    quickSort(pairs, 0, pairs.length - 1, k);
    int n = pairs.length - 1;
    int a = 0;
    int[] res = new int[k];
    for (int i = 0; i < pairs.length; i++) {
        res[a++] = pairs[i].number;
        if (a == k) {
            return res;
        }
    }
    return res;
}

private void quickSort(Pair[] pairs, int left, int right, int k) {
    if (left > right) {
        return;
    }
    int mid = partition(pairs, left, right);
    if (k == mid) {
        return;
    }
    if (mid < k) {
        quickSort(pairs, mid + 1, right, k);
        return;
    }
    quickSort(pairs, left, mid - 1, k);
}

private int partition(Pair[] pairs, int left, int right) {
    Pair mid = pairs[left];
    int l = left, r = right + 1;
    while (l < r) {
        // å¤§äºmidçš„æ”¾åˆ°å·¦è¾¹ï¼Œå°äºmidçš„æ”¾åˆ°å³è¾¹
        while (l < --r && pairs[r].times <= mid.times) ;
        while (++l < r && pairs[l].times >= mid.times) ;
        if (l < r) {
            Pair tmp = pairs[r];
            pairs[r] = pairs[l];
            pairs[l] = tmp;
        }
    }
    pairs[left] = pairs[r];
    pairs[r] = mid;
    return r;
}
```

#### [288. å•è¯çš„å”¯ä¸€ç¼©å†™](https://leetcode-cn.com/problems/unique-word-abbreviation/)

```java
class ValidWordAbbr {
    Map<String, Set<String>> map= new HashMap<>();

    public ValidWordAbbr(String[] dictionary) {
        for (String str : dictionary) {
            if (str.length() <= 2||" ".equals(str)) {
                Set<String> set = map.getOrDefault(str, new HashSet<>());
                set.add(str);
                map.put(str, set);
            } else {
                String key = "" + str.charAt(0) + (str.length() - 2) + str.charAt(str.length() - 1);
                Set<String> set = map.getOrDefault(key, new HashSet<>());
                set.add(str);
                map.put(key, set);
            }
        }
    }

    public boolean isUnique(String word) {
        if (word.length() <= 2) {
            return true;
        }
        String key = "" + word.charAt(0) + (word.length() - 2) + word.charAt(word.length() - 1);
        if (!map.containsKey(key)) {
            return true;
        }
        Set<String> stringSet = map.get(key);
        for (String str : stringSet) {
            if (!word.equals(str)) {
                return false;
            }
        }
        return true;
    }
}
```

```java
class ValidWordAbbr {
    Map<String, Boolean> map = new HashMap<>();
    Set<String> set = new HashSet<>();

    public ValidWordAbbr(String[] dictionary) {
        for (String str : dictionary) {
            String abbr = abbr(str);
            if (map.containsKey(abbr)) {
                map.put(abbr, abbr.length() <= 2 ? true : false);
            } else {
                map.put(abbr, true);
            }
            set.add(str);
        }
    }

    public boolean isUnique(String word) {
        if (word.length() <= 2) {
            return true;
        }
        String abbr = abbr(word);
        return map.containsKey(abbr) ? map.get(abbr) && set.contains(word) : true;
    }

    private String abbr(String str) {
        if (str.length() <= 2) {
            return str;
        }
        return str.charAt(0) + String.valueOf(str.length() - 2) + str.charAt(str.length() - 1);
    }
}
```

#### [380. O(1) æ—¶é—´æ’å…¥ã€åˆ é™¤å’Œè·å–éšæœºå…ƒç´ ](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

â­

- å“ˆå¸Œè¡¨å’ŒåŠ¨æ€æ•°ç»„çš„å¹³å‡æ’å…¥æ—¶é—´ä¸º0(1)
- å“ˆå¸Œè¡¨çš„å¹³å‡åˆ é™¤æ—¶é—´ä¸ºO(1)
- åˆ©ç”¨Random APIç”Ÿæˆéšæœºæ•°

```java
static class RandomizedSet {
    Map<Integer, Integer> map;
    List<Integer> list;
    Random rand = new Random();

    public RandomizedSet() {
        map = new HashMap<>();
        list = new ArrayList<>();
    }

    public boolean insert(int val) {
        if (map.containsKey(val)) {
            return false;
        }
        int idx = list.size();
        map.put(val, idx);
        list.add(idx, val);
        return true;
    }

    public boolean remove(int val) {
        if (!map.containsKey(val)) {
            return false;
        }
        int idx = map.get(val);
        int lastIdx = list.size() - 1;
        int lastVal = list.get(lastIdx);
        list.set(idx, lastVal);
        map.put(lastVal, idx);
        list.remove(lastIdx);
        map.remove(val);
        return true;
    }

    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}
```
