常用运算

### Math

- 开平方

  `举例：Math.sqrt(12)=3.4641016151377544;`

- 向上取整

  `举例：Math.ceil(11.4)=12; Math.ceil(-11.6)=-11;`

- 向下取整

  `举例：Math.floor(11.7)=11;Math.floor(-11.2)=-12;`


### Character

- Java `Character.isDigit()` 方法,判断字符是否为数字

- java.lang.Character.isLetterOrDigit(int codePoint) 确定指定字符(Unicode代码点)是一个字母或数字

- char型与int的相互转化：

  - ```java
    char ch='9';
    int ch_int=ch-'0';//此时ch_int=9
    ```

### 数组

- 二维数组排序：`Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);`

- Arrays.fill()方法：使用指定值填充数组

  ```java
  int[] array = new int[666];
  Arrays.fill(array,999);
  ```


### 字符串

- 去除字符串两端的空白字符 `s = s.trim();`
- 正则匹配，以空白符分割字符串 `s.split("\\s+")`
- 使用 join方法拼接字符串 `str = String.join(" ",wordList);`

### Pair

### 运算符

1.  a/3*3 == a? 错

### Stream

链表转换为数组

```java
int[] arrInBucket = bucket.stream().mapToInt(Integer::intValue).toArray();
```



### TreeSet

```java
 // 返回Set中小于/等于e的最大元素
 public E floor(E e) {
     return m.floorKey(e);
 }
 
 // 返回Set中大于/等于e的最小元素
 public E ceiling(E e) {
     return m.ceilingKey(e);
 }
```



### 类型转换

- 强制类型转换：long l = (long)5;
- 自动类型转换：long l = 5 * 1L;

### String

**compareTo() 方法：**

compareTo() 方法用于两种方式的比较：

字符串与对象进行比较。
按字典顺序比较两个字符串。

源码：

```java
/**
按字典顺序比较两个字符串。 比较基于字符串中每个字符的 Unicode 值。 此String对象表示的字符序列按字典顺序与参数字符串表示的字符序列进行比较。 如果此String对象按字典顺序位于参数字符串之前，则结果为负整数。 如果此String对象按字典顺序跟在参数字符串之后，则结果为正整数。 如果字符串相等，则结果为零； 当equals(Object)方法返回true时， compareTo返回0 。
这是字典排序的定义。 如果两个字符串不同，那么它们要么在对两个字符串都是有效索引的某个索引处具有不同的字符，要么它们的长度不同，或者两者都有。 如果它们在一个或多个索引位置有不同的字符，则令k为最小的此类索引； 则在位置k处的字符具有较小值的字符串（通过使用 < 运算符确定）按字典顺序排在另一个字符串之前。 在这种情况下， compareTo返回两个字符串中位置k处的两个字符值的差——即值：
       this.charAt(k)-anotherString.charAt(k)
       
如果没有它们不同的索引位置，则较短的字符串按字典顺序排在较长的字符串之前。 在这种情况下， compareTo返回字符串长度的差值——即值：
       this.length()-anotherString.length()
       
参数：
anotherString – 要比较的String 。
返回：
如果参数字符串等于此字符串，则值为0 ； 如果此字符串按字典顺序小于字符串参数，则为小于0的值； 如果此字符串按字典顺序大于字符串参数，则为大于0的值。
**/
public int compareTo(String anotherString) {
    int len1 = value.length;
    int len2 = anotherString.value.length;
    int lim = Math.min(len1, len2);
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    while (k < lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) {
            return c1 - c2;
        }
        k++;
    }
    return len1 - len2;
}
```

## 优先队列

优先队列自定义比较器

```java
PriorityQueue<Pair> queue = new PriorityQueue<>(new Comparator<Pair>() {
    @Override
    public int compare(Pair o1, Pair o2) {
        if (o1.value < o2.value) {
            return -1;
        }
        if (o1.value == o2.value) {
            return o2.key.compareTo(o1.key);
        }
        return 1;
    }
});
```

## ArraysList和LinkedList

ArraysList和LinkedList的remove()方法会移除第一次出现的元素！！！

```java
public static void main(String[] args) {
    LinkedList<String> list = new LinkedList<>();
    list.add("aaa");
    list.add("bbb");
    list.add("aaa");
    list.remove("aaa");
    for (int i = 0;i<2;i++){
        System.out.println(list.get(i));
    }
}
```

下面代码的输出结果是：

```java
bbb
aaa
```

removeLast()方法可以删除集合最后一个元素

```java
public static void main(String[] args) {
    LinkedList<String> list = new LinkedList<>();
    list.add("aaa");
    list.add("bbb");
    list.add("aaa");
    list.removeLast();
    for (int i = 0; i < 2; i++) {
        System.out.println(list.get(i));
    }
}
```

输出结果：

```java
aaa
bbb
```



# 数据结构

## 队列&栈

### 队列

特点：FIFO

队列相关问题：BFS

队列适用场景：按顺序处理元素

队列适用场景：按顺序处理元素

| 题目                                                         | 是否一次过 |      |
| ------------------------------------------------------------ | ---------- | ---- |
| [622. 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/) | 否         |      |

### 队列和广度优先搜索

| 题目                                                         | 是否一次过 |      |
| ------------------------------------------------------------ | ---------- | ---- |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)：图 | 是         |      |
| [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/)：不会访问一个结点多次；知道起点和终点;图 | 否         |      |
| [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)：不会访问一个结点多次；知道起点和终点；图 | 否         |      |
| [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)：：树 |            |      |

**常用算法：**

- 朴素BFS：遍历或找出最短路径，通常，这发生在树或图中
  - 注意是否需要记录访问过的结点！！！（尤其是在图中）
- 双向BFS：搜索空间爆炸问题解决方案
  - 特殊情况判断
  - 分别用左边和右边扩散的哈希表代替单向BFS里的队列，它们在双向BFS中交替使用
  - 选择较小的哈希表进行扩散，需要考虑到的情况更少
  - 扩散完成后nextLeftVisited会成为新的leftVisited
  - 注意标记已访问过的元素！
- A*
- IDA*

**朴素BFS模板**

```java
// 朴素BFS模板：不需要考虑一个结点是否会多次访问的情况
public int BFS(Node root, int target) {
    Queue<Node> queue = new LinkedList<>();
    int step = 0;
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size-- > 0) {
            Node cur = queue.poll();
            if (cur.val == target) {
                return step;
            }
            for (Node node : cur.neighbors) {
                queue.offer(node);
            }
        }
        step++;
    }
    return -1;
}
```

```java
// 朴素BFS模板：需要考虑一个结点不能多次访问的情况
public int BFS(Node root, int target) {
    Queue<Node> queue = new LinkedList<>();
    Set<Node> visited = new HashSet<>();
    queue.offer(root);
    int step = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size-- > 0) {
            Node cur = queue.poll();
            if (cur.val == target) {
                return step;
            }
            for (Node node : cur.neighbors) {
                if (!visited.contains(node)) {
                    queue.offer(node);
                    visited.add(node);
                }
            }
        }
        step++;
    }
    return -1;
}
```



**双向BFS模板**

```java
// 双向BFS:适用于知道起点和终点的图的搜索(Leetcode 127)
public int BFS(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordSet = new HashSet<>(wordList);
    if (wordList.size() == 0 || !wordSet.contains(endWord)) {
        return 0;
    }
    // 存放已访问过的元素
    Set<String> visited = new HashSet<>();
    // 分别用左右扩散的哈希表代替单向广度优先搜索里的队列，它们在双向BFS的过程中交替使用
    Set<String> beginVisited = new HashSet<>();
    beginVisited.add(beginWord);
    Set<String> endVisited = new HashSet<>();
    endVisited.add(endWord);
    // 记录步数
    int step = 1;
    while (!beginVisited.isEmpty() && !endVisited.isEmpty()) {
        // 优先选择小的哈希表进行扩散，需要考虑的情况会更少
        if (beginVisited.size() > endVisited.size()) {
            Set<String> temp = beginVisited;
            beginVisited = endVisited;
            endVisited = temp;
        }

        // 保证到这里的beginVisted是较小的集合，扩散完成后nextLevelVisited会成为新的beginVisited
        Set<String> nextLevelVisited = new HashSet<>();
        for (String word :
                beginVisited) {
            if (changeWordEveryOneLetter(word,endVisited,visited,wordSet,nextLevelVisited)) {
                return step + 1;
            }
        }
        beginVisited = nextLevelVisited;
        step++;
    }
    return 0;
}
```

### 栈

 当你想首先处理最后一个元素时，栈将是最合适的数据结构。

| 题目                                                         | 是否一次过 |      |
| ------------------------------------------------------------ | ---------- | ---- |
| [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)   | 否         |      |
| [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) | 否         |      |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) | 否         |      |
| [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 是         |      |

### 栈和深度优先搜索

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)：图 | 是         |            |
| [133. 克隆图](https://leetcode-cn.com/problems/clone-graph/) | 是         |            |
| [494. 目标和](https://leetcode-cn.com/problems/target-sum/)  | 否         | DP         |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 是         |            |

**常用算法：**

- 朴素DFS: 用于查找从根结点到目标结点的路径
  - 在 DFS 中找到的第一条路径并不总是最短的路径
  - 与BFS的重要区别：`遍历顺序`
  - 可通过再添加一个参数来指示你已经找到的最短路径
- 动态规划

**DFS递归模板**

```java
// DFS递归模板
/*
 * Return true if there is a path from cur to target.
 */
public boolean DFS(Node cur, Node target, Set<Node> visited) {
    if (cur == target) {
        return true;
    }
    for (Node node : cur.neighbors) {
        if (!visited.contains(node)) {
            visited.add(node);
            if (DFS(node, target, visited)) {
                return true;
            }
        }
    }
    return false;
}
```

**DFS迭代模板（显式栈）**

```java
// DFS迭代模板（显式栈）
/*
 * Return true if there is a path from cur to target.
 */
public boolean DFS(Node cur, Node target) {
    Stack<Node> stack = new Stack<>();
    Set<Node> visited = new HashSet<>();
    stack.push(cur);
    visited.add(cur);
    while (!stack.isEmpty())
    {
        cur = stack.pop();
        if (cur==target){
            return true;
        }
        for (Node node:cur.neighbors){
            if (!visited.contains(node)){
                visited.add(node);
                stack.push(node);
            }
        }
    }
    return false;
}
```

### 总结

| 题目                                                         | 是否一次过   | 待解决问题 |
| ------------------------------------------------------------ | ------------ | ---------- |
| [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/) | 是           |            |
| [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) | 是           |            |
| [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/) | 做了一个小时 |            |
| [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/) | 是           |            |
| [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)  | 否           | DP         |
| [841. 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/) | 是           |            |

## 数组和字符串

- 列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表

- 数组中的元素在内存中是连续存储的

- 相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的

### 数组

- 读取操作：O(1)
- 查找操作：线性时间复杂度：O(n)
- 删除操作：线性时间复杂度：O(n)
- 插入操作：
  - 插入到末尾：
  - 插入到其他位置：

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [1991. 找到数组的中间位置](https://leetcode-cn.com/problems/find-the-middle-index-in-array/) | 否         |            |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | 否         |            |
| [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/) | 否         |            |

**常用算法：**

- 前缀和
- 二分查找：专项训练！
  - 数组排序
  - 「二分」的本质是二段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。

##### 模板

**前缀和模板**

```java
// 前缀和模板：left+right+mid = sum,所以当 left = right时有 2left+mid = sum
public int findMiddleIndex(int[] nums) {
    int left = 0;
    int sum = Arrays.stream(nums).sum();
    for (int i = 0; i < nums.length; i++) {
        if ((2 * left + nums[i]) == sum) {
            return i;
        }
        left += nums[i];
    }
    return -1;
}
```

**二分查找模板**

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

### 二维数组

实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [面试题 01.07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/) | 否         |            |
| [面试题 01.08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/) | 否         |            |
| [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/) | 否         |            |

**常用算法：**

- 矩阵转置
- 考虑问题的简化问题，然后考虑从简化问题到原始问题需要做哪些修改

### 字符串

- 字符串的基本操作对象通常是字符串整体或者其子串
- 如果你确实希望你的字符串是可变的，则可以使用 toCharArray 将其转换为字符数组。
- 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [4. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/) | 是         |            |
| [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) | 否         | DP         |
| [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/) | 是         |            |
| [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/) | 否         | KMP        |

**算法：**

- 双指针
- 动态规划
- KMP：字符串匹配算法

**KMP 算法模板**

```java
// KMP 字符串匹配算法模板
public int strStr(String haystack, String needle) {
    if (needle.isEmpty()) {
        return 0;
    }
    // next 数组
    int[] next = next(needle);
    int m = haystack.length();
    int n = needle.length();
    // 模式串指针
    int i = 0, j = 0;
    // 从左向右逐个比对
    while (i < m && j < n) {
        if (j < 0 || haystack.charAt(i) == needle.charAt(j)) {
            // 比较下一个字符
            i++;
            j++;
        } else {
            // 指针回退
            j = next[j];
        }
    }
    return j == n ? i - j : -1;
}

// 构造next数组
// next数组对应的下标，为str[0,1,···,i-1]最长公共前后缀的长度
private int[] next(String str) {
    int length = str.length();
    // next数组
    int[] next = new int[length];
    next[0] = -1;
    // 主串指针
    int i = 0;
    // 模式串指针-最长公共前后缀长度
    int t = -1;
    while (i < length - 1) {
        if (t < 0 || str.charAt(t) == str.charAt(i)) {
            t++;
            next[++i] = t;
        } else {
            t = next[t];
        }
    }
    return next;
}
```

### 双指针

**使用双指针的典型场景：**

- 从两端向中间迭代数组：

  - 一个指针从头部开始，而另一个指针从尾部开始
  - 这种技巧经常在排序数组中使用

- 双指针缩减空间

- 快慢指针

- 滑动窗口

  - 两个指针的运动方向是相同的，而非相反
  - 有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略

  ![检查单元格 1, 7](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/10/202110291648752.jpeg)

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/) | 是         |            |
| [561. 数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/) | 是         |            |
| [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/) | 是         |            |
| [27. 移除元素](https://leetcode-cn.com/problems/remove-element/) | 是         |            |
| [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/) | 是         |            |
| [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/) |            |            |

**双指针模板：**

```java
// 头尾指针
public int[] twoSum(int[] numbers, int target) {
    int left = 0, right = numbers.length - 1;
    while (left<right){
        int sum = numbers[left]+numbers[right];
        if (sum == target){
            return new int[]{left+1,right+1};
        }
        if (sum>target){
            right--;
        }else {
            left++;
        }
    }
    return new int[]{-1, -1};
}
```

**快慢指针模板：**

```java
// 快慢指针
public int removeElement(int[] nums, int val) {
    int slow = 0, fast = 0;
    while (fast < nums.length) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            fast++;
            slow++;
        } else {
            fast++;
        }
    }
    return slow;
}


// 优化模板
public int removeElement(int[] nums, int val) {
    int slow = 0;
    for (int i : nums) {
        if (i != val) {
            nums[slow++] = i;
        }
    }
    return slow;
}
```

### 小结

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/) | 是         |            |
| [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/) | 是         |            |
| [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) | 是         |            |
| [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) | 否         | 旋转数组   |
| [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) | 是         |            |
| [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/) | 否         |            |

## 链表

- 与数组不同，不需要将所有元素移动到插入元素之后。可以在 `O(1)` 时间复杂度中将新结点插入到链表中
- 删除结点的时间复杂度是 O(N)，空间复杂度为 O(1)，因为只需要常量空间来存储指针

### 双指针

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/) | 是         |            |
| [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) | 是         |            |
| [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) | 一般       |            |
| [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/) | 一般       |            |
| [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) | 一般       |            |

**常用场景：**

- 判断链表是否有环：快慢指针
- 判断链表是否相交：双指针

**常用方法：**

- 双指针
- 快慢指针
- 栈
- 长度差值

**注意：**

- 在调用next 前，始终检查节点是否为空
- 仔细定义循环的结束条件

**快慢指针模板**

```java
// 快慢指针
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            return true;
        }
    }
    return false;
}
```

### 经典问题

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) | 是         |            |
| [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/) | 是         |            |
| [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/) | 否         |            |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) | 否         |            |

**链表常用解法：**

- 递归
- 双指针
  - 需要添加虚拟头节点
  - 有时利用环
  - 巧用next指针可以避免不必要的空间开销

### 双链表

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) | 是         |            |

### 小结

链表和其他数据结构（包括[数组](http://leetcode-cn.com/leetbook/detail/array-and-string/)，队列和栈）之间`时间复杂度`的比较：

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/10/202111011518990.png)

> 如果你需要经常添加或删除结点，链表可能是一个不错的选择
>
> 如果你需要经常按索引访问元素，数组可能是比链表更好的选择

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) | 是         |            |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) | 否         |            |
| [430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/) | 否         |            |
| [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/) | 吐了       |            |
| [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/) | 否         |            |

## 哈希表

哈希表是一种数据结构，它使用哈希函数组织数据，以支持快速插入和搜索

哈希表的关键思想是使用哈希函数将键映射到存储桶

- （哈希函数）散列函数取决于`键值的范围`和`桶的数量`
- 处理冲突
  - 如果桶容量 N 是常数且很小，可以简单地使用一个数组将键存储在同一个桶中
  - 如果 N 是可变的或很大，需要使用高度平衡的二叉树来代替
- 插入和搜索是哈希表中的两个基本操作，此外还有删除操作

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/) | 否         |            |
| [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/) | 否         |            |

**设计哈希集合模板**

1. 数组
2. 拉链法
3. bitMap

**设计哈希映射模板**

1. 数组
2. 拉链法
3. 开放寻址法

**内置哈希表的原理**
内置哈希表的典型设计是：

 键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有哈希码。此哈希码将用于映射函数以获取存储区索引。
 每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。
 如果在同一个桶中有太多的值，这些值将被保留在一个高度平衡的二叉树搜索树中。
插入和搜索的平均时间复杂度仍为 O(1)。最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。这是在插入和搜索之间的一种权衡

### 实际应用-哈希集合

常用场景：

1. 查重

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/) | 是         |            |
| [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/) | 是         |            |
| [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/) | 是         |            |
| [202. 快乐数](https://leetcode-cn.com/problems/happy-number/) | 否         |            |

**哈希集合查重模板**

```java
public boolean findDuplicates(int[] arrays) {
    Set<Integer> set = new HashSet<>();
    for (int a : arrays) {
        if (!set.add(a)) {
            return true;
        }
    }
    return false;
}
```

### 实际应用-哈希映射

常用场景：

1. 需要更多的信息，而不仅仅是键。然后通过哈希映射建立密钥与信息之间的映射关系
2. 按键聚合所有信息
   - 解决此类问题的关键是在`遇到现有键时确定策略`

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)     | 是         |            |
| [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/) | 是         |            |
| [599. 两个列表的最小索引总和](https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/) | 是         |            |
| [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/) | 是         |            |
| [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/) | 是         |            |
| [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/) | 是         |            |
| [359. 日志速率限制器](https://leetcode-cn.com/problems/logger-rate-limiter/) | 否         |            |

**哈希映射模板一**

```java
// HashMap
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{-1, -1};
}
```

**哈希映射模板二**

```java
public int firstUniqChar(String s) {
    Map<Character, Integer> map = new HashMap<>();
    for (int i = 0; i < s.length(); i++) {
        map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
    }
    for (int i = 0; i < s.length(); i++) {
        if (map.get(s.charAt(i))==1){
            return i;
        }
    }
    return -1;
}
```

### 实际应用-设计键

**设计关键是在原始信息和哈希映射使用的实际键之间建立映射关系。设计键时，需要保证：**

1. 属于同一组的所有值都将映射到同一组中。
2. 需要分成不同组的值不会映射到同一组。

**映射策略示例：**[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)：对字符串进行排序并使用排序后的字符串作为键

**大多数哈希表计数问题都能转换为使用数组解决，以提高执行效率**

- 虽然时间复杂度一样，但是哈希表的查询和更新的时间复杂度为均摊O(1)，而定长数组的查询和更新的时间复杂度则是严格O(1),因此从执行效率上来说，数组要比哈希表快上不少

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/) | 是         |            |
| [249. 移位字符串分组](https://leetcode-cn.com/problems/group-shifted-strings/) | 否         |            |
| [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/) | 否         |            |
| [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/) | 否         |            |

**设计建技巧：**

1. 当字符串 / 数组中每个元素的顺序不重要时，可以使用`排序后的字符串 / 数组`作为键

   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111041010686.png)

2. 如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用`偏移量`作为键

   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111041010881.png)

3. 在树中，你有时可能会希望直接使用 `TreeNode` 作为键。 但在大多数情况下，采用`子树的序列化表述`可能是一个更好的主意

   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111041010263.png)

4. 在矩阵中，你可能希望使用`行索引`或`列索引`作为键

5. 在数独中，可以将行索引和列索引组合来标识此元素属于哪个`块`

   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111041010798.png)

6. 有时，在矩阵中，您可能希望将值聚合在`同一对角线`中

   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111041010281.png)

### 小结

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [771. 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/) | 是         |            |
| [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) | 是         |            |
| [170. 两数之和 III - 数据结构设计](https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/) | 是         |            |
| [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/) | 否         |            |
| [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/) | 否         |            |
| [288. 单词的唯一缩写](https://leetcode-cn.com/problems/unique-word-abbreviation/) | 是         |            |
| [380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/) | 否         |            |

## 二叉树

树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。

树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。

二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。

#### 二叉树的高度和深度的区别

高度和深度是相反的表示，深度是从上到下数的，而高度是从下往上数

**高度：**指从该节点到叶子节点的最长简单路径边的条数
**深度：**指从根节点到该节点的最长简单路径边的条数

**注意：**

- 这里边的条数是规定根节点的深度和叶子节点的高度是0

- 树的深度和高度是相等的，而对其他节点来说深度和高度不一定相等

**实例**

![123](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101647565.jpg)

如 B和C节点深度都为1，因为从根节点到到该节点的边数为1，B的高度为2，而C的高度为1。

当然树的深度是3高度也是3。树的高度和深度是相等的。

### 树的遍历

**树的遍历方法：**

- 递归方法解决树的前序遍历、中序遍历和后序遍历问题
- 迭代方法解决树的为前序遍历、中序遍历和后序遍历问题
- 广度优先搜索解决树的层序遍历问题

**前序遍历**

前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树

**中序遍历**

中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树

通常来说，对于[二叉搜索树](https://leetcode-cn.com/leetbook/detail/introduction-to-data-structure-binary-search-tree/)，我们可以通过中序遍历得到一个递增的有序序列

**后序遍历**

后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点

- 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身
- 后序在数学表达中被广泛使用，编写程序来解析后缀表示法更为容易
- 如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中

**递归：调用递归栈，时间复杂度O(N),空间复杂度O(h)**

**迭代：时间复杂度O(N),空间复杂度O(h)**

**Morris遍历**：**时间复杂度O(N),空间复杂度O(1)**：笔试别装逼，写递归、迭代，简单能AC就好，面试可以喝面试官聊下Morris（和KMP中的M是同一个人）

![image-20211105092457427](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111050924090.png)

| 题目                                                         | 是否一次过 | 待解决问题       |
| ------------------------------------------------------------ | ---------- | ---------------- |
| [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 否         | Morris遍历       |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 否         | Morris遍历       |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 否         | 迭代、Morris遍历 |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | 是         |                  |

先序遍历：压栈顺序：中左右

后序遍历：压栈顺序：中右左  -> 逆序打印就是后序遍历

中序遍历：阶段一：子树整条左边界依次进栈，如没有进入阶段二

​					阶段二：栈中弹出节点cur，并打印，cur的右子树重复阶段一

### 运用递归解决问题

递归是解决树相关问题的最有效和最常用的方法之一

**自顶向下**

你能确定一些参数，从该节点自身解决出发寻找答案吗？
你可以使用这些参数和节点本身的值来决定什么应该是传递给它子节点的参数吗？

如果答案都是肯定的，那么请尝试使用 “自顶向下” 的递归来解决此问题。

**自底向上**

对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出该节点的答案吗？ 如果答案是肯定的，那么 “自底向上” 的递归可能是一个不错的解决方法。

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) | 是         |            |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) | 否         |            |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  | 是         |            |

### 小结

**二叉树的遍历方式：**

1. 深度优先搜索（DFS）
   1. 前序遍历
   2. 中序遍历
   3. 后续遍历
2. 宽度优先搜索（BFS）

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | 否         |            |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | 是         |            |
| [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/) | 否         |            |
| [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/) | 是         |            |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) | 否         |            |
| [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) | 否         |            |

## 二叉搜索树

**性质：**每个节点中的值必须大于其左侧子树中的任何值，但小于其右侧子树中的任何值。也就是中序遍历是**单调递增序列**

| 题目                                                         | 是否一次过 | 待解决问题                                                   |
| ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/) | 否         |                                                              |
| [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/) | 否         |                                                              |
| [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/) | 是         |                                                              |
| [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/) | 是         |                                                              |
| [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) | 否         |                                                              |
| [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/) | 否         | 「[拜托，面试别再问我TopK了！！！](https://mp.weixin.qq.com/s/FFsvWXiaZK96PtUg-mmtEw)」 |
| [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | 否         |                                                              |
| [220. 存在重复元素 III](https://leetcode-cn.com/problems/contains-duplicate-iii/) | 否         | TreeSet、桶排序                                              |
| [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/) | 是         |                                                              |
| [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) | 是         |                                                              |

在二叉搜索树中搜索特定的值，根据BST的特性，对于每个节点：

1. 如果目标值等于节点的值，则返回节点
2. 如果目标值小于节点的值，则继续在左子树中搜索
3. 如果目标值大于节点的值，则继续在右子树中搜索

二叉搜索树插入节点：

1. 根据节点值与目标节点值的关系，搜索左子树或右子树
2. 重复步骤 1 直到到达外部节点
3. 根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点

二叉搜索树删除节点：

1. 如果目标节点没有子节点，我们可以直接移除该目标节点
2. 如果目标节只有一个子节点，我们可以用其子节点作为替换
3. 如果目标节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点

### 小结

二叉搜索树的有优点是，即便在最坏的情况下，也允许你在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。

通常来说，如果你想有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉搜索树这个数据结构是一个很好的选择。

使用场景：求数据流第K大的数：在BST每个节点中放置一个计数器，以计算以此节点为根的子树中有多少个节点

### 拓展

**二叉搜索树中操作的复杂性，是根据树的高度而变化**



#### **高度平衡的二叉搜索树**

**树结构中的常见用语:**

- 节点的深度 - 从树的根节点到该节点的边数
- 节点的高度 - 该节点和叶子之间最长路径上的边数
- 树的高度 - 其根节点的高度

**高度平衡的二叉搜索树定义：**

一个高度平衡的二叉搜索树（平衡二叉搜索树）是在插入和删除任何节点之后可以自动保持其高度最小。也就是说，有N个节点的平衡二叉搜索树，它的高度是logN，并且，每个节点的两个子树的高度不会相差超过1。

> 为什么是 `logN` 呢?
>
> - 一个高度为 `h` 的二叉树 
>   <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/height_balanced_bst_equation_1.png" alt="img" style="zoom:33%;" />.
> - 换言之，一个有 `N` 个节点，且高度为 `h` 的二叉树
>   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101645230.png)
> - 所以： 
>   <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/26/height_balanced_bst_equation_3.png" alt="img" style="zoom:33%;" />.

#### 为什么需要用到高度平衡的二叉搜索树?

- 以搜索操作为例，如果二叉搜索树的高度为 h ，则时间复杂度为 O(h) 
- 对于一个节点总数N，高度为h的平衡二叉树，![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101646092.png)
- 但对于一个普通的二叉搜索树，在最坏的情况下，它可以退化成一个链
- 因此，具有 N 个节点的二叉搜索树的高度在 logN 到 N 区间变化。也就是说，搜索操作的时间复杂度可以从 logN 变化到 N 。这是一个巨大的性能差异。
- 所以说，高度平衡的二叉搜索树对提高性能起着重要作用

#### 如何实现一个高度平衡的二叉搜索树?

1. 采用的数据结构应该满足二分查找属性和高度平衡属性

2. 采用的数据结构应该支持二叉搜索树的基本操作，包括在 **O(logN)** 时间内的搜索、插入和删除，即使在最坏的情况下也是如此

**常见的的高度平衡二叉树列表：**

- [红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)
- [AVL树](https://baike.baidu.com/item/AVL树/10986648?fr=aladdin)
- [伸展树](https://baike.baidu.com/item/伸展树/7003945?fromtitle=Splay+Tree&fromid=6987714&fr=aladdin)
- [树堆](https://baike.baidu.com/item/Treap/4321536?fr=aladdin)

#### 高度平衡的二叉搜索树的实际应用

平衡二叉搜索树的概念经常运用在 Set 和 Map 中，Set 和 Map 的原理相似

> Set（集合）是另一种数据结构，它可以存储大量 key（键）而不需要任何特定的顺序或任何重复的元素。 它应该支持的基本操作是将新元素插入到 Set 中，并检查元素是否存在于其中。
>

通常，有两种最广泛使用的集合：散列集合（Hash Set）和 树集合（Tree Set）

- 树集合，Java 中的 Treeset 或者 C++ 中的 set ，是由高度平衡的二叉搜索树实现的。因此，搜索、插入和删除的时间复杂度都是 O(logN) 。


- 散列集合，Java 中的 HashSet 或者 C++ 中的 unordered_set ，是由哈希实现的，但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 O(N) 时间复杂度来查找特定元素，其中N是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把时间复杂度从 O(N) 改善到 O(logN) 。


**哈希集和树集之间的本质区别在于树集中的键是有序的**

**总结:**高度平衡的二叉搜索树是二叉搜索树的特殊表示形式，旨在提高二叉搜索树的性能

## N叉树

**N叉树定义**：一棵以根节点开始，每个节点不超过 N 个子节点的树，称为 N叉树

**二叉树定义**：二叉树是一棵以根节点开始，每个节点含有不超过 2 个子节点的树

- 前缀树 ，又称 字典树（Trie）， 就是一个常用的 N 叉树
- 二叉树是 N 叉树的一种特殊表示形式

### N叉树的遍历

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/nary_tree_example.png)

1. 前序遍历
在 N 叉树中，前序遍历指先访问根节点，然后逐个遍历以其子节点为根的子树。
例如，上述三叉树的前序遍历是：A->B->C->E->F->D->G.
2. 后序遍历
在 N 叉树中，后序遍历指前先逐个遍历以根节点的子节点为根的子树，最后访问根节点。
例如，上述三叉树的后序遍历是：B->E->F->C->G->D->A.
3. 层序遍历
N 叉树的层序遍历与二叉树的一致。通常，当我们在树中进行广度优先搜索时，我们将按层序的顺序进行遍历。
例如，上述三叉树的层序遍历是：A->B->C->D->E->F->G.

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) | 是         |            |
| [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) | 是         |            |
| [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) | 是         |            |
| [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) | 否         | 迭代解法   |
| [428. 序列化和反序列化 N 叉树](https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/) | 是         |            |

## 位运算⭐（不熟悉，多复习下）

| 题目                                                         | 是否一次过 | 待解决问题  |
| ------------------------------------------------------------ | ---------- | ----------- |
| [504. 七进制数](https://leetcode-cn.com/problems/base-7/)    | 否         |             |
| [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/) | 否         |             |
| [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/) | 否         |             |
| [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/) | 否         |             |
| [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/) | 否         |             |
| [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)  | 否         | 没做        |
| [201. 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/) | 否         | 没做        |
| [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/) | 否         | dp解法      |
| [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/) | 是         |             |
| [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/) | 否         |             |
| [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/) | 否         |             |
| [1349. 参加考试的最大学生数](https://leetcode-cn.com/problems/maximum-students-taking-exam/) | 否         | 困难,待解决 |

## 排序算法全解析

| 题目                                                         | 是否一次过 | 待解决问题       |
| ------------------------------------------------------------ | ---------- | ---------------- |
| [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/) | 否         | 学习这道题的思想 |
| [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/) | 是         |                  |
| [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) | 是         | 堆排             |
| [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/) | 是         |                  |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) | 否         |                  |
| [506. 相对名次](https://leetcode-cn.com/problems/relative-ranks/) | 是         |                  |
|                                                              |            |                  |

### 时间复杂度$O(n^2)$级排序算法

冒泡排序、选择排序、插入排序

#### 冒泡排序

冒泡排序有两种优化方式：

- 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；
- 记录上次发生交换的位置，下一轮排序时只比较到此位置。

#### 选择排序

选择排序可以演变为二元选择排序：

二元选择排序：一次遍历选出两个值——最大值和最小值；
二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。

#### 插入排序

插入排序有两种写法：

- 交换法：新数字通过不断交换找到自己合适的位置；
- 移动法：旧数字不断向后移动，直到新数字找到合适的位置。

#### 相同点

- 时间复杂度都是 O(n^2)*O*(*n*2) ，空间复杂度都是 O(1)*O*(1)。
- 都需要采用两重循环。

#### 不同点

- 选择排序是不稳定的，冒泡排序、插入排序是稳定的；
- 在这三个排序算法中，选择排序交换的次数是最少的；
- 在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。

### 时间复杂度$O(nlog^n)$级排序算法



## 堆

堆：高效快速地取得当前数据集中最大或者最小的元素

在介绍 **堆** 之前，我们需要首先介绍下 **优先队列**

> 维基百科：优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。
>

在很多书中会认为 堆 就是 优先队列 。但是， 优先队列 是一种抽象的数据类型，而 堆 是一种数据结构。所以 堆 并不是 优先队列 ， **堆 是实现 优先队列 的一种方式**。

实现 优先队列 的方式有很多种，比如数组和链表。但是，这些实现方式只能保证插入操作和删除操作中的一种操作可以在 O(1) 的时间复杂度内完成，而另外一个操作则需要在 O(N)的时间复杂度内完成。而 堆 能够使 优先队列 的插入操作在 O(log N)的时间复杂度内完成，删除操作在 O(log N)的时间复杂度内完成。

### 堆的定义与分类

#### 堆的定义

根据 维基百科 的定义，堆 是一种特别的二叉树，满足以下条件的二叉树，可以称之为 堆：

1. 完全二叉树

   - **完美二叉树：**

     - 一棵深度为k，且有{\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}![{\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/40e7e2aed4ee10bc92e2fd88afda4b76da298a48)个节点的[二叉树](https://zh.wikipedia.org/wiki/二元樹)，称为[完美二叉树](https://zh.wikipedia.org/w/index.php?title=完美二元樹&action=edit&redlink=1)（Perfect Binary Tree)。这种树的特点是每一层上的节点数都是最大节点数。

   - **完全二叉树：**

     - 在一颗[二叉树](https://zh.wikipedia.org/wiki/二元樹)中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此[二叉树](https://zh.wikipedia.org/wiki/二元樹)为[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)（Complete Binary Tree）。具有n个节点的[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)的深度为${\displaystyle log_{2}n+1}$。深度为k的[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)，至少有${\displaystyle 2^{\begin{aligned}k-1\end{aligned}}}$个节点，至多有${\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}$个节点。

     ![image-20211114170608776](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141706732.png)

     |           | [ 完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)  | 完美二叉树                         |
     | :-------: | :------------------------------------------------------: | ---------------------------------- |
     | 总节点$k$ | ${\displaystyle 2^{h-1}}<= k <= {\displaystyle 2^{h}-1}$ | $k = {\displaystyle 2^{h}-1}$      |
     |  树高$h$  |             $h = {\displaystyle log_{2}k+1}$             | $h = {\displaystyle log_{2}(k+1)}$ |

2. 每一个节点的值都必须 大于等于或者小于等于 其孩子节点的值。

**堆 具有以下的特点：**

1. 可以在 O(logN) 的时间复杂度内向 堆 中插入元素；

2. 可以在 O(logN) 的时间复杂度内向 堆 中删除元素；
3. 可以在 O(1) 的时间复杂度内获取 堆 中的最大值或最小值。

#### 堆的分类

堆 有两种类型：最大堆 和 最小堆。

- 最大堆：堆中每一个节点的值 都大于等于 其孩子节点的值。所以最大堆的特性是 堆顶元素（根节点）是堆中的最大值。


- 最小堆：堆中每一个节点的值 都小于等于 其孩子节点的值。所以最小堆的特性是 堆顶元素（根节点）是堆中的最小值。


![image.png](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141656518.png)

#### 基于数组实现堆

**完全二叉树与数组的转换**

1. 如何找到节点n的父节点？
   - 父节点下标 = n/2
2. 如何找到节点n的左孩子节点和右孩子节点
   - $左孩子节点下标 = 2*n$
   - $右孩子节点下标 = 2*n +1$
3. 如何确定长度为n的完全二叉树的一个节点是否是叶子节点
   - $长度为n的完全二叉树的叶子节点下标 大于 n/2$

![image-20211114172207301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141722372.png)

#### 算法实现

```java
/**
 * 最大堆
 *
 * @author miemiehoho
 * @date 2021/11/14 17:33
 */
public class MaxHeap {
    // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个堆
    int[] maxHeap;
    // 数组的大小
    int heapSize;
    // 记录堆的元素个数
    int realSize;

    public MaxHeap(int heapSize) {
        this.heapSize = heapSize;
        maxHeap = new int[heapSize + 1];
        // 为了便于完全二叉树的管理，数组的第0个索引将不会被使用，其值可以设置成堆中的元素个数
        maxHeap[0] = 0;
    }

    /**
     * 添加元素
     *
     * @param val
     */
    public void add(int val) {
        realSize++;
        if (realSize > heapSize) {
            System.out.println("Add too many values!");
            realSize--;
            return;
        }
        // 将新的val添加到数组中
        maxHeap[realSize] = val;
        // 新增元素的索引位置
        int idx = realSize;
        // 新增元素的父节点的索引位置
        int parentIdx = idx / 2;
        // 当新增元素的值大于父节点值时，交换父子节点的值
        while (maxHeap[idx] > maxHeap[parentIdx] && idx > 1) {
            int temp = maxHeap[parentIdx];
            maxHeap[parentIdx] = maxHeap[idx];
            maxHeap[idx] = temp;
            idx = parentIdx;
            parentIdx = idx / 2;
        }
    }

    // 获得堆顶元素
    public int peek() {
        return maxHeap[1];
    }

    // 删除堆顶元素
    public int pop() {
        if (realSize < 1) {
            System.out.println("Don't have any value!");
            return Integer.MIN_VALUE;
        }
        // 需要删除的堆顶元素
        int removeVal = maxHeap[1];
        // 将堆中的最后一个元素赋值给堆顶
        maxHeap[1] = maxHeap[realSize];
        realSize--;
        // 需要调整的元素下标
        int idx = 1;
        // 当需要调整的元素不是叶子节点时
        while (idx < realSize && idx <= realSize / 2) {
            // 左孩子节点
            int left = idx * 2;
            // 右孩子节点
            int right = left + 1;
            // 当需要调整的元素小于其左（右）孩子，将其与左（右）孩子交换
            if (maxHeap[idx] < maxHeap[left] || maxHeap[idx] < maxHeap[right]) {
                if (maxHeap[left] > maxHeap[right]) {
                    swap(left, idx);
                    idx = left;
                } else {
                    swap(right, idx);
                    idx = right;
                }
            } else {
                break;
            }
        }
        return removeVal;
    }

    private void swap(int i, int j) {
        if (maxHeap[i] != maxHeap[j]) {
            maxHeap[j] ^= maxHeap[i];
            maxHeap[i] ^= maxHeap[j];
            maxHeap[j] ^= maxHeap[i];
        }
    }

}
```

### 堆的常用方法

#### 创建堆

时间复杂度：O(n)

空间复杂度：O(n)

```java
public static void main(String[] args) {
    // Java中的堆可以用优先队列来表示
    // 创建一个空的最小堆
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    // 创建一个空的最大堆
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((v1, v2) -> v1 - v2);
    // 创建带初始值的最小堆
    PriorityQueue<Integer> minHeadWithValues = new PriorityQueue<>(Arrays.asList(7, 4, 2, 9, 6));
}
```

| 「堆」的用法     | 时间复杂度 | 空间复杂度 |
| ---------------- | ---------- | ---------- |
| 创建「堆」       | O(N)       | O(N)       |
| 插入元素         | O(logN)    | O(1)       |
| 获取堆顶元素     | O(1)       | O(1)       |
| 删除堆顶元素     | O(logN)    | O(1)       |
| 获取「堆」的长度 | O(1)       | O(1)       |

### 堆的应用

#### 堆排序

**理论**：堆排序指的是利用**堆**的数据结构对一组无序元素进行排序。

**最小堆排序算法：**

1. 将所有元素堆化成一个 最小堆 ；

2. 取出并删除堆顶元素，并将该堆顶元素放置在存储有序元素的数据集 T 中；
3. 此时，堆 会调整成新的 最小堆；
4. 重复 3 和 4 步骤，直到 堆 中没有元素；
5. 此时得到一个新的数据集 T，其中的元素按照 从小到大 的顺序排列。

**最大堆排序算法：**

1. 将所有元素堆化成一个 最大堆；

2. 取出并删除堆顶元素，并将该堆顶元素放置在存储有序元素的数据集 T 中；
3. 此时，堆 会调整成新的 最大堆；
4. 重复 3 和 4 步骤，直到 堆 中没有元素；
5. 此时得到一个新的数据集 T，其中的元素按照从大到小的顺序排列。

**时间复杂度：**$O(Nlog^N)$，N 是 **堆** 中的元素个数。

**空间复杂度：**$O(N)$，N 是 **堆** 中的元素个数。

### Top K问题

**Top K 问题:** 获取Top K 大的元素

#### 解法一：最大堆

解法步骤：

1. 创建一个最大堆
2. 将所有元素加入到最大堆中
3. 通过边删除边遍历的方式，将堆顶元素删除并保存到结果集T中
4. 重复步骤3 K次，直到获取前K大的元素

**时间复杂度：** $O(Klog^N)$

**空间复杂度：**$O(N)$

#### 解法二：最小堆

解法步骤：

1. 创建一个大小为K的最小堆
2. 依次将元素添加到最小堆中
3. 当最小堆的个数达到K时，将堆顶元素与当前元素对比：
   1. 如果当前元素小于堆顶，则放弃当前元素，继续进行下一轮比较
   2. 如果当前元素大于堆顶，则删除堆顶元素，将当前元素加入到最小堆中
4. 重复步骤 2 和 3 ，直到所有元素遍历完毕
5. 此时 最小堆 中的 K个元素就是前 K 个最大的元素

**时间复杂度：** $O(Nlog^K)$

**空间复杂度：**$O(K)$

### The Kth 问题

参照上面的Top K问题解法

![image-20211114200754976](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111142007171.png)



## 排序算法全解析

| 题目                                                         | 是否一次过 | 待解决问题     |
| ------------------------------------------------------------ | ---------- | -------------- |
| [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) | 是         |                |
| [剑指 Offer 40. 最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) | 是         |                |
| [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/) | 是         |                |
| [169. 多数元素](https://leetcode-cn.com/problems/majority-element/) | 否         | 摩尔投票法     |
| [面试题 10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/) | 否         | 归并逆序双指针 |
| [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) | 否         | 树状数组       |
| [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/) | 是         |                |
| [1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/) | 是         |                |
| [164. 最大间距](https://leetcode-cn.com/problems/maximum-gap/) | 否         | 桶排序         |
| [561. 数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/) | 是         |                |
| [908. 最小差值 I](https://leetcode-cn.com/problems/smallest-range-i/) | 是         |                |
| [164. 最大间距](https://leetcode-cn.com/problems/maximum-gap/) | 否         | 桶排           |

## 前缀树

`前缀树` ，又称 `字典树` ，是 `N 叉树` 的特殊形式。

### 简介

#### 什么是前缀树

`前缀树` 是 `N叉树` 的一种特殊形式。通常来说，一个前缀树是用来 `存储字符串` 的。前缀树的每一个节点代表一个 `字符串`（`前缀`）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的 `原始字符串` ，以及 `通往该子节点路径上所有的字符` 组成的。

下面是前缀树的一个例子：

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111210832143.png)

在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。

值得注意的是，根节点表示 `空字符串` 。

前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 `前缀树` 名称的由来。

我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。

前缀树有着广泛的应用，例如自动补全，拼写检查等等。

#### 如何表示一个前缀树

前缀树的特别之处在于字符和子节点之间的对应关系。有许多不同的表示前缀树节点的方法，这里我们只介绍其中的两种方法。

##### 方法一 - 数组

第一种方法是用 `数组` 存储子节点。

例如，如果我们只存储含有字母 a 到 z 的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符 c ，我们可以使用 c - 'a' 作为索引来查找数组中相应的子节点。

访问子节点十分 `快捷` 。访问一个特定的子节点比较 `容易` ，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节点都需要这样的操作，所以这可能会导致 `空间的浪费` 。

##### 方法二 - Map

第二种方法是使用 `Hashmap` 来存储子节点。

我们可以在每个节点中声明一个 Hashmap 。Hashmap 的键是字符，值是相对应的子节点。

通过相应的字符来访问特定的子节点 `更为容易` 。但它可能比使用数组 `稍慢一些` 。但是，由于我们只存储我们需要的子节点，因此 `节省了空间` 。这个方法也更加 `灵活` ，因为我们不受到固定长度和固定范围的限制。

##### 补充

我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。

例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。

### 基本操作

#### 插入

如果我们在前缀树中插入一个字符串 S，我们要从根节点开始。 我们将根据 S[0]（S中的第一个字符），选择一个子节点或添加一个新的子节点。然后到达第二个节点，并根据 S[1] 做出选择。 再到第三个节点，以此类推。 最后，我们依次遍历 S 中的所有字符并到达末尾。 末端节点将是表示字符串 S 的节点。

通常情况情况下，你需要自己构建前缀树。构建前缀树实际上就是多次调用插入函数。但请记住在插入字符串之前要 `初始化根节点` 。

#### 搜索

正如我们在前缀树的简介中提到的，所有节点的后代都与该节点相对应字符串的有着共同前缀。因此，很容易搜索以特定前缀开头的任何单词。

同样地，我们可以根据给定的前缀沿着树形结构搜索下去。一旦我们找不到我们想要的子节点，搜索就以失败终止。否则，搜索成功。

##### 搜索单词

如何搜索特定的单词，而不是前缀。我们可以将这个词作为前缀，并同样按照上述同样的方法进行搜索。

- 如果搜索失败，那么意味着没有单词以目标单词开头，那么目标单词绝对不会存在于前缀树中。

- 如果搜索成功，我们需要检查目标单词是否是前缀树中单词的前缀，或者它本身就是一个单词。为了进一步解决这个问题，你可能需要稍对节点的结构做出修改。

**提示：**往每个节点中加入布尔值可能会有效地帮助你解决这个问题。

| 题目                                                         | 是否一次过 | 待解决问题                         |
| ------------------------------------------------------------ | ---------- | ---------------------------------- |
| [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) | 否         | ElasticSearch-倒排索引、二维数组法 |
| [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/) | 否         |                                    |
| [648. 单词替换](https://leetcode-cn.com/problems/replace-words/) | 否         |                                    |
| [642. 设计搜索自动补全系统](https://leetcode-cn.com/problems/design-search-autocomplete-system/) | 否         | 前缀树+自定义比较器                |
| [211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/) | 否         | 注意条件                           |
| [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) | 否         | 前缀树模板题                       |
| [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/) | 否         | 复习！！！                         |
| [425. 单词方块](https://leetcode-cn.com/problems/word-squares/) | 否         | 46. 全排列 + 422. 有效的单词方块   |
| [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/) | 否         |                                    |

- [*T**r**i**e* 第一部（Trie 模板题）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488490&idx=1&sn=db2998cb0e5f08684ee1b6009b974089&chksm=fd9cb8f5caeb31e3f7f67dba981d8d01a24e26c93ead5491edb521c988adc0798d8acb6f9e9d&scene=178&cur_album_id=2049538161285955584#rd)
- [Trie*T**r**i**e* 第二部（Trie 优化 DFS 搜索）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489083&idx=1&sn=1971fdceb180ef3c7d51f8fbb81527d0&chksm=fd9cbd24caeb34321076e3f34bae0c001c9032b2b1814d15badab26cd4e8cddf48ac051550f6&scene=178&cur_album_id=2049538161285955584#rd)
- [Trie*T**r**i**e* 第三部（结合贪心的 Trie）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489106&idx=1&sn=b7c1d4864f42e8a54f4b4754ff9ba8d7&chksm=fd9cbd4dcaeb345b5e39e799bdbeb2e89ed424c763e2af2a23fcb8eab228acc46d10f0395686&token=1901895674&lang=zh_CN#rd)
- [Trie*T**r**i**e* 第四部（可删除/可计数的 Trie）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489259&idx=1&sn=042ee479cebfbcf1f3b517461b32ddac&chksm=fd9cbdf4caeb34e2254783b211bac795eb0c9bd9b4be844cf48450ca5afa7ca5694fd98f7d39&token=1848397639&lang=zh_CN#rd)

### 前缀树小结

Trie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。

其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111211114260.png)


#### Trie 的应用面

在纯算法领域，前缀树算是一种较为常用的数据结构。

不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。

如果考虑前缀匹配的话，工程也不会使用 Trie 。

一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。

另外，对于个别的超长字符 Trie 会进一步变深。

这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。

同时 Trie 的特殊结构，也会为分布式存储将会带来困难。

因此在工程领域中 Trie 的应用面不广。

至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。

而 ES 的实现则主要是依靠「倒排索引」。



## 图

「图」是由顶点和边组成的一种非线形数据结构。在「图」中有很多相关术语来描述一个图。

常见的三种类型的图：无向图、有向图、加权图

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/) | 否         | 并查集+DFS |
| [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/) | 是         | DFS        |
| [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/) | 否         | Kruskal    |
|                                                              |            |            |
|                                                              |            |            |



### 并查集

并查集（Union Find）也叫「不相交集合（Disjoint Set）」，专门用于 动态处理 不相交集合的「查询」与「合并」问题。

可以使用并查集的问题一般都可以使用基于遍历的搜索算法（深度优先搜索、广度优先搜索）完成，但是使用并查集会使得解决问题的过程更加清晰、直观。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251123145.png)



#### 并查集动态处理的两个问题

**查询（Find）**

查询图中的两个顶点是不是在同一个集合中。

> **注意**：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。

**合并（Union）**

将两个不相交集合进行合并。

#### 设计并查集的两种思想

**quick-find：基于 id**

「基于 id」的思想给每一个元素（顶点）分配一个唯一标识，称为 `id`。

- 初始化的时候：所有元素的 `id` 都不一样，表示一个元素单独属于一个集合。
- 如果两个元素的 `id` 一样，标识它们同属于一个集合；
- 合并的时候，需要将其中一个集合中的 **所有元素** 的 `id` 赋值成为另一个集合的 `id`（一个集合中的所有元素的 `id` 均一样）。

类似于：给每个元素（顶点）改名字，名字一样，就表示在同一个集合中。

- 优点：查询两个元素是否在一个集合中很快，时间复杂度为 O(1)；
- 缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

**quick-union：基于 parent（重要）**

「基于 parent」的思想其实也很常见：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫「代表元」法。

我们不再使用 `id` 数组，而使用 `parent` 数组。`parent` 数组的定义是：`parent[i]` 表示标识为 `i` 的结点的父亲结点的标识（可以形象地记为「找爸爸」）。在这个定义下，根结点的父亲结点是自己。

这种方式形成的「并查集」组织成了 **若干个不相交的树形结构**，并且我们在访问结点的时候，总是按照「从下到上」进行访问的。

#### 详解代表元法

**「代表元」的「三个不重要」**

以下「三个不重要」概括了「代表元法」的设计理念，大家需要结合练习体会。

- 谁作为根结点不重要：根结点与非根结点只是位置不同，并没有附加的含义；
- 树怎么形成的不重要：合并的时候任何一个集合的根结点指向另一个结合的根结点就可以；
- 树的形态不重要：理由同「谁作为根结点不重要」。

**代表元法可能造成的问题**

树的高度过高，查询性能降低。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251200945.png)



> 知识扩展：几乎所有的「树」的问题都在和「树的高度」较劲：
>
> - 「快速排序」，使用随机化 `pivot` 的方式避免递归树太深；
> - 「二叉搜索树」为了避免递归树太深，采用不同的旋转方式，得到了 AVL 树和红黑树。

解决方案有「按秩合并」与「路径压缩」，我们先介绍「按秩合并」。

#### 按秩合并

按「秩」合并的意思是：让树的「秩」较小的树的根结点，指向树的「秩」较大的树的根结点。

这里的「秩」有两种含义，分别用于不同的场景：

- 按 `size` 合并，用于需要维护每个连通分量结点个数的时候；
- 按 `rank` 合并，绝大多数时候。

**按 `size` 合并**

按 `size` 合并的意思是让树的「结点总数」较小的树的根结点，指向树的「结点总数」较大的树的根结点。

**按 `rank` 合并**

按 `rank` 合并的意思是让树的「高度」较小的树的根结点，指向树的「高度」较大的树的根结点。

之所以把「高度」称为 `rank` ，是因为同时使用「按秩合并」和「路径压缩」的时候，树的「高度」很难维护其准确的定义，但是依然可以作为合并时候的依据，因此成为「秩」。

#### 路径压缩

**路径压缩方式 1：隔代压缩**

「隔代压缩」的意思是：两步一跳，一直循环执行「把当前结点指向它的父亲结点的父亲结点」这样的操作。下面是一个例子。![image_1637826447](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251550121.gif)

这样的压缩并不彻底，但是多压缩几次，就可以达到压缩彻底的效果。



**路径压缩方式 2：完全压缩**

「完全压缩」的意思是：把从「查询结点」到「根结点」沿途经过的所有结点都指向根结点。「完全压缩」相比较于「隔代压缩」，压缩彻底。

![image_1637827685](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611341.gif)

![image_1637827856](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611270.gif)

#### 时间复杂度分析

**同时使用了「路径压缩」和「按秩合并」的时间复杂度**

并查集的时间复杂度分析，其理论性较强，通常只需要知道结论即可。这里我们给出结论：

同时使用按秩合并与路径压缩时，最坏情况的时间复杂度为 $O(m \alpha(n))$，这里 $\alpha(n)$ 是一个增长非常慢的函数，$\alpha(n) \le 4$

结论的具体介绍请见《算法导论》第 21.4 节《带路径压缩的按秩合并的分析》

可以 **感性** 地这样理解结论：由于路径压缩采用「一边查询，一边修改树结构」的策略，并且 **修改树的结构是不可逆的**，合并之前需要先查询再合并。如果次数非常多的话，最后并查集里所有的树的高度都只有 2，平均到每一次「合并」和「查询」操作，步骤是常数次的

