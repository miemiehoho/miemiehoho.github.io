# 常见算法

# 总结



# 学习笔记

## 求解 无需数组中第 K 小的数

### 方法一 快排 partition （不是快排)

#### 算法描述

1. 利用快排的partition，**随机选**一个数 m
2. （荷兰国旗问题）将小于m的放左边，大于m的放右边，等于m的放中间 （时间复杂度$O(n)$ )
3. 如果 K 在 等于 m的 下标的区间范围内，直接返回 m
4. 如果 K 在等于 m的 下标的区间范围的左侧，那么在 m所在区间的左侧，递归调用 1~3 过程
5. 如果 K 在等于 m的 下标的区间范围的右侧，那么在 m所在区间的右侧，递归调用 1~3 过程

#### 时间复杂度

时间复杂度**收敛于**：$O(n)$

时间复杂度证明：

- $T(n) = T(n/2) + O(n) = ...$

- $n+n/2+n/4+…… = 2n*(1-2^{-n})$

所以 $T(n) = O(n)$

#### 算法实现

```java
// 在 nums[L...R] 范围，找排序后 位于 index位置的数
public int findKthLargest(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = nums[L + (int) (Math.random() * (R - L + 1))];
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return findKthLargest(nums, k, L, range[0] - 1);
    } else {
        return findKthLargest(nums, k, range[1] + 1, R);
    }
}

// 返回 等于区域的左右边界
private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;// 小于区域的右边界
    int more = R + 1;// 大于区域的左边界
    int idx = L;// 当前数
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, idx, --more);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### 方法二 BFPRT算法（线性查找算法）

**（笔试时不要用 bfprt ，常数项会有些高，且写起来挺麻烦，但是面试时候说完了 快排 partition可以讲一下bfprt）**

BFPRT 算法解决的问题十分经典，即在一个无序数组中求解第 K 小的数，且时间复杂度**严格为** $O(n)$

#### 算法描述

1. 选一个数 m
2. < m 的放左边，= m 的放中间，> m 的放右边
3. 如果命中 k，返回 m
4. 如果 k 在 m区间的左侧，递归调用左侧区间
5. 如果 k 在 m区间的右侧，递归调用右侧区间 

**m 的选择过程：**

1. 数组中，每5个数为一组，不足5个数的单独一组
2. 每5个数一组的数组内排序，时间复杂度 $O(1)$
3. 每组取中位数 $m_x$  组成中位数数组 M ,时间复杂度 $O(n)$，如果最后一个数组不足5个，则取 上中位数或下中位数
4. 找到中位数数组的中位数 m(长度为 n/5 )，求 m 方法：递归调用 bfprt(M,n/10)

#### 时间复杂度

时间复杂度为 $O(n)$

**时间复杂度证明：**（详细证明：算法导论第9章第三节）

1.  每5个数划分为一个组，时间复杂度为$O(1)$
2.  每个组内排序（共n/5个小组），时间复杂度为$O(n)$
3.  递归调用 bfprt，求M数组的中位数 m 作为划分值：bfprt(M,n/10),时间复杂度为 $T(n/5)$
4.  （荷兰国旗问题）将小于m的放左边，大于m的放右边，等于m的放中间 （时间复杂度$O(n)$ )
5.  从 m 的左右两侧 选一侧做递归，时间复杂度为 $T(?)$

那么总的时间复杂度为：$T(N) = T(n/5) + T(n)+T(?)$ 

因为划分值 m 是**精挑细选**的，所以 $T(?)$ 的值是可以确定的，**求 $T(?)$ 过程**：

**求 划分值 m 左侧的最大范围：**

1. 求 小于 m 的左侧区域的范围的最大值，即等同于 原数组中 最多有 多少个数小于 m，即等同于求`n - 大于等于 m 的至少有几个`
2. 在 长度 为 n/5 的中位数数组 M 中，至少有 n/10 个数大于等于中位数 m，对应原数组中，至少有 $n*(3/10)$ 个数 大于等于 m，也就是说 原数组中 最多有  $n * (7/10)$ 个数小于 m

- **精挑细选** m 的好处：可以确定性的每次最少 丢弃 3/10 规模的数

**求 划分值 m 右侧的最大范围：**同理，可得右侧最多 $n * (7/10)$

那么，$T(N) = T(n/5) + T(n)+T(n*(7/10)) =O(n)$

#### 算法实现

```java
// nums[L...R] 返回在有序情况下的位于k位置的数
public int bfprt(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = medianOfMedians(nums, L, R);// 获得 nums[L...R] 区间内中位数的中位数
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return bfprt(nums, k, L, range[0] - 1);
    } else {
        return bfprt(nums, k, range[1] + 1, R);
    }
}

// nums[L...R] 每5个数一组
// 每组数 组内排序
// 用每组的中位数组成中位数数组 M
// 返回中位数数组的中位数 m
private int medianOfMedians(int[] nums, int L, int R) {
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] M = new int[size / 5 + offset];// 中位数数组
    for (int team = 0; team < M.length; team++) {
        int teamFirst = L + team * 5;// 每组的第一个元素下标
        M[team] = getMedian(nums, teamFirst, Math.min(R, teamFirst + 4));
    }
    return bfprt(M, M.length / 2, 0, M.length - 1);
}

private int getMedian(int[] nums, int teamFirst, int teamLast) {
    insertionSort(nums, teamFirst, teamLast);
    return nums[(teamLast + teamFirst) / 2];
}

private void insertionSort(int[] nums, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        int temp = nums[i];
        for (int j = i; j >= L; j--) {
            if (j > L && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
}

private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;
    int more = R + 1;
    int idx = L;
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### 应用

**求 数组 arr 中前 10 小的数？**

1. 利用 bfprt 求第 10小的数
2. new一个长度为10的数组
3. 遍历 arr数组，找到所有小于 第10小的数，填入new数组
4. 如果 次数arr数组长度不足10，那么剩下的位置全填 第 10 小的数

## Manacher 算法

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=13&t=202.2

Manacher算法 用来解决最长回文子串问题

应用：在DNA序列中找最长回文子串

> Manacher 算法能解决最大回文半径问题，但不仅于此，回文半径数组的信息可以解决很多回文问题，不只是最长回文子串

### 定义概念

1. 回文半径、回文直径
2. 最右回文右边界 R
3. 最右回文中心点 C

### Manacher算法对 暴力求解的优化思路

**当中心点来到 i，若：**

1. i 在 R 外，无法加速，只能**暴力**求解

2. i 在 R 内，则可以加速，**加速**思路：

   - 当 i 在 R 内，则在 i 的左侧，必存在 一个点 i‘ ，关于 中心点 C 回文

     - 情况一：i' 的回文半径在 R内，则 最右回文右边界 R 不变，证明：

       [...a[...i'...]b......C......m[...i...]n...]

       设 a、b 是 i' 为回文中心点的左右边界：

       ​	a = n，b = m，且 a ≠ b，所以有 m ≠ n，所以 i 不可能存在更长的回文半径，所以最右回文右边界 R 不变

     - 情况二：i' 的回文半径在 R外，则 最右回文右边界 R 不变，i 的回文半径右边界 为 R，证明：

       (...a[......i'......b...)......C......m......i......]n

       b与m关于 C 对称： b = m,

       a与b关于 i' 对此：a = b,

       又因为 a和n 在 C 的最长回文左半径 L 和 最长回文右半径之外，

       a 不可能等于n，所以，i 的回文半径右边界 为 R

     - 情况三：i' 的回文半径左边界和 C 的左边界相同（压线），则最右回文右边界 R 可能右移，证明：

       ![image-20211210221528772](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112102215019.png)

### 时间复杂度

![image-20211210222015425](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112102220517.png)

每个位置扩失败次数：1次，每个位置扩成功次数等于 R右移次数

对于长度为n的字符串，扩失败：O(N)，扩成功:O(N)，所以时间复杂度为O(N)

### 代码实现

```java
package zs;

/**
 * @author miemiehoho
 * @date 2021/12/10 22:43
 */
public class Manacher {

    /**
     * 求字符串s的最长回文子串长度
     *
     * @param s
     * @return 最长回文子串长度
     */
    public static int maxLen(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] str = manacherString(s);
        int[] rLen = new int[str.length];// 每个回文串对应的回文半径大小
        int R = -1;// 最右的扩成功位置的下一个位置
        int C = -1;// 最右的扩成功位置的回文中心点
        int max = Integer.MIN_VALUE;// 最长回文子串长度
        for (int i = 0; i < str.length; i++) {
            // R > i : i 在 R内
            // Math.min(rLen[2 * C - i], R - i) ：i 在 R内情况下，i'的回文半径和 i到R的距离中较小的那个：
            //  ① i' 的回文半径在 R 内② i' 的回文半径在 R 外③ i' 的回文半径 压线
            rLen[i] = R > i ? Math.min(rLen[2 * C - i], R - i) : 1;// i位置扩出来的区域的回文半径
            while (i + rLen[i] < str.length && i - rLen[i] > -1) {// 判断左右边界
                if (str[i + rLen[i]] == str[i - rLen[i]]) {
                    rLen[i]++;
                } else {
                    break;
                }
            }
            if (i + rLen[i] > R) {
                C = i;
                R = i + rLen[i];
            }
            max = Math.max(max, rLen[i]);
        }
        return max - 1;
    }

    /**
     * @param s
     * @return 字符串s的manacher表示
     */
    private static char[] manacherString(String s) {
        char[] manacherStr = new char[s.length() * 2 + 1];
        int idx = 0;
        for (int i = 0; i < manacherStr.length; i++) {
            manacherStr[i] = (i & 1) == 0 ? '#' : s.charAt(idx++);
        }
        return manacherStr;
    }

}
```

## 窗口最大最小值的更新结构

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=13&t=6227.5



## AC自动机

左神视频：https://www.bilibili.com/video/BV1Jh41167s7?p=8





# 经典算法题

## 最长递增子序列

[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

时间复杂度 $O(n^2)$解法：动态规划；

时间复杂度 $O(nlog^n)$解法: 二分

### 动态规划解法

#### 暴力递归

```java
public int lengthOfLIS(int[] nums) {
    int max = 0;
    int len = 0;
    for (int i = nums.length - 1; i >= 0; i--) {
        len = maxLen(nums, i);
        max = Math.max(len, max);
    }
    return max;
}

// 返回索引为 idx 为结尾，所得到的最长递增子序列的长度
private int maxLen(int[] nums, int idx) {
    if (idx == -1) {
        return 0;
    }
    int maxLen = 1;
    int len = 0;
    for (int i = idx - 1; i >= 0; i--) {
        if (nums[i] < nums[idx]) {
            len = maxLen(nums, i) + 1;
            maxLen = Math.max(maxLen, len);
        }
    }
    return maxLen;
}
```

#### 动态规划

**时间复杂度：** $O(n^2)$ 

**空间复杂度：**$O(n)$

```java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    int ans = 0;
    for (int idx = 0; idx < nums.length; idx++) {
        dp[idx] = 1;
        for (int i = idx - 1; i >= 0; i--) {
            if (nums[i] < nums[idx]) {
                dp[idx] = Math.max(dp[idx], dp[i] + 1);
            }
        }
        ans = Math.max(ans, dp[idx]);
    }
    return ans;
}
```



### ~~动态规划解法~~

#### ~~暴力递归~~

```java
public int lengthOfLIS(int[] nums) {
    return maxLen(nums, 0, Integer.MIN_VALUE);
}

private int maxLen(int[] nums, int idx, int preValue) {
    if (idx == nums.length) {
        return 0;
    }
    if (nums[idx] <= preValue) {
        return maxLen(nums, idx + 1, preValue);
    }
    int len1 = maxLen(nums, idx + 1, nums[idx]) + 1;
    int len2 = maxLen(nums, idx + 1, preValue);
    return Math.max(len1, len2);
}
```

#### ~~动态规划~~

~~**时间复杂度：** $O(n^2)$~~ 

~~**空间复杂度：**$O(n)$~~

```java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    int minValue = 0;
    for (int idx = nums.length - 1; idx > 0; idx--) {
        int len1 = dp[idx] + 1;
        for (int j = idx - 1; j >= 0; j--) {
            if (nums[idx] > nums[j]) {
                dp[j] = Math.max(len1, dp[j]);
            }
        }
        minValue = Math.max(len1, minValue);
    }
    return Math.max(dp[0] + 1, minValue);
}
```

### 二分解法

**时间复杂度：** $O(nlog^n)$ 

**空间复杂度：**$O(n)$

**算法思路:**

1. 创建一个 $ends 数组$，下标为 $i$ 的位置含义：代表遍历到目前为止，所有长度为 $i+1$ 的递增子序列中 最小结尾是 $ends[i]$ ; 并且这个 $ends 数组$ 有效区 一定是有序的（在更新 $ends数组$ 的过程保证了 $ends数组$ 有效区一定是有序的）
2. 从 $0$ 位置开始从左往右遍历 $nums数组$，并更新 $ends数组$
   1. 找到比 $ends数组$ 有效区最后一个位置的数更大的数 cur，扩充有效区：i = i+1
   2. 找到比 $ends数组$ 有效区最后一个位置的数更小的数 cur，在有效区中二分查找比 cur 大的最左位置的数，更新为 cur

```java
public int lengthOfLIS(int[] nums) {
    int[] ends = new int[nums.length];
    int len = 0;
    ends[0] = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > ends[len]) {// 找到比 ends[len] 更大的元素，扩充有效区
            ends[++len] = nums[i];
        } else if (nums[i] < ends[len]) {// 找到比 ends[len] 更小的元素，二分查找比 nums[i] 大的最小元素，更新
            int left = 0, right = len;
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (nums[i] > ends[mid]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            ends[left] = nums[i];
        }
    }
    return len + 1;
}
```

### 拓展 - 输出字典序最小的（路径）最长递增子序列

[输出最长递增子序列](https://www.nowcoder.com/study/live/718/3/10)

#### ~~动态规划解法~~

~~**时间复杂度：** $O(n^2)$~~ 

~~**空间复杂度：**$O(n^2)$~~

```java
package code_top.tx;

import java.util.*;

/**
 * @author miemiehoho
 * @date 2021/12/19 9:47
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        List<Integer> ans = lengthOfLIS(nums);
        Collections.reverse(ans);
        for (int a : ans) {
            System.out.print(a + " ");
        }
    }

    public static List<Integer> lengthOfLIS(int[] nums) {
        List<Integer>[] dp = new List[nums.length];
        for (int i = 0; i < nums.length; i++) {
            dp[i] = new ArrayList<>();
        }
        List<Integer> minValue = new ArrayList<>();
        for (int idx = nums.length - 1; idx > 0; idx--) {
            int len1 = dp[idx].size() + 1;
            for (int j = idx - 1; j >= 0; j--) {
                int preValue = nums[j];
                if (nums[idx] > preValue) {
                    int len2 = dp[j].size();
                    if (len1 > len2) {
                        List<Integer> list = new ArrayList<>();
                        list.addAll(dp[idx]);
                        list.add(nums[idx]);
                        dp[j] = list;
                    }
                }
            }
            if (len1 > minValue.size()) {
                List<Integer> list = new ArrayList<>();
                list.addAll(dp[idx]);
                list.add(nums[idx]);
                minValue = list;
            }
        }
        dp[0].add(nums[0]);
        if (dp[0].size() > minValue.size()) {
            return dp[0];
        }
        return minValue;
    }

}
```

#### 动态规划解法

**时间复杂度：** $O(n^2)$ 

**空间复杂度：**$O(n^2)$

```java
package code_top.tx;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;

/**
 * @author miemiehoho
 * @date 2021/12/19 9:47
 */
public class Main {

    private static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) (st.nval);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = nextInt();
        }
        int[] lis = LIS(nums, getDp(nums));
        for (int i : lis) {
            System.out.print(i + " ");
        }
    }

    // 获取dp数组
    // dp数组含义：以 idx 结尾的 递增子序列的最大长度
    public static int[] getDp(int[] nums) {
        int[] dp = new int[nums.length];
        for (int idx = 0; idx < nums.length; idx++) {
            dp[idx] = 1;
            for (int j = idx - 1; j >= 0; j--) {
                if (nums[j] < nums[idx]) {
                    dp[idx] = Math.max(dp[idx], dp[j] + 1);
                }
            }
        }
        return dp;
    }

    // 1. 根据dp数组找到最长递增子序列的最大长度以及结尾元素
    // 2. 从结尾元素开始，从右往左遍历查找最长递增子序列元素
    public static int[] LIS(int[] nums, int[] dp) {
        int curIdx = 0;
        int maxLen = 0;
        int value = Integer.MAX_VALUE;
        for (int idx = 0; idx < nums.length; idx++) {
            if (dp[idx] > maxLen) {// 等于号 保证了找到最后一个 最长递增子序列的结尾元素
                maxLen = dp[idx];
                curIdx = idx;
                value = nums[idx];
            } else if (dp[idx] == maxLen) {
                if (nums[idx] < value) {
                    curIdx = idx;
                    value = nums[idx];
                }
            }
        }
        int[] lis = new int[maxLen];
        int idx = maxLen;
        lis[--idx] = nums[curIdx];// 结尾元素
        for (int i = curIdx; i >= 0; i--) {
            // 当前元素小于后一个子序列元素，且当前元素结尾的 递增子序列的最大长度 = 后一个子序列元素最大长度 - 1
            if (nums[i] < lis[idx] && dp[i] == dp[curIdx] - 1) {
                lis[--idx] = nums[i];
                curIdx = i;
            }
        }
        return lis;
    }

}
```

#### 二分解法

**时间复杂度：** $O(nlog^n)$ 

**空间复杂度：**$O(n)$

```java
package code_top.tx;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;

/**
 * @author miemiehoho
 * @date 2021/12/19 9:47
 */
public class Main {

    private static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) (st.nval);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        int n = nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = nextInt();
        }
        int[] lis = LIS(nums, getDp(nums));
        for (int i : lis) {
            System.out.print(i + " ");
        }
    }

    // 获取dp数组
    // dp数组含义：以 idx 结尾的 递增子序列的最大长度
    public static int[] getDp(int[] nums) {
        int[] ends = new int[nums.length];
        int[] dp = new int[nums.length];
        int idx = 0;
        ends[0] = nums[0];
        dp[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > ends[idx]) {
                ends[++idx] = nums[i];
                dp[i] = idx + 1;
            } else {
                int left = 0, right = idx;
                while (left < right) {
                    int mid = left + ((right - left) >> 1);
                    if (nums[i] > ends[mid]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                ends[left] = nums[i];
                dp[i] = left + 1;
            }
        }
        return dp;
    }

    // 1. 根据dp数组找到最长递增子序列的最大长度以及结尾元素
    // 2. 从结尾元素开始，从右往左遍历查找最长递增子序列元素
    public static int[] LIS(int[] nums, int[] dp) {
        int curIdx = 0;
        int maxLen = 0;
        int value = Integer.MAX_VALUE;
        for (int idx = 0; idx < nums.length; idx++) {
            if (dp[idx] > maxLen) {// 等于号 保证了找到最后一个 最长递增子序列的结尾元素
                maxLen = dp[idx];
                curIdx = idx;
                value = nums[idx];
            } else if (dp[idx] == maxLen) {
                if (nums[idx] < value) {
                    curIdx = idx;
                    value = nums[idx];
                }
            }
        }
        int[] lis = new int[maxLen];
        int idx = maxLen;
        lis[--idx] = nums[curIdx];// 结尾元素
        for (int i = curIdx; i >= 0; i--) {
            // 当前元素小于后一个子序列元素，且当前元素结尾的 递增子序列的最大长度 = 后一个子序列元素最大长度 - 1
            if (nums[i] < lis[idx] && dp[i] == dp[curIdx] - 1) {
                lis[--idx] = nums[i];
                curIdx = i;
            }
        }
        return lis;
    }

}
```

### 最长递增子序列补充问题：信封问题

[信封嵌套问题](https://www.nowcoder.com/study/live/718/3/13)

给n个信封的长度和宽度。如果信封A的长和宽都小于信封B，那么信封A可以放到信封B里，请求出信封最多可以嵌套多少层。

输入描述:

```
输出包含多行，第一行包括一个整数，代表信封的个数n。接下来n行，每行两个整数，代表信封的长度和宽度
```

 输出描述:

```
输出包括一行，代表信封最多嵌套多少层。
```



```java
package code_top.tx;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StreamTokenizer;
import java.util.Arrays;
import java.util.Comparator;

/**
 * @author miemiehoho
 * @date 2021/12/19 9:47
 */
public class Main {

    private static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));

    private static int nextInt() {
        try {
            st.nextToken();
            return (int) (st.nval);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        int n = nextInt();// 信封个数
        int[][] nums = new int[n][2];
        for (int i = 0; i < n; i++) {
            nums[i][0] = nextInt();// 长度
            nums[i][1] = nextInt();// 宽度
        }
        Arrays.sort(nums, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[0] == o2[0]) {
                    return o1[1] - o2[1];
                }
                return o1[0] - o2[0];
            }
        });
        int[] ends = new int[n];
        ends[0] = nums[0][1];
        int idx = 0;
        for (int i = 1; i < n; i++) {
            if (nums[i][1] > ends[idx]) {
                ends[++idx] = nums[i][1];
            } else {
                int left = 0, right = idx;
                while (left < right) {
                    int mid = left + ((right - left) >> 1);
                    if (nums[i][1] > ends[mid]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                ends[left] = nums[i][1];
            }
        }
        System.out.println(idx + 1);
    }

}
```