# 常见算法

# 总结



# 学习笔记

## 求解 无需数组中第 K 小的数

### 方法一 快排 partition （不是快排)

#### 算法描述

1. 利用快排的partition，**随机选**一个数 m
2. （荷兰国旗问题）将小于m的放左边，大于m的放右边，等于m的放中间 （时间复杂度$O(n)$ )
3. 如果 K 在 等于 m的 下标的区间范围内，直接返回 m
4. 如果 K 在等于 m的 下标的区间范围的左侧，那么在 m所在区间的左侧，递归调用 1~3 过程
5. 如果 K 在等于 m的 下标的区间范围的右侧，那么在 m所在区间的右侧，递归调用 1~3 过程

#### 时间复杂度

时间复杂度**收敛于**：$O(n)$

时间复杂度证明：

- $T(n) = T(n/2) + O(n) = ...$

- $n+n/2+n/4+…… = 2n*(1-2^{-n})$

所以 $T(n) = O(n)$

#### 算法实现

```java
// 在 nums[L...R] 范围，找排序后 位于 index位置的数
public int findKthLargest(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = nums[L + (int) (Math.random() * (R - L + 1))];
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return findKthLargest(nums, k, L, range[0] - 1);
    } else {
        return findKthLargest(nums, k, range[1] + 1, R);
    }
}

// 返回 等于区域的左右边界
private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;// 小于区域的右边界
    int more = R + 1;// 大于区域的左边界
    int idx = L;// 当前数
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, idx, --more);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### 方法二 BFPRT算法（线性查找算法）

**（笔试时不要用 bfprt ，常数项会有些高，且写起来挺麻烦，但是面试时候说完了 快排 partition可以讲一下bfprt）**

BFPRT 算法解决的问题十分经典，即在一个无序数组中求解第 K 小的数，且时间复杂度**严格为** $O(n)$

#### 算法描述

1. 选一个数 m
2. < m 的放左边，= m 的放中间，> m 的放右边
3. 如果命中 k，返回 m
4. 如果 k 在 m区间的左侧，递归调用左侧区间
5. 如果 k 在 m区间的右侧，递归调用右侧区间 

**m 的选择过程：**

1. 数组中，每5个数为一组，不足5个数的单独一组
2. 每5个数一组的数组内排序，时间复杂度 $O(1)$
3. 每组取中位数 $m_x$  组成中位数数组 M ,时间复杂度 $O(n)$，如果最后一个数组不足5个，则取 上中位数或下中位数
4. 找到中位数数组的中位数 m(长度为 n/5 )，求 m 方法：递归调用 bfprt(M,n/10)

#### 时间复杂度

时间复杂度为 $O(n)$

**时间复杂度证明：**（详细证明：算法导论第9章第三节）

1.  每5个数划分为一个组，时间复杂度为$O(1)$
2.  每个组内排序（共n/5个小组），时间复杂度为$O(n)$
3. 递归调用 bfprt，求M数组的中位数 m 作为划分值：bfprt(M,n/10),时间复杂度为 $T(n/5)$
4. （荷兰国旗问题）将小于m的放左边，大于m的放右边，等于m的放中间 （时间复杂度$O(n)$ )
5. 从 m 的左右两侧 选一侧做递归，时间复杂度为 $T(?)$

那么总的时间复杂度为：$T(N) = T(n/5) + T(n)+T(?)$ 

因为划分值 m 是**精挑细选**的，所以 $T(?)$ 的值是可以确定的，**求 $T(?)$ 过程**：

**求 划分值 m 左侧的最大范围：**

1. 求 小于 m 的左侧区域的范围的最大值，即等同于 原数组中 最多有 多少个数小于 m，即等同于求`n - 大于等于 m 的至少有几个`
2. 在 长度 为 n/5 的中位数数组 M 中，至少有 n/10 个数大于等于中位数 m，对应原数组中，至少有 $n*(3/10)$ 个数 大于等于 m，也就是说 原数组中 最多有  $n * (7/10)$ 个数小于 m

- **精挑细选** m 的好处：可以确定性的每次最少 丢弃 3/10 规模的数

**求 划分值 m 右侧的最大范围：**同理，可得右侧最多 $n * (7/10)$

那么，$T(N) = T(n/5) + T(n)+T(n*(7/10)) =O(n)$

#### 算法实现

```java
// nums[L...R] 返回在有序情况下的位于k位置的数
public int bfprt(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = medianOfMedians(nums, L, R);// 获得 nums[L...R] 区间内中位数的中位数
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return bfprt(nums, k, L, range[0] - 1);
    } else {
        return bfprt(nums, k, range[1] + 1, R);
    }
}

// nums[L...R] 每5个数一组
// 每组数 组内排序
// 用每组的中位数组成中位数数组 M
// 返回中位数数组的中位数 m
private int medianOfMedians(int[] nums, int L, int R) {
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] M = new int[size / 5 + offset];// 中位数数组
    for (int team = 0; team < M.length; team++) {
        int teamFirst = L + team * 5;// 每组的第一个元素下标
        M[team] = getMedian(nums, teamFirst, Math.min(R, teamFirst + 4));
    }
    return bfprt(M, M.length / 2, 0, M.length - 1);
}

private int getMedian(int[] nums, int teamFirst, int teamLast) {
    insertionSort(nums, teamFirst, teamLast);
    return nums[(teamLast + teamFirst) / 2];
}

private void insertionSort(int[] nums, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        int temp = nums[i];
        for (int j = i; j >= L; j--) {
            if (j > L && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
}

private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;
    int more = R + 1;
    int idx = L;
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### 应用

**求 数组 arr 中前 10 小的数？**

1. 利用 bfprt 求第 10小的数
2. new一个长度为10的数组
3. 遍历 arr数组，找到所有小于 第10小的数，填入new数组
4. 如果 次数arr数组长度不足10，那么剩下的位置全填 第 10 小的数

## Manacher 算法

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=13&t=202.2

Manacher算法 用来解决最长回文子串问题

应用：在DNA序列中找最长回文子串

> Manacher 算法能解决最大回文半径问题，但不仅于此，回文半径数组的信息可以解决很多回文问题，不只是最长回文子串

### 定义概念

1. 回文半径、回文直径
2. 最右回文右边界 R
3. 最右回文中心点 C

### Manacher算法对 暴力求解的优化思路

**当中心点来到 i，若：**

1. i 在 R 外，无法加速，只能**暴力**求解

2. i 在 R 内，则可以加速，**加速**思路：

   - 当 i 在 R 内，则在 i 的左侧，必存在 一个点 i‘ ，关于 中心点 C 回文

     - 情况一：i' 的回文半径在 R内，则 最右回文右边界 R 不变，证明：

       [...a[...i'...]b......C......m[...i...]n...]

       设 a、b 是 i' 为回文中心点的左右边界：

       ​	a = n，b = m，且 a ≠ b，所以有 m ≠ n，所以 i 不可能存在更长的回文半径，所以最右回文右边界 R 不变

     - 情况二：i' 的回文半径在 R外，则 最右回文右边界 R 不变，i 的回文半径右边界 为 R，证明：

       (...a[......i'......b...)......C......m......i......]n

       b与m关于 C 对称： b = m,

       a与b关于 i' 对此：a = b,

       又因为 a和n 在 C 的最长回文左半径 L 和 最长回文右半径之外，

       a 不可能等于n，所以，i 的回文半径右边界 为 R

     - 情况三：i' 的回文半径左边界和 C 的左边界相同（压线），则最右回文右边界 R 可能右移，证明：

       ![image-20211210221528772](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112102215019.png)

### 时间复杂度

![image-20211210222015425](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112102220517.png)

每个位置扩失败次数：1次，每个位置扩成功次数等于 R右移次数

对于长度为n的字符串，扩失败：O(N)，扩成功:O(N)，所以时间复杂度为O(N)

### 代码实现

```java
package zs;

/**
 * @author miemiehoho
 * @date 2021/12/10 22:43
 */
public class Manacher {

    /**
     * 求字符串s的最长回文子串长度
     *
     * @param s
     * @return 最长回文子串长度
     */
    public static int maxLen(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] str = manacherString(s);
        int[] rLen = new int[str.length];// 每个回文串对应的回文半径大小
        int R = -1;// 最右的扩成功位置的下一个位置
        int C = -1;// 最右的扩成功位置的回文中心点
        int max = Integer.MIN_VALUE;// 最长回文子串长度
        for (int i = 0; i < str.length; i++) {
            // R > i : i 在 R内
            // Math.min(rLen[2 * C - i], R - i) ：i 在 R内情况下，i'的回文半径和 i到R的距离中较小的那个：
            //  ① i' 的回文半径在 R 内② i' 的回文半径在 R 外③ i' 的回文半径 压线
            rLen[i] = R > i ? Math.min(rLen[2 * C - i], R - i) : 1;// i位置扩出来的区域的回文半径
            while (i + rLen[i] < str.length && i - rLen[i] > -1) {// 判断左右边界
                if (str[i + rLen[i]] == str[i - rLen[i]]) {
                    rLen[i]++;
                } else {
                    break;
                }
            }
            if (i + rLen[i] > R) {
                C = i;
                R = i + rLen[i];
            }
            max = Math.max(max, rLen[i]);
        }
        return max - 1;
    }

    /**
     * @param s
     * @return 字符串s的manacher表示
     */
    private static char[] manacherString(String s) {
        char[] manacherStr = new char[s.length() * 2 + 1];
        int idx = 0;
        for (int i = 0; i < manacherStr.length; i++) {
            manacherStr[i] = (i & 1) == 0 ? '#' : s.charAt(idx++);
        }
        return manacherStr;
    }

}
```

## 窗口最大最小值的更新结构

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=13&t=6227.5



## AC自动机

左神视频：https://www.bilibili.com/video/BV1Jh41167s7?p=8