### [146. LRU ç¼“å­˜æœºåˆ¶](https://leetcode-cn.com/problems/lru-cache/)

#### ç¼“å­˜ç½®æ¢ç­–ç•¥ï¼ˆç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼‰

ä¸»å­˜å®¹é‡è¿œå¤§äºCPUç¼“å­˜ï¼Œç£ç›˜å®¹é‡è¿œå¤§äºä¸»å­˜ï¼Œå› æ­¤æ— è®ºæ˜¯å“ªä¸€å±‚æ¬¡çš„ç¼“å­˜éƒ½é¢ä¸´ä¸€ä¸ªåŒæ ·çš„é—®é¢˜ï¼šå½“å®¹é‡æœ‰é™çš„ç¼“å­˜çš„ç©ºé—²ç©ºé—´å…¨éƒ¨ç”¨å®Œåï¼Œåˆæœ‰æ–°çš„å†…å®¹éœ€è¦æ·»åŠ è¿›ç¼“å­˜æ—¶ï¼Œå¦‚ä½•æŒ‘é€‰å¹¶èˆå¼ƒåŸæœ‰çš„éƒ¨åˆ†å†…å®¹ï¼Œä»è€Œè…¾å‡ºç©ºé—´æ”¾å…¥è¿™äº›æ–°çš„å†…å®¹ã€‚



è§£å†³è¿™ä¸ªé—®é¢˜çš„ç®—æ³•æœ‰å‡ ç§ï¼Œå¦‚ï¼š

- æœ€ä¹…æœªä½¿ç”¨ç®—æ³•ï¼ˆLFUï¼‰
  - æŒ‰è®¿é—®é¢‘ç‡æ¥æ·˜æ±°
- å…ˆè¿›å…ˆå‡ºç®—æ³•ï¼ˆFIFOï¼‰
- æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³•ï¼ˆLRUï¼‰
  - æŒ‰è®¿é—®æ—¶åºæ¥æ·˜æ±°
- éæœ€è¿‘ä½¿ç”¨ç®—æ³•ï¼ˆNMRUï¼‰ç­‰ï¼Œ

è¿™äº›ç®—æ³•åœ¨ä¸åŒå±‚æ¬¡çš„ç¼“å­˜ä¸Šæ‰§è¡Œæ—¶æ‹¥æœ‰ä¸åŒçš„æ•ˆç‡å’Œä»£ä»·ï¼Œéœ€æ ¹æ®å…·ä½“åœºåˆé€‰æ‹©æœ€åˆé€‚çš„ä¸€ç§ã€‚



#### LRUåŸç†

LRUçš„è®¾è®¡åŸç†å°±æ˜¯ï¼Œå½“æ•°æ®åœ¨æœ€è¿‘ä¸€æ®µæ—¶é—´ç»å¸¸è¢«è®¿é—®ï¼Œé‚£ä¹ˆå®ƒåœ¨ä»¥åä¹Ÿä¼šç»å¸¸è¢«è®¿é—®ã€‚è¿™å°±æ„å‘³ç€ï¼Œå¦‚æœç»å¸¸è®¿é—®çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿå¿«é€Ÿå‘½ä¸­ï¼Œè€Œä¸å¸¸è®¿é—®çš„æ•°æ®ï¼Œæˆ‘ä»¬åœ¨å®¹é‡è¶…å‡ºé™åˆ¶åï¼Œè¦å°†å…¶æ·˜æ±°ã€‚

LRU çš„å…¨ç§°æ˜¯ Least Recently Usedï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è®¤ä¸ºæœ€è¿‘ä½¿ç”¨è¿‡çš„æ•°æ®åº”è¯¥æ˜¯æ˜¯ã€Œæœ‰ç”¨çš„ã€ï¼Œå¾ˆä¹…éƒ½æ²¡ç”¨è¿‡çš„æ•°æ®åº”è¯¥æ˜¯æ— ç”¨çš„ï¼Œå†…å­˜æ»¡äº†å°±ä¼˜å…ˆåˆ é‚£äº›å¾ˆä¹…æ²¡ç”¨è¿‡çš„æ•°æ®ã€‚

**å®ä¾‹ï¼š**

å®‰å“æ‰‹æœºåå°è¿è¡Œçš„æ’åºè§„åˆ™ï¼Œæœ€è¿‘ä½¿ç”¨çš„åº”ç”¨æ’åœ¨å‰é¢ï¼Œç³»ç»Ÿä¼šæ€æ­»æ’åºæœ€æœ«å°¾çš„åº”ç”¨ï¼Œä¸ºæ–°åº”ç”¨è…¾å‡ºç©ºé—´



#### LRU ç®—æ³•æè¿°

LRU ç®—æ³•å®é™…ä¸Šæ˜¯è®©ä½ è®¾è®¡æ•°æ®ç»“æ„ï¼šé¦–å…ˆè¦æ¥æ”¶ä¸€ä¸ª capacity å‚æ•°ä½œä¸ºç¼“å­˜çš„æœ€å¤§å®¹é‡ï¼Œç„¶åå®ç°ä¸¤ä¸ª APIï¼Œä¸€ä¸ªæ˜¯ put(key, val) æ–¹æ³•å­˜å…¥é”®å€¼å¯¹ï¼Œå¦ä¸€ä¸ªæ˜¯ get(key) æ–¹æ³•è·å– key å¯¹åº”çš„ valï¼Œå¦‚æœ key ä¸å­˜åœ¨åˆ™è¿”å› -1ã€‚æ³¨æ„ï¼Œget å’Œ put æ–¹æ³•å¿…é¡»éƒ½æ˜¯ O(1) çš„æ—¶é—´å¤æ‚åº¦ã€‚

##### ä¸¾ä¾‹å­

å¯ä»¥é€šè¿‡ ğŸŒ° æ¥ç†è§£ï¼Œå‡è®¾æˆ‘ä»¬æœ‰å®¹é‡ä¸º 2 çš„ LRUCache å’Œ æµ‹è¯•é”®å€¼å¯¹ [1-1,2-2,3-3] ï¼Œå°†å…¶æŒ‰ç…§é¡ºåºè¿›è¡Œæ’å…¥ & æŸ¥è¯¢ï¼š

æ’å…¥ 1-1ï¼Œæ­¤æ—¶æœ€æ–°çš„ä½¿ç”¨æ•°æ®ä¸º 1-1
æ’å…¥ 2-2ï¼Œæ­¤æ—¶æœ€æ–°ä½¿ç”¨æ•°æ®å˜ä¸º 2-2
æŸ¥è¯¢ 1-1ï¼Œæ­¤æ—¶æœ€æ–°ä½¿ç”¨æ•°æ®ä¸º 1-1
æ’å…¥ 3-3ï¼Œç”±äºå®¹å™¨å·²ç»è¾¾åˆ°å®¹é‡ï¼Œéœ€è¦å…ˆæ·˜æ±°å·²æœ‰æ•°æ®æ‰èƒ½æ’å…¥ï¼Œè¿™æ—¶å€™ä¼šæ·˜æ±° 2-2ï¼Œ3-3 æˆä¸ºæœ€æ–°ä½¿ç”¨æ•°æ®

é”®å€¼å¯¹å­˜å‚¨æ–¹é¢ï¼š

- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€æ¥ç¡®ä¿æ’å…¥å’ŒæŸ¥è¯¢çš„å¤æ‚åº¦ä¸º O(1)ï¼›

- å¦å¤–æˆ‘ä»¬è¿˜éœ€è¦é¢å¤–ç»´æŠ¤ä¸€ä¸ªã€Œä½¿ç”¨é¡ºåºã€åºåˆ—ï¼Œ
  - æˆ‘ä»¬æœŸæœ›å½“ã€Œæ–°æ•°æ®è¢«æ’å…¥ã€æˆ–ã€Œå‘ç”Ÿé”®å€¼å¯¹æŸ¥è¯¢ã€æ—¶ï¼Œèƒ½å¤Ÿå°†å½“å‰é”®å€¼å¯¹æ”¾åˆ°åºåˆ—å¤´éƒ¨ï¼Œè¿™æ ·å½“è§¦å‘ LRU æ·˜æ±°æ—¶ï¼Œåªéœ€è¦ä»åºåˆ—å°¾éƒ¨è¿›è¡Œæ•°æ®åˆ é™¤å³å¯ã€‚
  - æœŸæœ›åœ¨ O(1) å¤æ‚åº¦å†…è°ƒæ•´æŸä¸ªèŠ‚ç‚¹åœ¨åºåˆ—ä¸­çš„ä½ç½®ï¼Œå¾ˆè‡ªç„¶æƒ³åˆ°åŒå‘é“¾è¡¨ã€‚

##### å…·ä½“åˆ†æ

å…·ä½“çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨ã€Œé”®å€¼å¯¹ã€ï¼Œé”®å€¼å¯¹çš„é”®ä½œä¸ºå“ˆå¸Œè¡¨çš„ Keyï¼Œè€Œå“ˆå¸Œè¡¨çš„ Value åˆ™ä½¿ç”¨æˆ‘ä»¬è‡ªå·±å°è£…çš„ `Node` ç±»ï¼Œ`Node` åŒæ—¶ä½œä¸ºåŒå‘é“¾è¡¨çš„èŠ‚ç‚¹ã€‚

- æ’å…¥ï¼šæ£€æŸ¥å½“å‰é”®å€¼å¯¹æ˜¯å¦å·²ç»å­˜åœ¨äºå“ˆå¸Œè¡¨ï¼š
  - å¦‚æœå­˜åœ¨ï¼Œåˆ™æ›´æ–°é”®å€¼å¯¹ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
  - å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™æ£€æŸ¥å“ˆå¸Œè¡¨å®¹é‡æ˜¯å¦å·²ç»è¾¾åˆ°å®¹é‡ï¼š
    - æ²¡è¾¾åˆ°å®¹é‡ï¼šæ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
    - å·²è¾¾åˆ°å®¹é‡ï¼šå…ˆä»é“¾è¡¨å°¾éƒ¨æ‰¾åˆ°å¾…åˆ é™¤å…ƒç´ è¿›è¡Œåˆ é™¤ï¼ˆdelete æ“ä½œï¼‰ï¼Œç„¶åå†æ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
- æŸ¥è¯¢ï¼š
  - å¦‚æœæ²¡åœ¨å“ˆå¸Œè¡¨ä¸­æ‰¾åˆ°è¯¥ Keyï¼Œç›´æ¥è¿”å› -1âˆ’1ï¼›
  - å¦‚æœå­˜åœ¨è¯¥ Keyï¼Œåˆ™å°†å¯¹åº”çš„å€¼è¿”å›ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰

ä¸€äº›ç»†èŠ‚ï¼š

- ä¸ºäº†å‡å°‘åŒå‘é“¾è¡¨å·¦å³èŠ‚ç‚¹çš„ã€Œåˆ¤ç©ºã€æ“ä½œï¼Œæˆ‘ä»¬é¢„å…ˆå»ºç«‹ä¸¤ä¸ªã€Œå“¨å…µã€èŠ‚ç‚¹ `head` å’Œ `tail`

#### â­ç®—æ³•å®ç°

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

class LRUCache {

    class Node {
        int k, v;
        Node l, r;

        public Node(int k, int v) {
            this.k = k;
            this.v = v;
        }
    }

    int capacity;
    Map<Integer, Node> map;
    Node head, tail;    // å“¨å…µç»“ç‚¹

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.r = tail;
        tail.l = head;
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            refresh(cur);
            return cur.v;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            cur.v = value;
        } else {
            if (capacity == map.size()) {
                Node del = tail.l;
                remove(del);
                map.remove(del.k);
            }
            Node node = new Node(key, value);
            map.put(key, node);
        }
        refresh(map.get(key));
    }

    /**
     * 1.å…ˆåˆ é™¤ curç»“ç‚¹ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰
     * 2.å°†å½“å‰ç»“ç‚¹æ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨
     *
     * @param cur
     */
    private void refresh(Node cur) {
        remove(cur);
        cur.l = head;
        cur.r = head.r;
        head.r = cur;
        cur.r.l = cur;
    }

    /**
     * å› ä¸ºå¤´éƒ¨å­˜åœ¨å“¨å…µç»“ç‚¹ï¼Œæ‰€ä»¥å¦‚æœcur.l!=nullï¼Œåˆ™è¯æ˜curå­˜åœ¨äºåŒé“¾è¡¨ä¸­
     *
     * @param del
     */
    private void remove(Node del) {
        if (del.l != null) {
            del.l.r = del.r;
            del.r.l = del.l;
        }
    }
}
```

### [206. åè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
// åŒæŒ‡é’ˆ
public ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head, temp = null;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)

```java
// å¿«æ’
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }
    int rand = (int) (Math.random() * (end - start + 1)) + start;
    swap(nums, start, rand);
    int pivot = nums[start];
    int l = start, r = end;
    while (l < r) {
        while (l < r && nums[r] >= pivot) {
            r--;
        }
        while (l < r && nums[l] <= pivot) {
            l++;
        }
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, l);
    quickSort(nums, start, l - 1);
    quickSort(nums, l + 1, end);
}

private void swap(int[] nums, int l, int r) {
    if (nums[l] != nums[r]) {
        nums[r] ^= nums[l];
        nums[l] ^= nums[r];
        nums[r] ^= nums[l];
    }
}
```

### [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

æ—¶é—´å¤æ‚åº¦ $O(m+n)$

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) {
        return list2;
    }
    if (list2 == null) {
        return list1;
    }
    if (list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    }
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
}
```

### [23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

#### â­**å½’å¹¶æ³•**

æ—¶é—´å¤æ‚åº¦ï¼š$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    return mergeList(lists, 0, lists.length - 1);
}

private ListNode mergeList(ListNode[] lists, int start, int end) {
    if (start == end) {
        return lists[start];
    }
    int mid = (start + end) >> 1;
    ListNode list1 = mergeList(lists, start, mid);
    ListNode list2 = mergeList(lists, mid + 1, end);
    return merge(list1, list2);
}

private ListNode merge(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = merge(l1.next, l2);
        return l1;
    }
    l2.next = merge(l1, l2.next);
    return l2;
}
```

#### â­**å°æ ¹å †**

æ—¶é—´å¤æ‚åº¦ï¼š$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    PriorityQueue<ListNode> queue = new PriorityQueue<>((l1, l2) -> l1.val - l2.val);
    for (int i = 0; i < lists.length; i++) {
        queue.offer(lists[i]);
    }
    ListNode dummy = new ListNode();
    ListNode res = dummy;
    while (!queue.isEmpty()) {
        ListNode list = queue.poll();
        res.next = list;
        res = res.next;
        if (res.next != null) {
            queue.offer(res.next);
        }
    }
    return dummy.next;
}
```

### [8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

ç®—æ³•æ€è·¯ï¼š

1. å»æ‰å‰å¯¼ç©ºæ ¼
2. å†æ˜¯å¤„ç†æ­£è´Ÿå·
3. è¯†åˆ«æ•°å­—ï¼Œæ³¨æ„è¶Šç•Œæƒ…å†µ

```java
public int myAtoi(String s) {
    int idx = 0;
    while (idx < s.length() && s.charAt(idx) == ' ') {// ç§»é™¤å‰å¯¼ç©ºæ ¼
        idx++;
    }
    if (idx == s.length()) {
        return 0;
    }

    int result = 0;
    boolean negative = false;
    if (s.charAt(idx) == '-') {
        negative = true;
        idx++;
    } else if (s.charAt(idx) == '+') {
        idx++;
    }
    for (int i = idx; i < s.length() && Character.isDigit(s.charAt(i)); i++) {
        int digit = s.charAt(i) - '0';
        if ((Integer.MAX_VALUE - digit) / 10 < result) {
            return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        result = result * 10 + digit;
    }
    return negative ? -result : result;
}
```

### [234. å›æ–‡é“¾è¡¨](https://leetcode-cn.com/problems/palindrome-linked-list/)

```java
// æ–¹æ³•ä¸€ï¼šç¿»è½¬é“¾è¡¨ååˆ¤æ–­æ˜¯å¦å’ŒåŸé“¾è¡¨ç›¸åŒ
public boolean isPalindrome(ListNode head) {
    ListNode reserveList = reserve(head);
    while (head != null) {
        if (head.val != reserveList.val) {
            return false;
        }
        head = head.next;
        reserveList = reserveList.next;
    }
    return true;
}

private ListNode reserve(ListNode head) {
    ListNode pre = null, cur = head, res = null;
    while (cur != null) {
        res = new ListNode(cur.val, res);
        cur = cur.next;
    }
    return res;
}
```

```java
// æ–¹æ³•äºŒï¼šåŒç«¯é˜Ÿåˆ—
public boolean isPalindrome(ListNode head) {
    Deque<Integer> deque = new LinkedList<>();
    while (head != null) {
        deque.offerLast(head.val);
        head = head.next;
    }
    while (!deque.isEmpty() && deque.size() > 1) {
        if (deque.pollFirst() != deque.pollLast()) {
            return false;
        }
    }
    return true;
}
```

```java
// æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œç¿»è½¬ååŠéƒ¨åˆ†é“¾è¡¨ç„¶åä¸å‰åŠéƒ¨åˆ†æ¯”è¾ƒ
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    // å¯»æ‰¾ä¸­é—´ç»“ç‚¹
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    if (fast != null) {
        slow = slow.next;
    }
    slow = reserve(slow);
    while (slow != null) {
        if (slow.val != head.val) {
            return false;
        }
        slow = slow.next;
        head = head.next;
    }
    return true;
}

private ListNode reserve(ListNode node) {
    ListNode pre = null, temp = null, cur = node;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

#### â­**æ–¹æ³•ä¸‰ä¼˜åŒ–**

ä¼˜åŒ–ï¼šåœ¨å¿«æ…¢æŒ‡é’ˆå¯»æ‰¾ä¸­é—´ç»“ç‚¹è¿‡ç¨‹ï¼Œé¡ºä¾¿ç¿»è½¬å‰åŠéƒ¨åˆ†é“¾è¡¨

```java
// æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œåœ¨å¿«æ…¢æŒ‡é’ˆå¯»æ‰¾ä¸­é—´ç»“ç‚¹è¿‡ç¨‹ï¼Œé¡ºä¾¿ç¿»è½¬å‰åŠéƒ¨åˆ†é“¾è¡¨
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head, firstNode = head, pre = null;
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
        firstNode.next = pre;
        pre = firstNode;
        firstNode = slow;
    }
    if (fast != null) {
        slow = slow.next;
    }
    while (slow != null) {
        if (slow.val != pre.val) {
            return false;
        }
        pre = pre.next;
        slow = slow.next;
    }
    return true;
}
```

### [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode-cn.com/problems/binary-search/)

#### â­å·¦å³é—­åŒºé—´å†™æ³•

æ±‚ä¸­é—´æ•° 1.é˜²æ­¢æº¢å‡ºï¼Œå…ˆå‡ååŠ  2.ç”¨ç§»ä½æé«˜é€Ÿåº¦

```java
// äºŒåˆ†æŸ¥æ‰¾
public int search(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return -1;
}
```

### [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

#### â­åœ¨ä¸€ä¸ªæœ‰åºæ•°ç»„ä¸­ï¼Œæ‰¾ >=æŸä¸ªæ•°æœ€å·¦ä¾§ï¼ˆæœ€å³ä¾§ï¼‰çš„ä½ç½®

ï¼ï¼ï¼å°±çœ‹è¿™ä¸ªæ–¹æ³•å°±è¡Œï¼Œåˆ«çœ‹ç½‘ä¸Šé‚£äº›é¢˜è§£ï¼Œéƒ½æ˜¯åƒåœ¾ï¼Œè¿™ä¸ªæœ€å¥½ç†è§£

æ‰¾ >=æŸä¸ªæ•°  target æœ€å·¦ä¾§çš„ä½ç½®ï¼š

1. äºŒåˆ†æŸ¥æ‰¾ nums[mid] = target,è®°å½• å½“å‰ä½ç½®ä¸º mostL
2. å¾€å·¦ç»§ç»­äºŒåˆ†ï¼ŒæŸ¥æ‰¾ nums[mid] = targetï¼Œ
   - å¦‚æœ nums[mid]<target,åˆ™ç»§ç»­å¾€å³æ‰¾ï¼Œç›´åˆ°æ²¡æœ‰ä½ç½®å¯æ‰¾ï¼Œé‚£ä¹ˆæœ€å·¦ä¾§çš„è®°å½•ä½ç½®å°±æ˜¯ >=æŸä¸ªæ•°çš„æœ€å·¦ä½ç½®

```java
public int[] searchRange(int[] nums, int target) {
    int[] res = new int[]{-1, -1};
    if (nums == null || nums.length == 0) {
        return res;
    }
    int l = 0, r = nums.length - 1, mostL = -1, mostR = -1;
    // æŸ¥æ‰¾ ç­‰äº target æœ€å·¦ä¾§ä½ç½®
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostL = mid;
            r = mid - 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    if (mostL == -1) {
        return res;
    }
    res[0] = mostL;
    l = mostL;
    r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostR = mid;
            l = mid + 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    res[1] = mostR;
    return res;
}
```

### [470. ç”¨ Rand7() å®ç° Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

#### æ‹’ç»é‡‡æ ·é—®é¢˜

#### â­æ–¹æ³•ä¸€ï¼šä¸‡èƒ½æ„é€ æ³•ï¼šç‹¬ç«‹éšæœºäº‹ä»¶+å¤å…¸æ¦‚å‹

[1,X] çš„éšæœºæ•°å‘ç”Ÿå™¨ randX()  å¾ˆæ˜æ˜¾æ˜¯ä¸€ä¸ªå¤å…¸æ¦‚å‹ï¼šå®ƒçš„ç»“æœæ˜¯æœ‰é™çš„ï¼Œä¸”æ¯ä¸ªç»“æœçš„æ¦‚ç‡ç›¸åŒã€‚
ç‹¬ç«‹éšæœºäº‹ä»¶çš„æ¦‚ç‡ï¼šP(AB)=P(A)*P(B) 

é‚£ä¹ˆä»»æ„çš„ randX() éƒ½å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ„é€ ï¼š

1. æ„é€  n  æ¬¡ç›¸äº’ç‹¬ç«‹çš„é‡‡æ ·ï¼Œå…¶ä¸­ç¬¬ i  æ¬¡é‡‡æ ·æœ‰ $m_i$ ç§ç»“æœï¼Œä¸”ç¬¬ i*i* æ¬¡é‡‡æ ·ä¸­æ¯ç§ç»“æœçš„æ¦‚ç‡æ˜¯ $\frac{1}{m_i}$ ã€‚n è¦æ»¡è¶³$m_1*m_2*\cdots*m_n\ge X$ï¼Œå³æŠŠæ‰€æœ‰é‡‡æ ·ç»“æœç»„åˆèµ·æ¥ï¼Œæœ€ç»ˆçš„ç»“æœæ•°é‡ä¸å°‘äº X*ï¼Œä¿è¯å¯ä»¥æ˜ å°„åˆ° [1,X] çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚*

   è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬æ„é€ äº† $m_1*m_2*\cdots*m_n$ä¸ªç»“æœï¼Œå¹¶ä¸”æ¯ä¸ªç»“æœçš„æ¦‚ç‡éƒ½æ˜¯ $\frac{1}{m_1*m_2*\cdots*m_n}$

2. ä» $m_1*m_2*\cdots*m_n$  ä¸ªç»“æœä¸­å– X  ä¸ªï¼Œæ˜ å°„åˆ° [1,X]  åŒºé—´ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªå‡åŒ€åˆ†å¸ƒåœ¨ [1,X]  çš„éšæœºæ•°å‘ç”Ÿå™¨ã€‚

ç¬¬äºŒæ­¥ä¸­çš„æ˜ å°„æ˜¯ 1:1 æ˜ å°„ï¼Œå®é™…è¿ç”¨ä¸­ï¼Œç¬¬äºŒæ­¥å¯ä»¥å– k*X ä¸ªç»“æœæ¥åš  k:1  æ˜ å°„ï¼Œä»¥å‡å°‘è°ƒç”¨ rand7()  æ¬¡æ•°



**rand7() æ„é€  rand10()**

1. æ„é€  2 æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 2 å’Œ 5  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 10 ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 10  ç§ç»“æœæ˜ å°„åˆ° [1,10]  å³å¯ã€‚

ç¬¬ä¸€æ­¥å…·ä½“è¦å¦‚ä½•æ„é€ é‡‡æ ·æ˜¯è‡ªç”±çš„ï¼Œæ¯”å¦‚ rand7()  æ‹’ç» 7 ï¼Œç„¶åå¯¹ [1,6] é‡‡æ ·ï¼ŒæŠŠå¥‡æ•°å’Œå¶æ•°ä½œä¸º 2  ç§ç»“æœï¼Œè¿™ 2  ç§ç»“æœçš„æ¦‚ç‡å‡ä¸º 0.5 , rand7() æ‹’ç» 6,7 ï¼Œç„¶åå¯¹ [1,5]  é‡‡æ ·ï¼Œæœ‰ 5  ç§ç»“æœï¼Œæ¯ç§æ¦‚ç‡å‡ä¸º 0.2 

```java
public int rand10() {
    int rand1 = rand7();
    while (rand1 == 7) {
        rand1 = rand7();
    }
    int rand2 = rand7();
    while (rand2 > 5) {
        rand2 = rand7();
    }
    return (rand1 & 1) == 1 ? rand2 : 5 + rand2;
}
```

ä¸Šè¿°æ–¹æ³•ç†è®ºä¸Šå¯ä»¥æ„é€ ä»»ä½•èŒƒå›´çš„éšæœºæ•°å‘ç”Ÿå™¨ï¼Œæ¯”å¦‚

 rand11() ï¼š

1. æ„é€  2  æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 2   å’Œ 6  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 12  ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 12  ç§ç»“æœæ˜ å°„åˆ° [1,12]ï¼Œç„¶åå†æ‹’ç» 12  å³å¯ã€‚

rand100()  ï¼š

1. æ„é€  3  æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 4,5,5  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 100  ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 100 ç§ç»“æœæ˜ å°„åˆ° [1,100] å³å¯ã€‚

#### â­æ–¹æ³•äºŒï¼šk è¿›åˆ¶è¯¸ä½ç”Ÿæˆ + æ‹’ç»é‡‡æ ·

æ¯æ¬¡æ‰§è¡Œ rand7 éƒ½å¯ä»¥çœ‹ä½œä¸€æ¬¡ç‹¬ç«‹äº‹ä»¶ã€‚æˆ‘ä»¬å¯ä»¥å°†ä¸¤æ¬¡ rand7 çš„ç»“æœçœ‹ä½œç”Ÿæˆ 7  è¿›åˆ¶çš„ä¸¤ä½ã€‚ä»è€Œå®ç°æ¯ä¸ªæ•°å€¼éƒ½å”¯ä¸€å¯¹åº”äº†ä¸€ç§éšæœºå€¼çš„ç»„åˆï¼ˆç­‰æ¦‚ç‡ï¼‰ï¼Œåä¹‹äº¦ç„¶ã€‚

ä¸¾ä¸ªğŸŒ°ï¼Œè®¾éšæœºæ‰§è¡Œä¸¤æ¬¡ `rand7` å¾—åˆ°çš„ç»“æœåˆ†åˆ«æ˜¯ 4 ï¼ˆç¬¬ä¸€æ¬¡ï¼‰ã€7 ï¼ˆç¬¬äºŒæ¬¡ï¼‰ï¼Œç”±äºæˆ‘ä»¬æ˜¯è¦ 7  è¿›åˆ¶çš„æ•°ï¼Œå› æ­¤å¯ä»¥å…ˆå¯¹ `rand7` çš„æ‰§è¡Œç»“æœè¿›è¡Œ -1  æ“ä½œï¼Œå°†è¾“å‡ºåŸŸåç§»åˆ° [0, 6] ï¼ˆä»ä¸ºç­‰æ¦‚ç‡ï¼‰ï¼Œå³å¾—åˆ° 3 ï¼ˆç¬¬ä¸€æ¬¡ï¼‰å’Œ 6ï¼ˆç¬¬äºŒæ¬¡ï¼‰ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ˜¯æ•°å€¼ $(63)_7$ï¼Œæ•°å€¼ $(63)_7$  å”¯ä¸€å¯¹åº”äº†æˆ‘ä»¬çš„éšæœºå€¼ç»„åˆæ–¹æ¡ˆï¼Œåè¿‡æ¥éšæœºå€¼ç»„åˆæ–¹æ¡ˆä¹Ÿå”¯ä¸€å¯¹åº”ä¸€ä¸ª 7  è¿›åˆ¶çš„æ•°å€¼ã€‚

**é‚£ä¹ˆæ ¹æ®ã€Œè¿›åˆ¶è½¬æ¢ã€çš„ç›¸å…³çŸ¥è¯†ï¼Œå¦‚æœæˆ‘ä»¬å­˜åœ¨ä¸€ä¸ª `randK` çš„å‡½æ•°ï¼Œå¯¹å…¶æ‰§è¡Œ n  æ¬¡ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç­‰æ¦‚ç‡äº§ç”Ÿ [0, K^n - 1]  èŒƒå›´å†…çš„æ•°å€¼ã€‚**

å›åˆ°æœ¬é¢˜ï¼Œæ‰§è¡Œä¸€æ¬¡ `rand7` åªèƒ½äº§ç”Ÿ [0, 6]  èŒƒå›´å†…çš„æ•°å€¼ï¼Œä¸è¶³ 10  ä¸ªï¼›è€Œæ‰§è¡Œ 2  æ¬¡ `rand7` çš„è¯åˆ™èƒ½äº§ç”Ÿ [0, 48] ] èŒƒå›´å†…çš„æ•°å€¼ï¼Œè¶³å¤Ÿ 10 ä¸ªï¼Œä¸”ç­‰æ¦‚ç‡ã€‚

æˆ‘ä»¬åªéœ€è¦åˆ¤å®šç”Ÿæˆçš„å€¼æ˜¯å¦ä¸ºé¢˜æ„çš„ [1, 10]  å³å¯ï¼Œå¦‚æœæ˜¯çš„è¯ç›´æ¥è¿”å›ï¼Œå¦åˆ™ä¸€ç›´é‡è¯•ã€‚

```java
public int rand10() {
    int ans = -1;
    while (ans < 1 || ans > 10) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans;
}
```

#### â­æ–¹æ³•äºŒä¼˜åŒ–

**è¿›é˜¶**

1. é™ä½å¯¹ `rand7` çš„è°ƒç”¨æ¬¡æ•°

æˆ‘ä»¬å‘ç°ï¼Œåœ¨ä¸Šè¿°è§£æ³•ä¸­ï¼ŒèŒƒå›´ [0, 48][0,48] ä¸­ï¼Œåªæœ‰ [1, 10][1,10] èŒƒå›´å†…çš„æ•°æ®ä¼šè¢«æ¥å—è¿”å›ï¼Œå…¶ä½™æƒ…å†µå‡è¢«æ‹’ç»é‡è¯•ã€‚

ä¸ºäº†å°½å¯èƒ½å°‘çš„è°ƒç”¨ `rand7` æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä» [0, 48][0,48] ä¸­å–ä¸ [1, 10][1,10] æˆå€æ•°å…³ç³»çš„æ•°ï¼Œæ¥è¿›è¡Œè½¬æ¢ã€‚

æˆ‘ä»¬å¯ä»¥å– [0, 48][0,48] ä¸­çš„ [1, 40][1,40] èŒƒå›´å†…çš„æ•°æ¥ä»£æŒ‡ [1, 10][1,10]ã€‚

é¦–å…ˆåœ¨ [0, 48][0,48] ä¸­å– [1, 40][1,40] ä»ä¸ºç­‰æ¦‚ç‡ï¼Œå…¶æ¬¡å½¢å¦‚ x1  çš„æ•°å€¼æœ‰ 4  ä¸ªï¼ˆ1 ã€11 ã€21 ã€31 ï¼‰ï¼Œå½¢å¦‚ x2  çš„æ•°å€¼æœ‰ 4  ä¸ªï¼ˆ2 ã€12 ã€22 ã€32 ï¼‰... å› æ­¤æœ€ç»ˆç»“æœä»ä¸ºç­‰æ¦‚ç‡ã€‚

```java
public int rand10() {
    int ans = -1;
    while (ans < 0 || ans > 40) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans % 10 + 1;
}
```

### [53. æœ€å¤§å­æ•°ç»„å’Œ](https://leetcode-cn.com/problems/maximum-subarray/)

#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

ç”¨ max è®°å½•ç»“æœï¼Œtempè®°å½•å½“å‰çš„å­æ•°ç»„å’Œï¼š

1. å¾€å³éå†ï¼Œæ›´æ–°tempï¼š
   - å¦‚æœå½“å‰ä½ç½®çš„å€¼ï¼Œå¤§äºtempï¼Œæ›´æ–°tempä¸º å½“å‰ä½ç½®çš„å€¼ï¼Œå¦åˆ™ temp ç´¯åŠ  å½“å‰ä½ç½®
2. ç”¨tempæ›´æ–° max

æ‹“å±•ï¼š

1. æ±‚æœ€å¤§å­æ•°ç»„çš„èŒƒå›´ï¼š
   1. åœ¨å½“å‰æ–¹æ³•åŸºç¡€ä¸Šæ–°å¢å˜é‡ leftå’Œ right
   2. å¦‚æœå½“å‰ä½ç½®çš„å€¼ï¼Œå¤§äºtempï¼Œæ›´æ–°left
   3. å¦‚æœtempå¤§äº maxï¼Œæ›´æ–°right

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = nums[0];
    int r = 1;
    while (r < nums.length) {
        if (nums[r] > nums[r] + temp) {
            temp = nums[r];
        } else {
            temp += nums[r];
        }
        ans = Math.max(ans, temp);
        r++;
    }
    return ans;
}
```

æ–¹æ³•ä¸€ä¼˜åŒ–

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = 0;
    for (int num : nums) {
        temp = Math.max(num, num + temp);
        ans = Math.max(ans, temp);
    }
    return ans;
}
```

#### æ–¹æ³•äºŒ åˆ†æ²»



### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0 || s.length() == 1) {
            return s.length();
        }
        int ans = 0, temp = 0;
        int l = 0, r = 0;
        Set<Character> set = new HashSet<>();
        while (r < s.length()) {
            if (!set.contains(s.charAt(r))) {
                set.add(s.charAt(r));
                temp++;
                r++;
                ans = Math.max(ans, temp);
            } else {
                set.remove(s.charAt(l));
                temp--;
                l++;
            }
        }
        return ans;
    }
}
```

#### æ–¹æ³•äºŒï¼šæ•°ç»„

```java
public int lengthOfLongestSubstring(String s) {
    if (s.length() == 0 || s.length() == 1) {
        return s.length();
    }
    int ans = 0, temp = 0;
    int l = 0, r = 0;
    int[] set = new int[150];
    while (r < s.length()) {
        if (set[s.charAt(r)] == 0) {
            set[s.charAt(r)] = 1;
            temp++;
            r++;
            ans = Math.max(ans, temp);
        } else {
            set[s.charAt(l)] = 0;
            temp--;
            l++;
        }
    }
    return ans;
}
```

#### æ–¹æ³•ä¸‰ï¼šå¦‚æœåªåŒ…å«å­—æ¯çš„æƒ…å†µï¼Œå¯ä»¥ç”¨ä½è¿ç®—æ¥åŠ é€Ÿ

### [395. è‡³å°‘æœ‰ K ä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

#### â­â­æ»‘åŠ¨çª—å£

**å½“ç¡®å®šäº†çª—å£å†…æ‰€åŒ…å«çš„å­—ç¬¦æ•°é‡æ—¶ï¼ŒåŒºé—´é‡æ–°å…·æœ‰äº†äºŒæ®µæ€§è´¨**ï¼Œè¿™æ˜¯æœ¬é¢˜çš„æ»‘åŠ¨çª—å£è§£æ³•å’Œè¿„ä»Šä¸ºæ­¢åšçš„æ»‘åŠ¨çª—å£é¢˜ç›®çš„æœ€å¤§ä¸åŒï¼Œæœ¬é¢˜éœ€è¦æ‰‹åŠ¨å¢åŠ é™åˆ¶ï¼Œå³é™åˆ¶çª—å£å†…å­—ç¬¦ç§ç±»ã€‚

##### ç‚¹è¯„

è¿™é“é¢˜çš„çªç ´å£åˆ†æå…¶å®å’Œ 1178. çŒœå­—è°œ ç±»ä¼¼ã€‚

è§£å†³æ€è·¯ï¼šå½“æˆ‘ä»¬é‡‡ç”¨å¸¸è§„çš„åˆ†ææ€è·¯å‘ç°æ— æ³•è¿›è¡Œæ—¶ï¼Œ**è¦å»å…³æ³¨ä¸€ä¸‹æ•°æ®èŒƒå›´ä¸­ã€Œæ•°å€¼å°ã€çš„å€¼ã€‚å› ä¸ºæ•°å€¼å°å…¶å®æ˜¯ä»£è¡¨äº†ã€Œå¯æšä¸¾ã€ï¼Œå¾€å¾€æ˜¯è§£é¢˜æˆ–è€…é™ä½å¤æ‚åº¦çš„ä¸€ä¸ªé‡è¦ï¼ˆç”šè‡³æ˜¯å”¯ä¸€ï¼‰çš„çªç ´å£ã€‚**

```java
// æ–¹æ³•ä¸€ï¼šæ»‘åŠ¨çª—å£
public int longestSubstring(String s, int k) {
    int ans = 0;
    int[] count = new int[26];
    int len = s.length();
    for (int kind = 1; kind <= 26; kind++) {// å…è®¸å‡ºç°çš„å­—ç¬¦ç§ç±»
        Arrays.fill(count, 0);
        for (int i = 0, j = 0, total = 0, vaild = 0; i < len; i++) {
            int idx = s.charAt(i) - 'a';
            count[idx]++;
            if (count[idx] == 1) {// å‡ºç°çš„å­—ç¬¦ç§ç±»åŠ ä¸€
                total++;
            }
            if (count[idx] == k) {// ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ç§ç±»åŠ ä¸€
                vaild++;
            }
            while (total > kind) {// å½“å‡ºç°çš„å­—ç¬¦ç§ç±»è¶…è¿‡é™å®šçš„å­—ç¬¦ç§ç±»ï¼Œå·¦æŒ‡é’ˆå³ç§»
                int n = s.charAt(j) - 'a';
                count[n]--;
                if (count[n] == 0) {// å‡ºç°çš„å­—ç¬¦ç§ç±»å‡å°‘ä¸€
                    total--;
                }
                if (count[n] == k - 1) {// ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ç§ç±»å‡å°‘ä¸€
                    vaild--;
                }
                j++;
            }
            if (total == vaild) {
                ans = Math.max(ans, i - j + 1);
            }
        }
    }
    return ans;
}
```

#### â­â­åˆ†æ²»

å¯¹äºå‡ºç°ä»»ä½•ä¸€ä¸ªå‡ºç°æ¬¡æ•° å¤§äº 0 å°äº k çš„å­—ç¬¦ chï¼ŒåŒ…å«è¯¥å­—ç¬¦çš„ä»»æ„å­ä¸²éƒ½ä¸å¯èƒ½ç¬¦åˆè¦æ±‚ï¼Œæ‰€ä»¥ ä»¥ å­—ç¬¦ ch åˆ†éš”å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆç¬¦åˆè¦æ±‚çš„æœ€é•¿å­ä¸²ä¸€å®šå‡ºç°åœ¨æŸä¸ªè¢«åˆ†å‰²çš„æ®µå†…ï¼Œå› æ­¤å¯ä»¥ç”¨åˆ†æ²»çš„æ–¹å¼æ±‚è§£æ­¤é¢˜ã€‚

```java
public int longestSubstring(String s, int k) {
    return longestSubstring(s, k, 0, s.length() - 1);
}

private int longestSubstring(String s, int k, int l, int r) {
    // ç»Ÿè®¡å½“å‰èŒƒå›´å†…å„å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
    int[] count = new int[26];
    for (int i = l; i <= r; i++) {
        count[s.charAt(i) - 'a']++;
    }
    // æŸ¥æ‰¾ å‡ºç°æ¬¡æ•° å¤§äº 0 å°äº k çš„åˆ†å‰²å­—ç¬¦
    int split = 0;
    for (int i = l; i <= r; i++) {
        if (count[s.charAt(i) - 'a'] < k) {
            split = s.charAt(i);
            break;
        }
    }
    // æ‰¾ä¸åˆ°åˆ†å‰²å­—ç¬¦ï¼Œåˆ™è¯¥å­ä¸²ç¬¦åˆè¦æ±‚ï¼Œç›´æ¥è¿”å›
    if (split == 0) {
        return r - l + 1;
    }
    int ans = 0;
    int left = l;
    while (left <= r) {
        while (left <= r && s.charAt(left) == split) {
            left++;
        }
        if (left > r) {
            break;
        }
        int start = left;
        while (left <= r && s.charAt(left) != split) {
            left++;
        }
        int len = longestSubstring(s, k, start, left - 1);
        ans = Math.max(ans, len);
    }
    return ans;
}
```

### [460. LFU ç¼“å­˜](https://leetcode-cn.com/problems/lfu-cache/)

**åˆ†æéœ€è¦ç”¨åˆ°çš„æ•°æ®ç»“æ„ï¼š**

- $O(1)$ æ—¶é—´å¤æ‚åº¦çš„ å­˜å– æ•°æ®ç»“æ„ï¼šhashMap

- $O(log^n)$ æ—¶é—´å¤æ‚åº¦çš„ æ’åºæ•°æ®ç»“æ„ï¼šå †ï¼ˆJava ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †ï¼‰
  - å †çš„å¢åˆ æ“ä½œæ˜¯ $O(log^n)$ï¼Œå¢åˆ æ“ä½œä¼šè‡ªåŠ¨è°ƒæ•´å †ï¼Œè¿™ä¸ªè°ƒæ•´æ—¶é—´æ˜¯$O(log^n)$
  - å †æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlog^n)$ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ $O(1)$
  - å»ºå †çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$
- å¢åˆ  éƒ½æ˜¯$O(1)$ æ—¶é—´å¤æ‚åº¦çš„ **æœ‰åº**çš„æ•°æ®ç»“æ„ï¼šé“¾è¡¨



#### â­æ—¶é—´å¤æ‚åº¦ $O(n)$ è§£æ³•

- ä½¿ç”¨å°æ ¹å †æ’åºï¼ˆJava ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †ï¼‰ï¼Œæ‰¾åˆ°è®¿é—®æ¬¡æ•°æœ€å°‘çš„é¡¹
  - è®¿é—®æ¬¡æ•° time **æœ€å°ä¸”æœ€ä¹…æœªè®¿é—®**çš„ é¡¹ ä¸Šæµ®åˆ°å †é¡¶
  - å¯¹äºè®¿é—®æ¬¡æ•°ç›¸åŒçš„é¡¹ï¼Œæ¯”è¾ƒè®¿é—®å…ˆåï¼Œè¿™é‡Œç”¨ å…¨å±€è‡ªå¢çš„ idx è¡¨ç¤ºè®¿é—®çš„å…ˆå

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * O(1)  get
 * O(logn) put
 */
class LFUCache {
    class Node implements Comparable<Node> {
        int key;
        int value;
        int time;// è®¿é—®æ¬¡æ•°
        int idx;// è®¿é—®æ—¶é—´

        public Node(int key, int value, int idx) {
            this.key = key;
            this.value = value;
            this.idx = idx;
            this.time = 1;
        }

        @Override
        public int compareTo(Node o) {
            int diff = this.time - o.time;
            return diff != 0 ? diff : this.idx - o.idx;
        }
    }

    Map<Integer, Node> map;// è´Ÿè´£å­˜å–
    PriorityQueue<Node> queue;// è´Ÿè´£æ’åº
    int capacity;
    int idx;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        idx = 0;
        queue = new PriorityQueue<>();
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.time++;
            node.idx = idx++;
            queue.remove(node);
            queue.offer(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            node.time++;
            node.idx++;
            queue.remove(node);
            queue.offer(node);
            return;
        } else {
            if (capacity == 0) {
                return;
            }
            if (map.size() == capacity) {
                Node poll = queue.poll();
                map.remove(poll.key);
            }
            Node node = new Node(key, value, idx++);
            map.put(key, node);
            queue.offer(node);
        }
    }
}
```

#### â­æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆä¸€ï¼‰ - åŒ hashMap + LinkedHashSet

#### â­æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆäºŒï¼‰ -  åŒ hashMap + è‡ªå®šä¹‰åŒå‘é“¾è¡¨

**åŒ hashMap + åŒå‘é“¾è¡¨ï¼š**

- `Map<Integer, Node> cacheMap`å­˜å‚¨ç¼“å­˜çš„å†…å®¹
- `Map<Integer, DoubleLinkedList> freqMap` æŒ‰è®¿é—®é¢‘æ¬¡å­˜å‚¨å¯¹åº”Node çš„åŒå‘é“¾è¡¨
- `minFreq` è®°å½•æœ€å°‘è®¿é—®æ¬¡æ•°

**åˆ†æï¼š**

- **cacheMap** ç¡®ä¿äº†å¯ä»¥åœ¨ O(1) å†… æŸ¥è¯¢ï¼ˆget)
- **frepMap** ä¸ minFreq æ­é…ä½¿ç”¨ï¼Œå¯ä»¥åœ¨ O(1) å†… è·å– æœ€ä½è®¿é—®æ¬¡æ•°é¡¹æ‰€åœ¨çš„é“¾è¡¨

- **åŒå‘é“¾è¡¨** ç¡®ä¿äº† ç›¸åŒè®¿é—®æ¬¡æ•°ä¸‹é¡¹çš„æœ‰åºæ€§ï¼Œå¯ä»¥åœ¨ O(1) å†… å¤´æ’å…¥ã€å°¾åˆ é™¤ ç»“ç‚¹ 
  - æ¯å½“æ–°å¢é¡¹æ—¶ï¼Œæ–°å¢é¡¹å¤´æ’å…¥ï¼Œ**æœ€ä¹…æœªä½¿ç”¨** çš„é¡¹ æ°¸è¿œåœ¨ é“¾è¡¨å°¾éƒ¨

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

/**
 * O(1)è§£æ³•
 */
class LFUCache {
    int capacity;// å®¹é‡
    int minFreq;// æœ€å°‘è®¿é—®æ¬¡æ•°
    Map<Integer, Node> cacheMap;// å­˜å‚¨ç¼“å­˜å†…å®¹
    Map<Integer, DoubleLinkedList> freqMap;// æŒ‰é¢‘ç‡å­˜å‚¨å¯¹åº”çš„åŒå‘é“¾è¡¨


    public LFUCache(int capacity) {
        this.capacity = capacity;
        cacheMap = new HashMap<>();
        freqMap = new HashMap<>();
    }

    public int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            refresh(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            node.value = value;
            refresh(node);
        } else {
            if (cacheMap.size() == capacity) {// ç§»é™¤ æœ€å°‘è®¿é—®æ¬¡æ•°ä¸”æœ€ä¹…æœªä½¿ç”¨çš„é¡¹
                DoubleLinkedList list = freqMap.get(minFreq);
                Node del = list.removeLast();
                if (list.isEmpty()) {
                    freqMap.remove(minFreq);
                }
                cacheMap.remove(del.key);
            }
            // æ–°å¢ é¡¹
            Node node = new Node(key, value);
            cacheMap.put(key, node);
            if (!freqMap.containsKey(1)) {
                freqMap.put(1, new DoubleLinkedList());
            }
            DoubleLinkedList list = freqMap.get(1);
            list.add(node);
            minFreq = 1;
        }
    }

    // æ›´æ–°ä½¿ç”¨æ¬¡æ•°
    private void refresh(Node node) {
        DoubleLinkedList list = freqMap.get(node.freq);
        list.remove(node);
        if (list.isEmpty()) {// ç§»é™¤ç©ºé“¾è¡¨
            freqMap.remove(node.freq);
            if (minFreq == node.freq) {// æ›´æ–°æœ€å°‘è®¿é—®æ¬¡æ•°
                minFreq++;
            }
        }
        node.freq++;
        if (!freqMap.containsKey(node.freq)) {
            freqMap.put(node.freq, new DoubleLinkedList());
        }
        freqMap.get(node.freq).add(node);// æ’å…¥æ–°ç»“ç‚¹
    }

}

// è‡ªå®šä¹‰åŒé“¾è¡¨
class DoubleLinkedList {
    Node head;
    Node tail;

    public DoubleLinkedList() {
        this.head = new Node(-1, -1);
        this.tail = new Node(-1, -1);
        head.next = tail;
        tail.pre = head;
    }

    // å¤´æ’å…¥
    public void add(Node node) {
        node.pre = head;
        node.next = head.next;
        head.next = node;
        node.next.pre = node;
    }

    public void remove(Node node) {
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }

    // å°¾åˆ é™¤
    public Node removeLast() {
        Node del = tail.pre;
        remove(del);
        return del;
    }

    public boolean isEmpty() {
        return head.next == tail;
    }
}

/**
 * è‡ªå®šä¹‰ç»“ç‚¹ç±»
 */
class Node {
    int key, value, freq;
    Node pre, next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
        this.freq = 1;
    }
}
```

#### â­æœ€ä¼˜è§£ - æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆä¸‰ï¼‰ -  

[ç”œå§¨é¢˜è§£](https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/#o1-%E8%A7%A3%E6%B3%95-%E2%80%94%E2%80%94-%E5%AD%98%E5%82%A8%E9%A2%91%E6%AC%A1%E7%9A%84hashmap%E6%94%B9%E4%B8%BA%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%80%E4%BC%98%E5%AE%9E%E7%8E%B0-13ms-%E5%8F%8C100percent%EF%BC%89)



### [153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

- æ—¶é—´å¤æ‚åº¦ï¼š$O(log^n)$ï¼Œåœ¨äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€æ­¥ä¼šå¿½ç•¥ä¸€åŠçš„åŒºé—´

- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

**åˆ†æï¼š**

1. æœ€å°å€¼è¦ä¹ˆåœ¨å·¦è¾¹ï¼Œè¦ä¹ˆåœ¨å³è¾¹
2. å¦‚æœ æœ€å°å€¼ä¸åœ¨å³è¾¹ï¼Œé‚£ä¹ˆ `nums[mid] ä¸€å®š å¤§äº nums[r]` ,å¦åˆ™ï¼Œæœ€å°å€¼åœ¨å³è¾¹

```java
// äºŒåˆ†
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return nums[l];
}
```

### [154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

**åˆ†æï¼š**

- å½“ `nums[mid] > nums[right]`æ—¶ï¼Œmid  ä¸€å®šåœ¨ å³è¾¹

- å½“ `nums[mid] < nums[right]` æ—¶ï¼Œmid  ä¸€å®šåœ¨å·¦è¾¹

- å½“ `nums[mid] = nums[right]` æ—¶ï¼Œéš¾ä»¥åˆ¤æ–­æœ€å°å€¼åŒºé—´ï¼Œ è§£å†³æ–¹å¼ï¼š`right--;`

  è¯æ˜ï¼š

  1. æ­¤æ“ä½œä¿è¯äº†æ•°ç»„ä¸ä¼šè¶Šç•Œï¼Œå› ä¸ºè¿­ä»£æ¡ä»¶ï¼š`l < r`
  2. æ­¤æ“ä½œä¿è¯äº†ä¸ä¼šä¸¢å¤±æœ€å°å€¼
     - å‡è®¾ nums[right]  æ˜¯æœ€å°å€¼ï¼Œé‚£å°±ä¸å¯èƒ½æœ‰ `nums[mid] = nums[right]`

æ—¶é—´å¤æ‚åº¦ $O(logN)$ï¼Œåœ¨ç‰¹ä¾‹æƒ…å†µä¸‹ä¼šé€€åŒ–åˆ° $O(N)$ï¼ˆä¾‹å¦‚ [1, 1, 1, 1]ï¼‰

```java
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else if (nums[mid] > nums[r]) {
            l = mid + 1;
        } else {
            r--;
        }
    }
    return nums[l];
}
```

### [852. å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼•](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

#### éå†

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0;
    while (arr[l] < arr[l + 1]) {
        l++;
    }
    return l;
}
```

#### â­äºŒåˆ†

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0, r = arr.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (arr[mid] < arr[mid + 1]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}
```

### [88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)

**å½’å¹¶æ’åº**

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int start1 = 0, start2 = 0, end1 = m - 1, end2 = n - 1;
    int[] result = new int[m + n];
    int idx = 0;
    while (start1 <= end1 && start2 <= end2) {
        if (nums1[start1] <= nums2[start2]) {
            result[idx++] = nums1[start1++];
        } else {
            result[idx++] = nums2[start2++];
        }
    }
    while (start1 <= end1) {
        result[idx++] = nums1[start1++];
    }
    while (start2 <= end2) {
        result[idx++] = nums2[start2++];
    }
    for (int i = 0; i < result.length; i++) {
        nums1[i] = result[i];
    }
}
```

### [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

å¦‚æœå¯¹æ—¶é—´å¤æ‚åº¦çš„è¦æ±‚æœ‰ $\log$ï¼Œé€šå¸¸éƒ½éœ€è¦ç”¨åˆ°äºŒåˆ†æŸ¥æ‰¾ï¼Œè¿™é“é¢˜ä¹Ÿå¯ä»¥é€šè¿‡äºŒåˆ†æŸ¥æ‰¾å®ç°

- å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°åªæœ‰1ä¸ªï¼Œå°†å®ƒè¿”å›
- å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°æœ‰ä¸¤ä¸ªï¼Œè¿”å›è¿™ä¸¤ä¸ªæ•°çš„å¹³å‡æ•°

#### æ–¹æ³•ä¸€ æš´åŠ›æ±‚è§£

å…ˆåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œç„¶åæ’åºæ‰¾åˆ°ä¸­ä½æ•°

#### æ–¹æ³•äºŒ å½’å¹¶æ’åº

å½’å¹¶æ’åºï¼Œåˆå¹¶æœ‰åºæ•°ç»„

æ—¶é—´å¤æ‚åº¦ï¼š$O(m+n)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(m+n)$

#### æ–¹æ³•ä¸‰  äºŒåˆ†æŸ¥æ‰¾

**æ•´ä½“æ€è·¯**ï¼šåªéœ€è¦ç»™å‡ºä¿©ä¸ªæœ‰åºæ•°ç»„çš„ä¸€ä¸ªæ°å½“çš„ **åˆ†å‰²çº¿**ï¼Œä¸­ä½æ•°çš„å€¼å°±ç”± ä½äºè¿™ä¸ª **åˆ†å‰²çº¿** ä¸¤ä¾§çš„æ•°å†³å®š

##### åœ¨åªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™

ä¸­ä½æ•°ï¼šåœ¨åªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™ï¼Œä¸­ä½æ•°æŠŠæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†

- å½“æ•°ç»„é•¿åº¦ä¸ºå¶æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°æœ‰ä¸¤ä¸ªï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯å·¦è¾¹æ•°ç»„çš„æœ€å¤§å€¼ï¼Œå¦ä¸€ä¸ªæ˜¯å³è¾¹æ•°ç»„çš„æœ€å°å€¼

![image-20211222212403358](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127758.png)

- å½“æ•°ç»„é•¿åº¦ä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°åªæœ‰1ä¸ªï¼Œä¸å¦¨æŠŠä¸­ä½æ•°åˆ†åˆ°å·¦è¾¹æ•°ç»„

![image-20211222212431730](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127219.png)

##### åœ¨æœ‰ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™

ä¸­ä½æ•°ï¼šåœ¨æœ‰ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™ï¼Œä»ç„¶å¯ä»¥æŠŠæœ‰åºæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†

![image-20211222213559266](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222136540.png)

ä½¿ç”¨ä¸€æ¡åˆ†å‰²çº¿æŠŠæ•°ç»„åˆ†åˆ«åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†ï¼š

1. çº¢çº¿å·¦è¾¹å’Œå³è¾¹çš„å…ƒç´ ä¸ªæ•°ç›¸ç­‰ï¼ˆä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°ï¼‰ï¼Œæˆ–å·¦è¾¹å…ƒç´ ä¸ªæ•°æ¯”å³è¾¹å…ƒç´ ä¸ªæ•°å¤šä¸€ä¸ªï¼ˆä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°ï¼‰
2. **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼**ï¼ˆ**å…³é”®**ï¼Œæ»¡è¶³äº†è¿™ç‚¹ï¼Œä½¿å¾—ä¸­ä½æ•°**åªä¸**åˆ†å‰²çº¿å·¦å³ä¸¤ä¾§çš„å…ƒç´ æœ‰å…³ï¼‰

å¦‚æœæ‰¾åˆ°äº†ç¬¦åˆè¿™ä¸¤ç‚¹è¦æ±‚çš„åˆ†å‰²çº¿ï¼Œé‚£ä¹ˆå°±å¯ä»¥å’Œåªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æƒ…å†µç»Ÿä¸€èµ·æ¥ï¼š

- é‚£ä¹ˆä¸­ä½æ•°å°±ä¸€å®šåªä¸çº¢çº¿ä¸¤ä¾§çš„å…ƒç´ æœ‰å…³ï¼Œç¡®å®šè¿™æ¡çº¢çº¿çš„ä½ç½®ï¼Œéœ€è¦ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚

**ï¼ˆä¸€ï¼‰å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™**

â€‹	å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œ

- $Size_{left}  = Size_{right} + 1$

- åœ¨æ»¡è¶³ **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼** çš„å‰æä¸‹ï¼Œ
  - åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ çš„æœ€å¤§å€¼å°±æ˜¯æ•°ç»„çš„ä¸­ä½æ•°
  - ç”±äºä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯æœ‰åºæ•°ç»„ï¼Œåˆ†å‰²çº¿å·¦è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå¤§è€…ï¼Œå°±æ˜¯ä¸­ä½æ•°

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222148124.png" alt="image-20211222214827410" style="zoom:50%;" />

**ï¼ˆäºŒï¼‰å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™**

å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™

- $Size_{left}  = Size_{right}$
- åœ¨æ»¡è¶³ **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼** çš„å‰æä¸‹ï¼Œ
  - åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ çš„æœ€å¤§å€¼å°±æ˜¯ å…¶ä¸­ä¸€ä¸ªä¸­ä½æ•°
  - åˆ†å‰²çº¿å³è¾¹å…ƒç´ çš„æœ€å°å€¼å°±æ˜¯ å…¶ä¸­å¦ä¸€ä¸ªä¸­ä½æ•°
  - ç”±äºä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯æœ‰åºæ•°ç»„ï¼Œ
    - åˆ†å‰²çº¿å·¦è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå¤§è€…ï¼Œå°±æ˜¯å…¶ä¸­ä¸€ä¸ªä¸­ä½æ•°
    - åˆ†å‰²çº¿å³è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå°è€…ï¼Œå°±æ˜¯å…¶ä¸­å¦ä¸€ä¸ªä¸­ä½æ•°

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222155593.png" alt="image-20211222215458018" style="zoom:50%;" />

##### å…¶ä»–ç»†èŠ‚é—®é¢˜

1. æ²¡æœ‰å¿…è¦åˆ†åˆ«å»ç¡®å®šåˆ†å‰²çº¿åœ¨ä¸¤ä¸ªæ•°ç»„ä¸Šçš„ä½ç½®
   - åˆ†å‰²çº¿å·¦è¾¹ï¼Œæˆ–åˆ™å³è¾¹çš„å…ƒç´ ä¸ªæ•°æ˜¯å¯ä»¥è®¡ç®—å‡ºæ¥çš„ï¼Œæ˜¯ä¸€ä¸ªç¡®å®šçš„æ•°

##### åˆ†å‰²çº¿è®¡ç®—

**æ¡ä»¶ä¸€ï¼šåˆå¹¶å¥‡æ•°å¶æ•°æƒ…å†µä¸‹ï¼Œåˆ†å‰²çº¿ä½ç½®çš„ç¡®å®šå…¬å¼**

![image-20211222220516370](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222205185.png)

**æ¡ä»¶äºŒï¼š æ»¡è¶³äº¤å‰å°äºç­‰äºå…³ç³»** 

- ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ <= ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼
- ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ <= ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼



##### ä¸æ»¡è¶³äº¤å‰å°äºç­‰äºå…³ç³»çš„åˆ†å‰²çº¿ä½ç½®è°ƒæ•´

**æƒ…å†µä¸€ï¼š**ç¬¬äºŒä¸ªæ•°ç»„åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ å¤§äº ç¬¬ä¸€ä¸ªæ•°ç»„åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼

- è°ƒæ•´æ–¹æ¡ˆï¼šå°†ä¸­ä½æ•°åˆ†å‰²çº¿åœ¨æ•°ç»„ 1 çš„ä½ç½® å³ç§»

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112231657314.png" alt="image-20211222221932163" style="zoom:50%;" />

**æƒ…å†µäºŒï¼š**ç¬¬ä¸€ä¸ªæ•°ç»„åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ å¤§äº ç¬¬äºŒä¸ªæ•°ç»„åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼

- è°ƒæ•´æ–¹æ¡ˆï¼šå°†ä¸­ä½æ•°åˆ†å‰²çº¿åœ¨æ•°ç»„ 1 çš„ä½ç½® å·¦ç§»

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222216455.png" alt="image-20211222221632023" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222215431.png" alt="image-20211222221557476" style="zoom:50%;" />

> **äºŒåˆ†æŸ¥æ‰¾ç®—æ³•**å°±æ˜¯åœ¨è¿™æ ·çš„å°è¯•æ‰¾åˆ°æ°å½“çš„åˆ†å‰²çº¿çš„è¿‡ç¨‹å½“ä¸­ï¼Œä¸æ–­åœ°ç¼©å°æœç´¢åŒºé—´çš„èŒƒå›´ï¼Œç›´åˆ°æœ€ç»ˆæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„åˆ†å‰²çº¿çš„ä½ç½®



ç”±äºéœ€è¦æ¯”è¾ƒåˆ†å‰²çº¿ä¸¤ä¾§å…ƒç´ çš„å¤§å°å…³ç³»ï¼Œå¯èƒ½å‡ºç°ä»¥ä¸‹ä¸¤ç±»æç«¯æƒ…å†µï¼š

##### æç«¯æƒ…å†µ

**ç¬¬ä¸€ç±»æƒ…å†µï¼š**ä¸¤æ•°ç»„é•¿åº¦ä¸ä¸€è‡´æ—¶

- æƒ…å†µä¸€ï¼šè¾ƒçŸ­çš„æ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ 
- æƒ…å†µäºŒï¼šè¾ƒçŸ­çš„æ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ 

ä¸ºäº†ä¿è¯åˆ†å‰²çº¿åœ¨ è¾ƒé•¿çš„æ•°ç»„ä¸­ åˆ†å‰²çº¿ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œå› æ­¤åº”è¯¥åœ¨è¾ƒçŸ­çš„æ•°ç»„ä¸Šç¡®å®š åˆ†å‰²çº¿ çš„ä½ç½®ï¼Œ**è¿™æ ·å°±ä¸ä¼š åœ¨è®¿é—®æ•°ç»„æ—¶ å‡ºç° æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µ**

![image-20211222222953628](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222229922.png)

**ç¬¬äºŒç±»æƒ…å†µï¼š**ä¸¤æ•°ç»„é•¿åº¦ä¸€æ ·æ—¶

- æƒ…å†µä¸€ï¼šç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ 
- æƒ…å†µäºŒï¼šç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ 

![image-20211222223152519](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222231600.png)

#### ç®—æ³•æè¿°

1. äº¤æ¢è¾ƒçŸ­çš„æ•°ç»„ä¸º ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œè¾ƒé•¿çš„æ•°ç»„ä¸ºç¬¬äºŒä¸ªæ•°ç»„

   - è¿™æ˜¯ ä¸ºäº†ä½¿å¾—åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„çš„ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œä»¥ä¿è¯ä¸ä¼šå‡ºç°è®¿é—®æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µï¼Œä»¥æ–¹ä¾¿åç»­ç¼–ç 

2. ç”¨ å˜é‡ mã€n åˆ†åˆ«ä¿å­˜ æ•°ç»„ num1 å’Œ num2 çš„é•¿åº¦

3. ç»Ÿè®¡ åˆ†å‰²çº¿å·¦è¾¹åº”è¯¥æœ‰çš„å…ƒç´ ä¸ªæ•°ï¼š` int totalLeft = (m+n+1)/2;`

   - å¯èƒ½ä¼šå‘ç”Ÿæ•´å‹æº¢å‡ºï¼Œè§£å†³æ–¹æ³•ï¼š` int totalLeft = m + (n - m + 1)/2;`

4. åˆ†å‰²çº¿äºŒåˆ†æŸ¥æ‰¾è¿‡ç¨‹

   1. åˆ†å‰²çº¿å®šä¹‰

      - åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å³è¾¹çš„ç¬¬ 1 ä¸ªå…ƒç´ ä¸‹æ ‡ i = åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å·¦è¾¹çš„å…ƒç´ ä¸ªæ•°
      - åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„å³è¾¹çš„ç¬¬ 1 ä¸ªå…ƒç´ ä¸‹æ ‡ j = åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„å·¦è¾¹çš„å…ƒç´ ä¸ªæ•°
      - æ ¹æ®ä¹‹å‰çš„å®šä¹‰ï¼Œi+j æ»¡è¶³ å…³ç³»å¼ï¼š    $i+j = \frac{m+n+1}{2}$

      ![image-20211222224336317](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222243308.png)

   2. åˆ†å‰²çº¿é™åˆ¶æ¡ä»¶ï¼ˆäº¤å‰å°äºç­‰äºï¼‰

      -  `nums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]`

   3. åœ¨ nums1 çš„åŒºé—´ [0,m] é‡ŒæŸ¥æ‰¾æ°å½“çš„åˆ†å‰²çº¿

5. 3

**æ€»ç»“ï¼š**

- äºŒåˆ†æŸ¥æ‰¾æ³•æ€è·¯ï¼š
  - åªéœ€è¦ç»™å‡ºä¿©ä¸ªæœ‰åºæ•°ç»„çš„ä¸€ä¸ªæ°å½“çš„ **åˆ†å‰²çº¿**ï¼Œä¸­ä½æ•°çš„å€¼å°±ç”± ä½äºè¿™ä¸ª **åˆ†å‰²çº¿** ä¸¤ä¾§çš„æ•°å†³å®š

#### ç®—æ³•å®ç°

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    // äº¤æ¢è¾ƒçŸ­æ•°ç»„åˆ° nums1ï¼Œæ–¹ä¾¿åç»­ç¼–ç 
    if (nums1.length > nums2.length) {
        int[] temp = nums1;
        nums1 = nums2;
        nums2 = temp;
    }
    // è®°å½• æ•°ç»„é•¿åº¦
    int m = nums1.length;
    int n = nums2.length;
    // ç»Ÿè®¡åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ ä¸ªæ•°ï¼ˆè®©å·¦è¾¹å¤šä¸€ä¸ªå…ƒç´ )
    int sizeLeft = (m + n + 1) / 2;
    // åœ¨è¾ƒçŸ­çš„æ•°ç»„ä¸Šé‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾ å¯»æ‰¾åˆ†å‰²çº¿ä½ç½®
    // äºŒåˆ†æŸ¥æ‰¾åˆ†å‰²çº¿ä½ç½®,åˆ†å‰²çº¿éœ€è¦æ»¡è¶³çš„æ¡ä»¶ï¼ˆäº¤å‰å°äºç­‰äºçš„å…³ç³»ï¼‰ï¼šnums1[i-1] <= nums2[j]&&nums2[j-1] <=nums1[i]
    int left = 0, right = m;
    while (left < right) {
        // äºŒåˆ†è®¡ç®—ä¸­é—´ä½ç½®å…ƒç´ ä¸‹æ ‡
        int i = left + ((right - left + 1) >> 1);// åˆ†å‰²çº¿å³è¾¹å…ƒç´ çš„ä¸‹æ ‡ï¼Œåœ¨ç¬¬ä¸€ä¸ªæ•°ç»„
        int j = sizeLeft - i;// åˆ†å‰²çº¿å³è¾¹çš„å…ƒç´ ä¸‹æ ‡ï¼Œåœ¨ç¬¬äºŒä¸ªæ•°ç»„
        if (nums1[i - 1] > nums2[j]) {// åˆ†å‰²çº¿é å³ï¼Œåº”å·¦ç§»
            right = i - 1;
        } else {
            // åœ¨å·¦è¾¹ç•Œä¸º left = iæ—¶,è‹¥æ•°ç»„ä¸­åªæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œåˆ™ä¼šè¿›å…¥æ­»å¾ªç¯ï¼Œ
            // è§£å†³æ–¹å¼ï¼šå–ä¸­ä½æ•°æ—¶åŠ ä¸€ï¼Œä¸­ä½æ•°=left + ((right - left + 1) >> 1)
            // åŒæ—¶ä¹Ÿä¿è¯äº† i ä¸ä¼šå–åˆ° 0 ,ä¿è¯äº† i-1>=0,å³ nums1[i-1]ä¸ä¼šè¶Šç•Œ
            left = i;
        }
    }
    int i = left;
    int j = sizeLeft - i; 
    int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
    int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
    int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
    int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
    if (((m + n) & 1) == 1) {// m+n é•¿åº¦ä¸ºå¥‡æ•°
        return Math.max(nums1LeftMax, nums2LeftMax);
    } else {
        return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
    }
}
```

å¦ä¸€ç§ äºŒåˆ†æ¡ä»¶ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // äº¤æ¢è¾ƒå°çš„æ•°ç»„ä¸ºnum1
        // è¿™æ˜¯ä¸ºäº†ä½¿å¾—åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„çš„ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œä»¥ä¿è¯ä¸ä¼šå‡ºç°è®¿é—®æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µï¼Œä»¥æ–¹ä¾¿åç»­ç¼–ç 
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        // ç”¨ å˜é‡ mã€n åˆ†åˆ«ä¿å­˜ æ•°ç»„ num1 å’Œ num2 çš„é•¿åº¦
        int m = nums1.length;
        int n = nums2.length;
        // ç»Ÿè®¡ åˆ†å‰²çº¿å·¦è¾¹åº”è¯¥æœ‰çš„å…ƒç´ ä¸ªæ•°
        int totalLeft = (m + n + 1) / 2;
        // åˆ†å‰²çº¿é™åˆ¶æ¡ä»¶(äº¤å‰å°äºç­‰äº)ï¼šnums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]
        // åœ¨ nums1 çš„åŒºé—´ [0,m] é‡ŒæŸ¥æ‰¾æ°å½“çš„åˆ†å‰²çº¿
        int left = 0, right = m;
        // äºŒåˆ†æŸ¥æ‰¾,ç¡®å®šåˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å³è¾¹çš„å…ƒç´ ä¸‹æ ‡
        while (left < right) {
//            int i = left + ((right - left + 1) >> 1);// åˆ†å‰²çº¿,+1ä¿è¯äº† iå¤§äºé›¶ï¼Œå³ i-1>=0,å³ä¿è¯äº†nums1æ•°ç»„ä¸‹æ ‡ä¸è¶Šç•Œ
            int i = left + ((right - left) >> 1);// åˆ†å‰²çº¿,+1ä¿è¯äº† iå¤§äºé›¶ï¼Œå³ i-1>=0,å³ä¿è¯äº†nums1æ•°ç»„ä¸‹æ ‡ä¸è¶Šç•Œ
            int j = totalLeft - i;
//            // ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„å…ƒç´ æ•°å€¼å¤§äºç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„å…ƒç´ æ•°å€¼ï¼Œè¯æ˜åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„ä¸Šçš„ä½ç½®å¤ªé å³ï¼Œåº”å·¦ç§»
//            // ä¹Ÿå¯ä»¥æ ¹æ®å¦ä¸€ä¸ªæ¡ä»¶å–å
//            if (nums1[i - 1] > nums2[j]) {
//                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [left,i-1]
//                right = i - 1;
//            } else {
//                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [i,right]
//                left = i;
//            }
            if (nums2[j - 1] > nums1[i]) {
                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [i+1,right]
                left = i + 1;// i+1,é‚£ä¹ˆå–ä¸­ä½æ•°æ—¶ä¸éœ€è¦å‘ä¸Šå–æ•´
            } else {
                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [left,i]
                right = i;
            }
        }
        int i = left;
        int j = totalLeft - i;
        // åˆ†å‰²çº¿å·¦å³ä¸¤ä¾§å…ƒç´ å€¼
        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
        if ((m + n) % 2 == 1) {// æ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
        }
    }
```

#### æ—¶é—´å¤æ‚åº¦

æ—¶é—´å¤æ‚åº¦ï¼š$O(log^{min(m,n)})$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

#### æ€»ç»“

äºŒåˆ†æŸ¥æ‰¾é€æ¸ç¼©å°ç›®æ ‡å…ƒç´ åŒºé—´

### [è¡¥å……é¢˜6. æ‰‹æ’•å †æ’åº](https://leetcode-cn.com/problems/sort-an-array)

```java
// å †æ’åº
public int[] heapSort(int[] nums) {
    buildMaxHeap(nums);// åˆå§‹åŒ–å¤§é¡¶å †
    // å †æ’åºï¼Œæ¯æ¬¡å¾ªç¯æŠŠå †é¡¶å…ƒç´ ä¸å †å°¾ç»“ç‚¹äº¤æ¢ï¼ŒåŒæ—¶å †é•¿åº¦-1
    for (int i = nums.length - 1; i >= 0; i--) {
        swap(nums, 0, i);// äº¤æ¢å †é¡¶ä¸å †å°¾å…ƒç´ 
        maxHeapFix(nums, 0, i);
    }
    return nums;
}

/**
 * æ„å»ºåˆå§‹å¤§é¡¶å †ï¼Œä»æœ€åä¸€ä¸ªéå¶å­ç»“ç‚¹å¼€å§‹ï¼Œå¶å­ç»“ç‚¹å¯è§†ä¸ºç¬¦åˆå †è¦æ±‚çš„ç»“ç‚¹
 *
 * @param nums
 */
private void buildMaxHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

/**
 * è°ƒæ•´å¤§é¡¶å †
 *
 * @param nums
 * @param idx      éœ€è¦è°ƒæ•´çš„å †å…ƒç´ ç»“ç‚¹
 * @param heapSize éœ€è¦è°ƒæ•´çš„å †çš„é•¿åº¦
 */
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx <= heapSize / 2 - 1) {// å½“ç›®æ ‡ç»“ç‚¹æ˜¯éå¶å­ç»“ç‚¹æ‰è¿›å…¥å¾ªç¯
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [141. ç¯å½¢é“¾è¡¨](https://leetcode-cn.com/problems/linked-list-cycle/)

#### æ–¹æ³•ä¸€:hashSet

ç”¨hashSetè®°å½•èµ°è¿‡çš„ç»“ç‚¹ï¼Œå¦‚æœå†æ¬¡ç»è¿‡ï¼Œåˆ™æœ‰ç¯

#### æ–¹æ³•äºŒï¼šæ ‡è®°æ³•

`-105 <= Node.val <= 105`ï¼Œæ ‡è®°å·²èµ°è¿‡çš„ç»“ç‚¹å€¼ä¸º Integer.MAX_VALUE,è‹¥é‡åˆ° Node.val = Integer.MAX_VALUEï¼Œåˆ™æœ‰ç¯

#### æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆæ³•

å¿«æ…¢æŒ‡é’ˆåŒæ—¶èµ°ï¼Œç›¸é‡ï¼Œåˆ™å­˜åœ¨ç¯

```java
// å¿«æ…¢æŒ‡é’ˆ
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

### [142. ç¯å½¢é“¾è¡¨ II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

#### å¿«æ…¢æŒ‡é’ˆ

**å½“ å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥**

å‡è®¾èµ·ç‚¹åˆ° ç¯å…¥å£è·ç¦»ä¸º mï¼Œç¯é•¿ä¸º nï¼Œç¬¬ä¸€æ¬¡ç›¸é‡æ—¶è·ç¦»ç¯å…¥å£è·ç¦»ä¸º k

ç»“è®ºï¼š

1. è®¾ä¸€ä¸ªæ…¢æŒ‡é’ˆï¼Œä¸€ä¸ªå¿«æŒ‡é’ˆï¼Œè‹¥æœ‰ç¯å¿«æ…¢æŒ‡é’ˆå¿…ä¼šç›¸é‡ã€‚
   - è¿™ä¸ªä¸éœ€å¤šè¨€ï¼Œç”±äºå¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆæ¯æ¬¡å¤šèµ°ä¸€æ­¥ï¼Œå­˜åœ¨ç¯çš„è¯ï¼Œå¿…å®šç›¸é‡ã€‚
2. ä¸¤æŒ‡é’ˆåœ¨ç¯ä¸­ç¬¬ä¸€æ¬¡ç›¸é‡çš„æ—¶å€™ï¼Œæ…¢æŒ‡é’ˆä¸€å®šåªèµ°äº†ä¸€æ¬¡ m+k ,è€Œä¸ä¼šå¤šèµ°ä¸€åœˆ
3. å°†å¿«æŒ‡é’ˆé‡æ–°ç§»åŠ¨åˆ°é“¾è¡¨å¼€å¤´ï¼Œå¹¶è®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½å‰è¿›ä¸€æ­¥ã€‚å½“å¿«æ…¢æŒ‡é’ˆç¬¬äºŒæ¬¡ç›¸é‡æ—¶ï¼Œç›¸é‡çš„èŠ‚ç‚¹å³ä¸ºç¯è·¯çš„å¼€å§‹ç‚¹ã€‚

è¯æ˜ï¼š

- å…³äºå¿«æ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡ï¼Œæ…¢æŒ‡é’ˆä¸€å®šåªèµ°äº† m+k ,è€Œä¸ä¼šå¤šèµ°ä¸€åœˆçš„è¯æ˜
  1. ç”±äºå¿«æŒ‡é’ˆå…ˆå…¥ç¯ï¼Œå½“æ…¢æŒ‡é’ˆå…¥ç¯æ—¶ï¼Œå¿«æŒ‡é’ˆä¸€å®šåœ¨ç¯ä¸­æŸä¸ªä½ç½®ï¼Œè®¾ï¼ˆé¡ºæ—¶é’ˆï¼‰è·ç¦»ç¯å…¥å£ èµ°è¿‡çš„è·ç¦»ä¸º p
  2. ä¸€å®šæœ‰ 0<= p <= n
  3. å› ä¸º å¿«æŒ‡é’ˆæ¯æ¬¡æ¯”æ…¢æŒ‡é’ˆå¤šèµ°ä¸€æ­¥ï¼Œä¹Ÿå°±æ˜¯è¯´ å¿«æŒ‡é’ˆåªéœ€èµ° n-p æ­¥å°±å¯ä»¥è¿½ä¸Š æ…¢æŒ‡é’ˆï¼Œè€Œæ…¢æŒ‡é’ˆè¿˜è¦èµ° n æ­¥æ‰èƒ½èµ°å®Œç¬¬ä¸€æ¬¡ç¯ï¼Œ**æ‰€ä»¥å¿…å®šä¼šåœ¨æ…¢æŒ‡é’ˆçš„ç¬¬ä¸€æ¬¡ç¯å†… å¿«æŒ‡é’ˆå°±è¿½ä¸Šæ…¢æŒ‡é’ˆï¼Œå³è¯¥ä¸¤ç‚¹ç›¸é‡**
- å…³äºä¸¤æŒ‡é’ˆç¬¬äºŒæ¬¡ç›¸é‡æ—¶ï¼Œç›¸é‡çš„èŠ‚ç‚¹å³ä¸ºç¯çš„å¼€å§‹ç‚¹çš„è¯æ˜
  1. å½“ä¸¤æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼Œslowèµ°è¿‡è·ç¦»ï¼šm+k, fastèµ°è¿‡è·ç¦»ï¼šm+k+An(Aä»£è¡¨åœˆæ•°ï¼ŒA>=1)
  2. ç”±äºfastçš„é€Ÿåº¦æ˜¯slowçš„ä¸¤å€ï¼Œæ‰€ä»¥æœ‰: $(m+k)*2 = m+k+An$ï¼Œå¾—åˆ°ï¼š$m+k = An$ï¼Œè®¾ $n-k = y$, é‚£ä¹ˆæœ‰ï¼š$m = (A-1)n + y$
  3. ä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶ï¼ŒæŠŠfastæŒ‡é’ˆç§»å›é“¾è¡¨èµ·ç‚¹ï¼Œé€Ÿåº¦å˜ä¸ºå’Œslowä¸€æ ·,é‚£ä¹ˆslowå’Œfastå†æ¬¡ç›¸é‡çš„ç»“ç‚¹å¿…ç„¶æ˜¯ç¯èµ·ç‚¹ï¼Œåªæ˜¯ A çš„ä¸åŒä¼šå½±å“ä»ç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹å‡ºå‘çš„slowç»“ç‚¹å¤šèµ°çš„ç¯åœˆæ•°

**å½“ å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸‰æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥**

- åŒæ ·æœ‰ç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼š $k = y/2$

- å°†å¿«æŒ‡é’ˆé‡æ–°ç§»åŠ¨åˆ°é“¾è¡¨å¼€å¤´ï¼Œå¹¶è®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½å‰è¿›ä¸€æ­¥ï¼Œç¬¬äºŒæ¬¡ç›¸é‡ï¼š$m = (A-1)n + y$



**ä»£ç å®ç°**

```java
// å¿«æ…¢æŒ‡é’ˆ
public ListNode detectCycle(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            break;
        }
    }
    if (fast == null || fast.next == null) {
        return null;
    }
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```

### [70. çˆ¬æ¥¼æ¢¯](https://leetcode-cn.com/problems/climbing-stairs/)

**æ–æ³¢é‚£å¥‘æ•°åˆ—**å¸¸è§æ–¹æ³•ï¼š 1.åŠ¨æ€è§„åˆ’ã€ 2.é€’æ¨ï¼ˆåŠ¨æ€è§„åˆ’ç©ºé—´ä¼˜åŒ–ï¼‰ã€ 3.çŸ©é˜µå¿«é€Ÿå¹‚ã€ 4.é€šé¡¹å…¬å¼

#### é€’å½’

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    int count = 0;
    count += climbStairs(n - 1);
    count += climbStairs(n - 2);
    return count;
}
```

#### DP

$f(x) = f(x - 1) + f(x - 2)$

```java
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int m = 2; m <= n; m++) {
        dp[m] = dp[m - 1] + dp[m - 2];
    }
    return dp[n];
}
```

```java
public int climbStairs(int n) {
    int a = 1, b = 1, temp = 0;
    for (int m = 2; m <= n; m++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
```

#### æ‹“å±•ï¼šä¸èƒ½çˆ¬åˆ°7åŠ7çš„å€æ•°

```java
if (m % 7 == 0) {
    continue;
}
```

### [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

#### æ–¹æ³•ä¸€ï¼šå †æ’ å¤§é¡¶å †

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(max(n,k*log^n))$

```java
// å¤§é¡¶å †
public int findKthLargest(int[] nums, int k) {
    buildHeap(nums);
    int heapSize = nums.length;
    for (int i = 1; i < k; i++) {
        nums[0] = Integer.MIN_VALUE;
        maxHeapFix(nums, 0, heapSize);
    }
    return nums[0];
}

// åˆå§‹åŒ–å¤§é¡¶å †
private void buildHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

// è°ƒæ•´å¤§é¡¶å †
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx < heapSize / 2) {
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### æ–¹æ³•äºŒï¼šå †æ’ å°é¡¶å †

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n*log^k)$

#### æ–¹æ³•ä¸‰ï¼šå¿«æ’

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n*log^n)$

#### æ–¹æ³•å››ï¼šå¿«æ’ partition

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public int findKthLargest(int[] nums, int k) {
    return findKthLargest(nums, nums.length-k, 0, nums.length - 1);
}

// åœ¨ nums[L...R] èŒƒå›´ï¼Œæ‰¾æ’åºå ä½äº indexä½ç½®çš„æ•°
public int findKthLargest(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = nums[L + (int) (Math.random() * (R - L + 1))];
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return findKthLargest(nums, k, L, range[0] - 1);
    } else {
        return findKthLargest(nums, k, range[1] + 1, R);
    }
}

// è¿”å› ç­‰äºåŒºåŸŸçš„å·¦å³è¾¹ç•Œ
private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;// å°äºåŒºåŸŸçš„å³è¾¹ç•Œ
    int more = R + 1;// å¤§äºåŒºåŸŸçš„å·¦è¾¹ç•Œ
    int idx = L;// å½“å‰æ•°
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, idx, --more);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### æ–¹æ³•äº”ï¼šBFPRT

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$

```java
// nums[L...R] è¿”å›åœ¨æœ‰åºæƒ…å†µä¸‹çš„ä½äºkä½ç½®çš„æ•°
public int bfprt(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = medianOfMedians(nums, L, R);// è·å¾— nums[L...R] åŒºé—´å†…ä¸­ä½æ•°çš„ä¸­ä½æ•°
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return bfprt(nums, k, L, range[0] - 1);
    } else {
        return bfprt(nums, k, range[1] + 1, R);
    }
}

// nums[L...R] æ¯5ä¸ªæ•°ä¸€ç»„
// æ¯ç»„æ•° ç»„å†…æ’åº
// ç”¨æ¯ç»„çš„ä¸­ä½æ•°ç»„æˆä¸­ä½æ•°æ•°ç»„ M
// è¿”å›ä¸­ä½æ•°æ•°ç»„çš„ä¸­ä½æ•° m
private int medianOfMedians(int[] nums, int L, int R) {
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] M = new int[size / 5 + offset];// ä¸­ä½æ•°æ•°ç»„
    for (int team = 0; team < M.length; team++) {
        int teamFirst = L + team * 5;// æ¯ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        M[team] = getMedian(nums, teamFirst, Math.min(R, teamFirst + 4));
    }
    return bfprt(M, M.length / 2, 0, M.length - 1);
}

private int getMedian(int[] nums, int teamFirst, int teamLast) {
    insertionSort(nums, teamFirst, teamLast);
    return nums[(teamLast + teamFirst) / 2];
}

private void insertionSort(int[] nums, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        int temp = nums[i];
        for (int j = i; j >= L; j--) {
            if (j > L && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
}

private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;
    int more = R + 1;
    int idx = L;
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

**ç®—æ³•æ€è·¯ï¼š**

1. è®¾ä¸€ä¸ªè™šæ‹Ÿå¤´dummy ç»“ç‚¹æŒ‡å‘head
2. è®¾ä¸€ä¸ªæŒ‡é’ˆ preTail ä¸ºå‰ä¸€ä¸ªç»„çš„å°¾èŠ‚ç‚¹
3. curæŒ‡é’ˆæŒ‡å‘å½“å‰éå†åˆ°çš„ä½ç½®
4. ä»å½“å‰ç»“ç‚¹curå¼€å§‹ç»Ÿè®¡å¤Ÿ k ä¸ªç»“ç‚¹ï¼Œç¿»è½¬ä¸€æ¬¡ï¼Œå¹¶ç”¨preTailæŒ‡å‘ç¿»è½¬åçš„å¤´ç»“ç‚¹
5. æ›´æ–° preTail
6. è¿”å› dummyçš„ä¸‹ä¸€ä¸ªç»“ç‚¹

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode preTail = dummy;// å‰ä¸€ç»„åè½¬åçš„å°¾ç»“ç‚¹
    ListNode cur = head;
    while (cur != null) {
        ListNode curHead = cur;
        int count = 0;
        for (int i = 0; i < k; i++) {
            count++;
            cur = cur.next;
            if (cur == null) {
                break;
            }
        }
        if (count == k) {// æ‰¾åˆ°ä¸€ç»„æ»¡ç¼–çš„é“¾è¡¨æ®µ
            ListNode newCurHead = reverseListNode(curHead, k);
            preTail.next = newCurHead;
            preTail = curHead;
        } else {
            preTail.next = curHead;
        }
    }
    return dummy.next;
}

private ListNode reverseListNode(ListNode head, int k) {
    ListNode pre = null, cur = head, temp = null;
    while (k-- > 0) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

#### æ–¹æ³•ä¸€ï¼šæš´åŠ›æšä¸¾

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^3)$

```java
// æ–¹æ³•ä¸€ï¼šæš´åŠ›æšä¸¾
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (isPalindrome(chars, i, j) && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}

private boolean isPalindrome(char[] chars, int i, int j) {
    while (i < j) {
        if (chars[i++] != chars[j--]) {
            return false;
        }
    }
    return true;
}
```

#### æ–¹æ³•äºŒï¼šä¸­å¿ƒæ‰©æ•£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$

æšä¸¾çš„ä¸­å¿ƒä½ç½®çš„ä¸ªæ•°æ˜¯ $2(n-1)$, æ¯æ¬¡å‘ä¸¤è¾¹æ‰©æ•£æ£€æµ‹æ˜¯å¦å›æ–‡

```java
// æ–¹æ³•äºŒï¼šä¸­å¿ƒæ‰©æ•£
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    int maxLen = 1;
    int begin = 0;
    char[] chars = s.toCharArray();
    for (int idx = 0; idx < chars.length - 1; idx++) {
        int oddLen = palindromeLen(chars, idx, idx);
        int evenLen = palindromeLen(chars, idx, idx + 1);
        if (oddLen > maxLen || evenLen > maxLen) {
            maxLen = Math.max(oddLen, evenLen);
            begin = idx - ((maxLen + 1) >> 1) + 1;// å›æ–‡ä¸²å¥‡å¶é•¿åº¦ç»Ÿä¸€å¤„ç†
        }
    }
    return s.substring(begin, begin + maxLen);
}

// è¿”å›ä»¥ leftã€rightä¸ºå›æ–‡ä¸­å¿ƒçš„å›æ–‡ä¸²çš„é•¿åº¦
private int palindromeLen(char[] chars, int left, int right) {
    while (left >= 0 && right < chars.length && chars[left] == chars[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

#### æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$

å›æ–‡ä¸²å¤©ç„¶å…·æœ‰çŠ¶æ€è½¬ç§»æ€§è´¨ï¼Œæ–¹æ³•ä¸€ä¸­æœ‰å¯¹ æ˜¯å¦å›æ–‡çš„é‡å¤åˆ¤æ–­ï¼Œä½¿ç”¨dpäºŒç»´è¡¨è®°å½•åˆ¤æ–­ç»“æœï¼Œå‡å°‘é‡å¤åˆ¤æ–­ï¼Œç©ºé—´æ¢æ—¶é—´ï¼Œè®°å¿†åŒ–æœç´¢

```java
// æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] palindrome = isPalindrome(chars);
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (palindrome[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}


private boolean[][] isPalindrome(char[] chars) {
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }
    }
    return dp;
}
```

**ä¼˜åŒ–**

```java
// æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
            // å½“å‰å­ä¸²æ˜¯å›æ–‡ï¼Œæ›´æ–°æœ€é•¿å›æ–‡è®°å½•ä¿¡æ¯
            if (dp[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}
```

#### æ–¹æ³•å››ï¼šManacher

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```java
// Manacher ç®—æ³•
public String longestPalindrome(String s) {
    if (s == null || s.length() < 2) {
        return s;
    }
    char[] manacherStr = new char[s.length() * 2 + 1];// manacherå­—ç¬¦ä¸²
    int idx = 0;
    for (int i = 0; i < manacherStr.length; i++) {
        manacherStr[i] = ((i & 1) == 0) ? '#' : s.charAt(idx++);
    }
    int[] pArr = new int[manacherStr.length];// å›æ–‡åŠå¾„æ•°ç»„
    int C = -1;// æœ€å³æ‰©æˆåŠŸå›æ–‡ä¸²çš„ä¸­å¿ƒä½ç½®
    int R = -1;// æœ€å³æ‰©æˆåŠŸä½ç½®çš„ä¸‹ä¸€ä¸ªä½ç½®
    // manacherå­—ç¬¦ä¸²ä¸­æœ€é•¿å›æ–‡ä¸²çš„èµ·å§‹ä½ç½®å’Œé•¿åº¦
    int begin = 0;
    int maxLen = 1;
    for (int i = 0; i < manacherStr.length; i++) {
        // å½“å‰ä½ç½® i æœ€çŸ­çš„ä¸ç”¨éªŒçš„å›æ–‡åŠå¾„é•¿åº¦
        pArr[i] = (i < R) ? Math.min(pArr[2 * C - i], R - i) : 1;
        // å°è¯•æ‰©å¤§å›æ–‡åŠå¾„
        while (i - pArr[i] > -1 && i + pArr[i] < manacherStr.length) {
            if (manacherStr[i + pArr[i]] == manacherStr[i - pArr[i]]) {
                pArr[i]++;
            } else {
                break;
            }
        }
        if ((i + pArr[i]) > R) {
            R = i + pArr[i];
            C = i;
        }
        // æ›´æ–°æœ€é•¿å›æ–‡å­ä¸²ä¿¡æ¯
        if ((pArr[i] * 2 - 1) > maxLen) {
            maxLen = pArr[i] * 2 - 1;
            begin = i - pArr[i] + 1;
        }
    }
    // æ›´æ–°ä¸ºçœŸå®å€¼
    begin = (begin + 1) >> 1;
    maxLen = (maxLen - 1) >> 1;
    return s.substring(begin, begin + maxLen);
}
```

### [151. ç¿»è½¬å­—ç¬¦ä¸²é‡Œçš„å•è¯](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

#### æ–¹æ³•ä¸€ï¼šè°ƒç”¨å†…ç½®API

```java
public String reverseWords(String s) {
    s = s.trim();// ç§»é™¤é¦–å°¾ç©ºæ ¼
    String[] strs = s.split("[\\s]+");
    StringBuilder sb = new StringBuilder();
    for (int i = strs.length - 1; i >= 0; i--) {
        if (sb.length() > 0) {
            sb.append(" ");
        }
        sb.append(strs[i]);
    }
    return sb.toString();
}
```

```java
public String reverseWords(String s) {
    s = s.trim();// ç§»é™¤é¦–å°¾ç©ºæ ¼
    List<String> strings = Arrays.asList(s.split("\\s+"));
    Collections.reverse(strings);
    // ä½¿ç”¨joinæ–¹æ³•æ‹¼æ¥å­—ç¬¦ä¸²
    return String.join(" ", strings);
}
```

#### æ–¹æ³•äºŒï¼šåŒç«¯é˜Ÿåˆ—ï¼ˆæ ˆï¼‰

```java
public String reverseWords(String s) {
    s = s.trim();// ç§»é™¤é¦–å°¾ç©ºæ ¼
    String[] strings = s.split("\\s+");
    Deque<String> stack = new LinkedList<>();
    for (String string : strings) {
        stack.addFirst(string);
    }
    return String.join(" ", stack);
}
```

#### æ–¹æ³•ä¸‰ï¼šæœ€çœç©ºé—´çš„æ–¹å¼

**æ³¨æ„ï¼š Java æ— æ³•åšåˆ°åŸåœ° O(1)!**

```java
public String reverseWords(String s) {
    int left = 0, right = s.length() - 1;
    while (s.charAt(right) == ' ') {
        right--;
    }
    left = right;
    StringBuilder sb = new StringBuilder();
    while (right >= 0) {
        if (sb.length() > 0) {
            sb.append(' ');
        }
        while (right >= 0 && s.charAt(right) != ' ') {
            right--;
        }
        sb.append(s.substring(right + 1, left + 1));
        while (right >= 0 && s.charAt(right) == ' ') {
            right--;
        }
        left = right;
    }
    return sb.toString();
}
```

### [102. äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

#### æ–¹æ³•ä¸€ï¼šé˜Ÿåˆ—ï¼Œè¿­ä»£

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }
    List<List<Integer>> resList = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        ArrayList<Integer> list = new ArrayList<>();
        while (size-- > 0) {
            TreeNode cur = queue.poll();
            if (cur.left != null) {
                queue.offer(cur.left);
            }
            if (cur.right != null) {
                queue.offer(cur.right);
            }
            list.add(cur.val);
        }
        resList.add(list);
    }
    return resList;
}
```

#### æ–¹æ³•äºŒï¼šé€’å½’

ä½¿ç”¨ å˜é‡ level è®°å½•å½“å‰éå†åˆ°çš„å±‚æ•°

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null) {
        return new ArrayList<>();
    }
    List<List<Integer>> resList = new ArrayList<>();
    levelOrder(root, resList, 0);
    return resList;
}

private void levelOrder(TreeNode root, List<List<Integer>> resList, int level) {
    if (root == null) {
        return;
    }
    if (resList.size() <= level) {
        resList.add(new ArrayList<>());
    }
    resList.get(level).add(root.val);
    levelOrder(root.left,resList,level+1);
    levelOrder(root.right,resList,level+1);
}
```

### [415. å­—ç¬¦ä¸²ç›¸åŠ ](https://leetcode-cn.com/problems/add-strings/)

**æ€è·¯ï¼š**æ¨¡æ‹Ÿç”Ÿæ´»ä¸­ä¸¤ä¸ªæ•°ç»„ç«–å¼ç›¸åŠ çš„è¿‡ç¨‹ï¼Œä»åœ°ä½åˆ°é«˜ä½é€ä½ç›¸åŠ ï¼Œå†ç”¨ä¸€ä¸ªå˜é‡ä¿å­˜è¿›ä½ï¼Œä¸ºäº†ç»Ÿä¸€å¤„ç†ä¸¤æ•°å­—é•¿åº¦ä¸ç­‰çš„æƒ…å†µï¼Œå‡å°‘ä»£ç é‡ï¼Œå¯¹äºä¸‹æ ‡æŒ‡å‘è´Ÿæ•°çš„æƒ…å†µè¿”å›0å³å¯ï¼Œè¿™æ ·æ¨¡æ‹Ÿäº†å¯¹ **ä½æ•°è¾ƒçŸ­çš„æ•°å­—è¡¥å‰å¯¼0**çš„æ“ä½œ

```java
public String addStrings(String num1, String num2) {
    StringBuilder sb = new StringBuilder();
    int i = num1.length() - 1, j = num2.length() - 1;
    int temp = 0;
    while (i >= 0 || j >= 0 || temp != 0) {
        int a = i >= 0 ? num1.charAt(i--) - '0' : 0;
        int b = j >= 0 ? num2.charAt(j--) - '0' : 0;
        temp = a + b + temp;
        sb.append(temp % 10);
        temp /= 10;
    }
    return sb.reverse().toString();
}
```

### [678. æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸²](https://leetcode-cn.com/problems/valid-parenthesis-string/)

#### æ–¹æ³•ä¸€ ï¼šå•æ ˆ

#### æ–¹æ³•äºŒï¼šåŒæ ˆ

æ€è·¯ï¼š

1. ä¸€ä¸ªæ ˆå­˜ '*', ä¸€ä¸ªæ ˆå­˜ '(', å­˜çš„æ—¶å¯¹åº”çš„ä¸‹æ ‡
2. éå†ä¸€é å­—ç¬¦ä¸²ï¼Œé‡åˆ° '*'å’Œ'(' åˆ™åŠ å…¥å¯¹åº”æ ˆ
3. é‡åˆ° ')'æ—¶ï¼Œå·¦æ‹¬å·æ ˆå…ˆå‡ºæ ˆï¼Œå¦åˆ™ï¼Œâ­æ ˆå‡ºæ ˆï¼Œè‹¥ä¸¤æ ˆçš†ç©ºï¼Œåˆ™ FALSE
4. éå†å®Œåå† å¾ªç¯æ£€æµ‹ å·¦æ‹¬å·æ ˆ æ ˆé¡¶ä¸‹æ ‡ä¸ â­æ ˆçš„æ ˆé¡¶ä¸‹æ ‡ï¼Œå¦‚æœå·¦æ‹¬å·æ ˆ æ ˆé¡¶ä¸‹æ ‡å¤§äº â­æ ˆæ ˆé¡¶ä¸‹æ ‡ï¼Œæˆ–â­æ ˆç©ºï¼Œåˆ™ FALSE

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
// åŒæ ˆ
public boolean checkValidString(String s) {
    char[] chars = s.toCharArray();
    Deque<Integer> star = new LinkedList<>();// å­˜â­
    Deque<Integer> left = new LinkedList<>();// å­˜ (
    for (int idx = 0; idx < chars.length; idx++) {
        if (chars[idx] == '(') {
            left.offerFirst(idx);
        } else if (chars[idx] == '*') {
            star.offerFirst(idx);
        } else if (!left.isEmpty()) {
            left.pollFirst();
        } else if (!star.isEmpty()) {
            star.pollFirst();
        } else {
            return false;
        }
    }
    while (!left.isEmpty() && !star.isEmpty()) {
        if (left.pollFirst() > star.pollFirst()) {
            return false;
        }
    }
    return left.isEmpty();
}
```

#### æ–¹æ³•ä¸‰ï¼šè´ªå¿ƒ

ä½¿ç”¨è´ªå¿ƒçš„æ€æƒ³ï¼Œå¯ä»¥å°†ç©ºé—´å¤æ‚åº¦é™åˆ° $O(1)$

**æ€è·¯ï¼š**

ä»å·¦åˆ°å³éå†å­—ç¬¦ä¸²çš„è¿‡ç¨‹ä¸­ï¼ŒæœªåŒ¹é…çš„å·¦æ‹¬å·çš„æ•°é‡æœ‰å¦‚ä¸‹å˜åŒ–

- å¦‚æœé‡åˆ°å·¦æ‹¬å·ï¼ŒæœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡åŠ ä¸€
- å¦‚æœé‡åˆ°å³æ‹¬å·ï¼ŒæœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡å‡ä¸€
- å¦‚æœé‡åˆ°â­ï¼Œå› ä¸ºâ­å¯ä»¥çœ‹ä½œ å·¦æ‹¬å·æˆ–å³æ‹¬å·ï¼Œæ‰€ä»¥æœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡å¯èƒ½åŠ ä¸€ã€å‡ä¸€ï¼Œæˆ–ä¸å˜

**å…·ä½“ç®—æ³•æè¿°ï¼š**

1. ä»å·¦å‘å³éå†å­—ç¬¦ä¸²
2. ä½¿ç”¨ å˜é‡ min è®°å½•æœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡çš„æœ€å°å€¼ï¼Œä½¿ç”¨å˜é‡ max è®°å½•æœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡çš„æœ€å¤§å€¼
3. å¦‚æœé‡åˆ°å·¦æ‹¬å·ï¼Œmin+1,max+1
4. å¦‚æœé‡åˆ°å³æ‹¬å·ï¼Œmin-1,max-1
5. å¦‚æœé‡åˆ°â­ï¼Œåˆ™ min-1,max+1
6. ä»»ä½•æƒ…å†µä¸‹ï¼ŒæœªåŒ¹é…çš„å·¦æ‹¬å·æ•°é‡éƒ½å¿…é¡»éè´Ÿï¼Œå› æ­¤å½“ max å˜æˆè´Ÿæ•°æ—¶ï¼Œè¯´æ˜æ²¡æœ‰å·¦æ‹¬å·å¯ä»¥å’Œå³æ‹¬å·åŒ¹é…ï¼Œè¿”å› FALSE
7. å½“ min ä¸º 0æ—¶ï¼Œä¸åº”è¯¥ç»§ç»­å‡å°‘ï¼Œé‡ç½®ä¸º 0
8. éå†ç»“æŸåæ‰€æœ‰çš„å·¦æ‹¬å·å’Œå³æ‹¬å·éƒ½åº”å·²ç»åŒ¹é…ï¼Œä¹Ÿå°±æ˜¯ æœªåŒ¹é…çš„å·¦æ‹¬å·çš„ min ä¸º 0æ—¶ï¼Œå­—ç¬¦ä¸²sæ‰æ˜¯æœ‰æ•ˆçš„ æ‹¬å·å­—ç¬¦ä¸²

```java
// è´ªå¿ƒ
public boolean checkValidString(String s) {
    int min = 0, max = 0;
    for (char c : s.toCharArray()) {
        if (c == '(') {
            min++;
            max++;
        } else if (c == ')') {
            min--;
            max--;
        } else {
            min--;
            max++;
        }
        min = Math.max(min, 0);
        if (max < 0) {
            return false;
        }
    }
    return min == 0;
}
```

### [15. ä¸‰æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/3sum/)

#### æ’åº+åŒæŒ‡é’ˆ

**æ—¶é—´å¤æ‚åº¦ï¼š**

- æ’åºï¼š$O(nlog^n)$
- æŸ¥æ‰¾ï¼š$O(n^2)$

**ç©ºé—´å¤æ‚åº¦ï¼š**

- $O(log^n)$ æ’åºçš„ç©ºé—´å¤æ‚åº¦ä¸º$O(log^n)$

**æ€è·¯ï¼š**

1. è·³è¿‡é‡å¤è§£ï¼šæ’åºï¼ŒæŒ‡é’ˆè·³è¿‡å·²æŸ¥è¯¢è¿‡çš„ç›¸åŒå€¼å…ƒç´ 
2. è½¬æ¢ä¸º ä¸¤æ•°ä¹‹å’Œ

```java
// ä¸‰æ•°ä¹‹å’Œ - æ’åº+åŒæŒ‡é’ˆ
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);// æ’åºï¼Œæ–¹ä¾¿ç»•å¼€é‡å¤è§£
    List<List<Integer>> ans = new ArrayList<>();
    for (int first = 0; first < nums.length; first++) {
        // è·³è¿‡å·²ç»æŸ¥è¿‡çš„ç›¸åŒå…ƒç´ 
        if (first > 0 && nums[first] == nums[first - 1]) {
            continue;
        }
        int three = nums.length - 1;// ç¬¬ä¸‰ä¸ªå…ƒç´ æŒ‡é’ˆ
        for (int second = first + 1; second < nums.length; second++) {
            // è·³è¿‡å·²ç»æŸ¥è¿‡çš„ç›¸åŒå…ƒç´ 
            if (second > first + 1 && nums[second] == nums[second - 1]) {
                continue;
            }
            while (second < three && nums[second] + nums[three] > -nums[first]) {
                three--;
            }
            if (second >= three) {
                break;
            }
            if (nums[second] + nums[three] == -nums[first]) {
                ArrayList<Integer> list = new ArrayList<>();
                list.add(nums[first]);
                list.add(nums[second]);
                list.add(nums[three]);
                ans.add(list);
            }
        }
    }
    return ans;
}
```

### [16. æœ€æ¥è¿‘çš„ä¸‰æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/3sum-closest/)

#### æ–¹æ³•ä¸€ï¼šæ’åº+åŒæŒ‡é’ˆ

**æ€è·¯ï¼š**

1. è€ƒè™‘ä¸‰é‡å¾ªç¯æš´åŠ›è§£çš„åšæ³•ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¸º $O(n^3)$
2. è€ƒè™‘å¯¹æš´åŠ›è§£çš„ä¼˜åŒ–ï¼Œå¦‚ä½•åœ¨å›ºå®šç¬¬ä¸€ä¸ªå…ƒç´  a çš„æƒ…å†µä¸‹åœ¨**å‰©ä½™çš„æ•°ç»„å…ƒç´ **ä¸­æ‰¾åˆ°æœ€æ¥è¿‘ target - a çš„ bå’Œc
3. å¯ä»¥é€šè¿‡åŒé‡å¾ªç¯æŸ¥æ‰¾åˆé€‚çš„ bå’Œ c
4. ä¸ºäº†èƒ½æœ‰è§„å¾‹çš„æŸ¥æ‰¾åˆé€‚çš„bå’Œcï¼Œè¦æå‰å¯¹æ•°ç»„è¿›è¡Œ**å‡åºæ’åº**
5. è¿™æ ·ä¸€æ¥é—®é¢˜å°±å˜æˆäº†åœ¨ä¸€ä¸ªå‡åºæ•°ç»„ä¸­ æŸ¥æ‰¾æœ€æ¥è¿‘ target-a çš„ bå’Œcï¼Œè‡ªç„¶è€Œç„¶çš„æƒ³åˆ°äº†åŒæŒ‡é’ˆï¼ŒæŒ‡é’ˆsecondæŒ‡å‘ å‰©ä½™æ•°ç»„å…ƒç´ çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒæŒ‡é’ˆ threeæŒ‡å‘æœ€åä¸€ä¸ªå…ƒç´ 
6. ç”¨ å˜é‡ best è®°å½•å½“å‰ a+b+c çš„æœ€ä½³æƒ…å†µ
7. å¦‚æœ nums[second]+nums[three] == target - aï¼Œåˆ™ç›´æ¥è¿”å›
8. å¦‚æœå½“å‰ nums[second]+nums[three] æ¯”ä¹‹å‰çš„æƒ…å†µæ›´æ¥è¿‘ target -a ,åˆ™æ›´æ–° best
9. å¦‚æœ nums[second]+nums[three] >  target - a, å³æŒ‡é’ˆå·¦ç§»
10. å¦‚æœ nums[second]+nums[three] <  target - a, å·¦æŒ‡é’ˆå³ç§»

```java
// æ’åº+åŒæŒ‡é’ˆ
public int threeSumClosest(int[] nums, int target) {
    Arrays.sort(nums);
    int best = 1000001;
    for (int first = 0; first < nums.length; first++) {
        int second = first + 1;
        int three = nums.length - 1;
        while (second < three) {
            int sum = nums[first] + nums[second] + nums[three];
            if (sum == target) {
                return target;
            }
            if (Math.abs(target - sum) < Math.abs(target - best)) {
                best = sum;
            }
            // ç›®æ ‡å’Œ å¤§äº target,å³æŒ‡é’ˆå·¦ç§»
            if (sum > target) {
                three--;
            } else {// ç›®æ ‡å’Œå°äºtargetï¼Œ å·¦æŒ‡é’ˆå³ç§»
                second++;
            }
        }
    }
    return best;
}
```

#### æ–¹æ³•ä¸€ä¼˜åŒ–

**æ€è·¯ï¼š**

1. å¯¹äº ç›¸åŒ nums[first]ï¼Œå»é‡
2. å¯¹äº ç›¸åŒ nums[second],å»é‡
3. å¯¹äº ç›¸åŒ nums[three],å»é‡

```java
// æ’åº+åŒæŒ‡é’ˆ
public int threeSumClosest(int[] nums, int target) {
    Arrays.sort(nums);
    int best = 1000001;
    for (int first = 0; first < nums.length; first++) {
        if (first > 0 && nums[first] == nums[first - 1]) {
            continue;
        }
        int second = first + 1;
        int three = nums.length - 1;
        while (second < three) {
            int sum = nums[first] + nums[second] + nums[three];
            if (sum == target) {
                return target;
            }
            if (Math.abs(target - sum) < Math.abs(target - best)) {
                best = sum;
            }
            // ç›®æ ‡å’Œ å¤§äº target,å³æŒ‡é’ˆå·¦ç§»
            if (sum > target) {
                three--;
                while (second < three && nums[three] == nums[three + 1]) {
                    three--;
                }
            } else {// ç›®æ ‡å’Œå°äºtargetï¼Œ å·¦æŒ‡é’ˆå³ç§»
                second++;
                while (second < three && nums[second] == nums[second - 1]) {
                    second++;
                }
            }
        }
    }
    return best;
}
```

### [å‰‘æŒ‡ Offer 54. äºŒå‰æœç´¢æ ‘çš„ç¬¬kå¤§èŠ‚ç‚¹](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

#### æ–¹æ³•ä¸€ï¼šäºŒå‰æ ‘ä¸­åºéå†

**é€’å½’**

```java
public int kthLargest(TreeNode root, int k) {
    List<Integer> list = new ArrayList<>();
    DFS(root, list);
    return list.get(list.size() - k);
}

private void DFS(TreeNode root, List<Integer> list) {
    if (root == null) {
        return;
    }
    DFS(root.left, list);
    list.add(root.val);
    DFS(root.right, list);
}
```

**è¿­ä»£**

```java
public int kthLargest(TreeNode root, int k) {
    List<Integer> list = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(root);
            root = root.left;
        }
        root = stack.pollFirst();
        list.add(root.val);
        root = root.right;
    }
    return list.get(list.size() - k);
}
```

#### æ–¹æ³•äºŒï¼šäºŒå‰æœç´¢æ ‘åå‘éå†

**è¿­ä»£**

```java
public int kthLargest(TreeNode root, int k) {
    List<Integer> list = new ArrayList<>();
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(root);
            root = root.right;
        }
        root = stack.pollFirst();
        if (k == 1) {
            break;
        }
        k--;
        root = root.left;
    }
    return root.val;
}
```

**é€’å½’**

```java
public int kthLargest(TreeNode root, int k) {
    List<Integer> list = new ArrayList<>();
    DFS(root, list, k);
    return list.get(k - 1);
}

public void DFS(TreeNode root, List<Integer> list, int k) {
    if (root == null) {
        return;
    }
    DFS(root.right, list, k);
    list.add(root.val);
    if (list.size() == k) {
        return;
    }
    DFS(root.left, list, k);
}
```

### [å‰‘æŒ‡ Offer 07. é‡å»ºäºŒå‰æ ‘](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

#### æ–¹æ³•ä¸€ åˆ†æ²»ï¼Œè¿­ä»£

```java
// æ ¹æ®å‰åºã€ä¸­åºéå†æ„é€ äºŒå‰æ ‘
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return DFS(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);
}

private TreeNode DFS(int[] preorder, int[] inorder, int pL, int pR, int iL, int iR) {
    if (pL >= preorder.length || iR < 0 || pL > pR || iL > iR) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pL]);
    if (pL == pR) {
        return root;
    }

    int rootVal = root.val;
    int inRootIdx = iL;// ä¸­åºéå†ä¸­rootç»“ç‚¹çš„ä¸‹æ ‡ä½ç½®
    while (inorder[inRootIdx] != rootVal) {
        inRootIdx++;
    }
    int leftLen = inRootIdx - iL;// ä¸­åºéå†ä¸­ï¼Œrootç»“ç‚¹å·¦å­æ ‘çš„ç»“ç‚¹ä¸ªæ•°
    root.left = DFS(preorder, inorder, pL + 1, pL + leftLen, iL, inRootIdx - 1);
    root.right = DFS(preorder, inorder, pL + leftLen + 1, pR, inRootIdx + 1, iR);
    return root;
}
```

#### æ–¹æ³•äºŒ åˆ†æ²»+hashMap

```java
// hashMapå­˜å‚¨ä¸­åºéå†ä¸å…¶å¯¹åº”ä¸‹æ ‡
public TreeNode buildTree(int[] preorder, int[] inorder) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return DFS(preorder, map, new int[]{0, preorder.length}, new int[]{0, inorder.length});
}

private TreeNode DFS(int[] preorder, Map<Integer, Integer> map, int[] pre, int[] in) {
    if (pre[0] == pre[1]) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pre[0]]);
    int inorderRootIdx = map.get(root.val);
    int[] preL = new int[]{pre[0] + 1, pre[0] + inorderRootIdx - in[0] + 1};
    int[] inL = new int[]{in[0], inorderRootIdx};
    root.left = DFS(preorder, map, preL, inL);
    int[] preR = new int[]{preL[1], pre[1]};
    int[] inR = new int[]{inorderRootIdx + 1, in[1]};
    root.right = DFS(preorder, map, preR, inR);
    return root;
}
```

### [1008. å‰åºéå†æ„é€ äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/)

#### æ–¹æ³•ä¸€ è¿­ä»£+æ ˆ

**æ€è·¯:**

1. ä½¿ç”¨æ ˆè®°å½• BSTæ ‘ç»“ç‚¹
2. é¡ºåºéå†ä¸€æ¬¡ å‰åºéå†åºåˆ—
   1. å½“å‰éå†å…ƒç´ å°äº æ ˆé¡¶å…ƒç´ ï¼Œä½œä¸ºæ ˆé¡¶å…ƒç´ çš„å·¦å­ç»“ç‚¹ï¼Œå…¥æ ˆ
   2. å½“å‰éå†å…ƒç´ å¤§äºæ ˆé¡¶å…ƒç´ ï¼Œæ ˆé¡¶å…ƒç´ å‡ºæ ˆï¼Œç›´åˆ°æ ˆç©ºæˆ–æ ˆé¡¶å…ƒç´ å¤§äºå½“å‰å…ƒç´ ï¼Œä½œä¸ºæ ˆé¡¶å…ƒç´ çš„å³å­ç»“ç‚¹ï¼Œå…¥æ ˆ

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public TreeNode bstFromPreorder(int[] preorder) {
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode root = new TreeNode(preorder[0]);
    stack.offerFirst(root);
    for (int i = 1; i < preorder.length; i++) {
        TreeNode cur = stack.peekFirst();
        if (preorder[i] < cur.val) {
            cur.left = new TreeNode(preorder[i]);
            stack.offerFirst(cur.left);
        } else {
            while (!stack.isEmpty() && preorder[i] > stack.peekFirst().val) {
                cur = stack.pollFirst();
            }
            cur.right = new TreeNode(preorder[i]);
            stack.offerFirst(cur.right);
        }
    }
    return root;
}
```

#### æ–¹æ³•äºŒ é€’å½’+åˆ†æ²»

**æ€è·¯ï¼š**

ç»´æŠ¤ä¸€ä¸ªäºŒå…ƒç»„`(lower, upper)`ï¼Œè¡¨ç¤ºå½“å‰ä½ç½®å¯ä»¥æ’å…¥å…ƒç´ çš„ä¸Šä¸‹è¾¹ç•Œï¼Œå¦‚æœå½“å‰å…ƒç´ ä½äºè¾¹ç•Œå†…ï¼Œåˆ™ä½œä¸ºæ–°çš„ç»“ç‚¹æ’å…¥åˆ°å½“å‰ä½ç½®ï¼Œå¹¶é€’å½’å¤„ç†å·¦å³å­èŠ‚ç‚¹ï¼Œå¦åˆ™å›æº¯åˆ°çˆ¶èŠ‚ç‚¹

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
int idx = 0;
int[] preorder = null;

public TreeNode bstFromPreorder(int[] preorder) {
    this.preorder = preorder;
    return DFS(Integer.MIN_VALUE, Integer.MAX_VALUE);
}

private TreeNode DFS(int lower, int upper) {
    if (idx == preorder.length) {
        return null;
    }
    if (preorder[idx] < lower || preorder[idx] > upper) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[idx++]);
    root.left = DFS(lower, root.val);
    root.right = DFS(root.val, upper);
    return root;
}
```

#### æ–¹æ³•ä¸‰ æ’åº+å‰åºã€ä¸­åºéå†æ„é€ äºŒå‰æ ‘

**æ€è·¯ï¼š**BSTæ ‘æ˜¯æœ‰åºäºŒå‰æ ‘ï¼Œå¯ä»¥å…ˆæ’åºï¼Œå¾—åˆ°æœ‰åºçš„ä¸­åºéå†ï¼Œå†æ ¹æ®ä¸­åºéå†ã€å‰åºéå†æ„é€ äºŒå‰æ ‘

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(nlog^n)$ 

(å¿«æ’çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlog^n)$ï¼Œæ„é€ äºŒå‰æ ‘çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ï¼Œæ‰€ä»¥æ€»çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlog^n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(nlog^n)$

```java
public TreeNode bstFromPreorder(int[] preorder) {
    int[] inorder = Arrays.copyOf(preorder, preorder.length);
    quickSort(inorder);
    return buildTree(preorder, inorder);
}

private TreeNode buildTree(int[] preorder, int[] inorder) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return DFS(preorder, map, new int[]{0, preorder.length}, new int[]{0, preorder.length});
}

private TreeNode DFS(int[] preorder, Map<Integer, Integer> map, int[] pre, int[] in) {
    if (pre[0] == pre[1]) {
        return null;
    }
    TreeNode root = new TreeNode(preorder[pre[0]]);
    int rootIdx = map.get(root.val);// ä¸­åºéå†ä¸­ï¼Œrootç»“ç‚¹ä¸‹æ ‡ä½ç½®
    int[] preL = new int[]{pre[0] + 1, pre[0] + 1 + rootIdx - in[0]};
    int[] inL = new int[]{in[0], rootIdx};
    root.left = DFS(preorder, map, preL, inL);
    int[] preR = new int[]{preL[1], pre[1]};
    int[] inR = new int[]{rootIdx + 1, in[1]};
    root.right = DFS(preorder, map, preR, inR);
    return root;
}

private void quickSort(int[] nums) {
    partition(nums, 0, nums.length - 1);
}

private void partition(int[] nums, int L, int R) {
    if (L >= R) {
        return;
    }
    swap(nums, L, L + (int) (Math.random() * (R - L + 1)));
    int pivot = nums[L];
    int left = L, right = R;
    while (left < right) {
        while (left < right && nums[right] >= pivot) {
            right--;
        }
        while (left < right && nums[left] <= pivot) {
            left++;
        }
        if (left < right) {
            swap(nums, left, right);
        }
    }
    swap(nums, L, left);
    partition(nums, L, left - 1);
    partition(nums, left + 1, R);
}

private void swap(int[] nums, int a, int b) {
    if (nums[a] != nums[b]) {
        nums[b] ^= nums[a];
        nums[a] ^= nums[b];
        nums[b] ^= nums[a];
    }
}
```

#### æ–¹æ³•å›› å‰åºéå†+äºŒåˆ†æŸ¥æ‰¾

**æ€è·¯ï¼š**æ–¹æ³•ä¸‰æ’åºçš„ç›®çš„æ˜¯ä¸ºäº†åˆ›å»ºä¸­åºéå†ç»“æœï¼Œæ–¹ä¾¿æ„é€ äºŒå‰æ ‘ï¼Œå¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾æ–¹æ³•æ›¿ä»£æ’åºï¼Œé™ä½äº†ç©ºé—´å¤æ‚åº¦

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(nlog^n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$,é€’å½’è¿‡ç¨‹çš„ç©ºé—´å¤æ‚åº¦ä¸º$O(n)$

```java
public TreeNode bstFromPreorder(int[] preorder) {
    return DFS(preorder, 0, preorder.length - 1);
}

// å·¦å³é—­åŒºé—´
private TreeNode DFS(int[] preorder, int left, int right) {
    if (left > right) {
        return null;
    }
    if (left == right) {
        return new TreeNode(preorder[left]);
    }
    TreeNode root = new TreeNode(preorder[left]);
    int l = left, r = right;
    // äºŒåˆ†æŸ¥æ‰¾ å¤§äº root.valçš„ç¬¬ä¸€ä¸ªå…ƒç´ 
    while (l < r) {
        int mid = l + ((r - l + 1) >> 1);
        if (preorder[mid] > root.val) {
            r = mid - 1;
        } else {
            l = mid;
        }
    }
    root.left = DFS(preorder, left + 1, l);
    root.right = DFS(preorder, l + 1, right);
    return root;
}
```

### [138. å¤åˆ¶å¸¦éšæœºæŒ‡é’ˆçš„é“¾è¡¨](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

#### æ–¹æ³•ä¸€ï¼šåŸåœ°è§£æ³•

**æ€è·¯ï¼š**

1. ä¸ºåŸé“¾è¡¨çš„æ¯ä¸ªç»“ç‚¹åˆ›å»ºæ·±æ‹·è´ç»“ç‚¹ï¼Œå¹¶æ’å…¥å½“å‰ç»“ç‚¹ä¸ä¸‹ä¸€ä¸ªç»“ç‚¹ä¸­é—´
2. è®©æ·±æ‹·è´ç»“ç‚¹çš„éšå³æŒ‡é’ˆæŒ‡å‘åŸç»“ç‚¹éšå³æŒ‡é’ˆç»“ç‚¹çš„nextç»“ç‚¹
3. å°†æ‰€æœ‰æ·±æ‹·è´ç»“ç‚¹é“¾æ¥æˆæ–°é“¾è¡¨ï¼Œå¹¶æ¢å¤åŸé“¾è¡¨

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(1)$

```java
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    Node cur = head;// å½“å‰ç»“ç‚¹
    // å½“å‰ç»“ç‚¹æŒ‡å‘å½“å‰ç»“ç‚¹çš„æ·±æ‹·è´ç»“ç‚¹ï¼Œ
    // å½“å‰ç»“ç‚¹çš„æ·±æ‹·è´ç»“ç‚¹æŒ‡å‘å½“å‰ç»“ç‚¹çš„nextç»“ç‚¹
    while (cur != null) {
        Node next = cur.next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }
    cur = head;
    Node newHead = head.next;// æ·±æ‹·è´é“¾è¡¨å¤´ç»“ç‚¹
    // è®© randomæŒ‡å‘æ­£ç¡®çš„æ–°é“¾è¡¨ç»“ç‚¹
    while (cur != null) {
        if (cur.random != null) {
            cur.next.random = cur.random.next;
        }
        cur = cur.next.next;
    }
    // è¿˜åŸåŸé“¾è¡¨ï¼Œç„¶æ–°é“¾è¡¨ç»“ç‚¹çš„nextæŒ‡å‘æ­£ç¡®çš„ç»“ç‚¹
    cur = head;
    while (cur != null) {
        Node next = cur.next.next;
        if (next != null) {
            cur.next.next = next.next;
        }
        cur.next = next;
        cur = next;
    }
    return newHead;
}
```

#### æ–¹æ³•äºŒ è¿­ä»£+hashMap

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    Map<Node, Node> map = new HashMap<>();
    Node cur = head;
    while (cur != null) {
        map.put(cur, new Node(cur.val));
        cur = cur.next;
    }
    cur = head;
    while (cur != null) {
        if (cur.next != null) {
            map.get(cur).next = map.get(cur.next);
        }
        if (cur.random != null) {
            map.get(cur).random = map.get(cur.random);
        }
        cur = cur.next;
    }
    return map.get(head);
}
```

#### æ–¹æ³•ä¸‰ é€’å½’+hashMap

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
Map<Node, Node> map = new HashMap<>();

public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    if (map.containsKey(head)) {
        return map.get(head);
    }
    Node newNode = new Node(head.val);
    map.put(head, newNode);
    newNode.next = copyRandomList(head.next);
    newNode.random = copyRandomList(head.random);
    return newNode;
}
```

### [20. æœ‰æ•ˆçš„æ‹¬å·](https://leetcode-cn.com/problems/valid-parentheses/)

#### æ–¹æ³•ä¸€ï¼šæ ˆ

```java
public boolean isValid(String s) {
    Deque<Character> stack = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '(') {
            stack.offerFirst(')');
        } else if (c == '{') {
            stack.offerFirst('}');
        } else if (c == '[') {
            stack.offerFirst(']');
        } else if (stack.isEmpty() || stack.pollFirst() != c) {
            return false;
        }
    }
    return stack.isEmpty();
}
```

### [198. æ‰“å®¶åŠ«èˆ](https://leetcode-cn.com/problems/house-robber/)

#### æ–¹æ³•ä¸€ï¼šæš´åŠ›å°è¯•ï¼ˆè¶…æ—¶ï¼‰

```java
public int rob(int[] nums) {
    return maxValue(nums, 0);
}

private int maxValue(int[] nums, int idx) {
    if (idx >= nums.length) {
        return 0;
    }
    int max = nums[idx] + maxValue(nums, idx + 2);
    if (idx < nums.length - 1) {
        max = Math.max(max, nums[idx + 1] + maxValue(nums, idx + 3));
    }
    return max;
}
```

#### æ–¹æ³•äºŒï¼šè®°å¿†åŒ–æœç´¢

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

```java
public int rob(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        dp[i] = nums[i] + ((i + 2) >= nums.length ? 0 : dp[i + 2]);
        if (i + 1 < nums.length) {
            dp[i] = Math.max(dp[i], nums[i + 1] + ((i + 3) >= nums.length ? 0 : dp[i + 3]));
        }
    }
    return dp[0];
}
```

```java
public int rob(int[] nums) {
    int a = 0, b = 0, c = 0, d = 0;
    for (int i = nums.length - 1; i >= 0; i--) {
        d = c;
        c = b;
        b = a;
        a = nums[i] + ((i + 2) >= nums.length ? 0 : c);
        if (i + 1 < nums.length) {
            a = Math.max(a, nums[i + 1] + ((i + 3) >= nums.length ? 0 : d));
        }
    }
    return a;
}
```

### [213. æ‰“å®¶åŠ«èˆ II](https://leetcode-cn.com/problems/house-robber-ii/)

#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

```java
public int rob(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }
    if (nums.length == 2) {
        return Math.max(nums[0], nums[1]);
    }
    int value1 = maxValue(nums, 1);
    nums[nums.length - 1] = 0;
    int value2 = maxValue(nums, 0);
    return Math.max(value1, value2);
}

private int maxValue(int[] nums, int idx) {
    int[] dp = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        dp[i] = nums[i] + ((i + 2) < nums.length ? dp[i + 2] : 0);
        if (i + 1 < nums.length) {
            dp[i] = Math.max(dp[i], nums[i + 1] + ((i + 3) < nums.length ? dp[i + 3] : 0));
        }
    }
    return dp[idx];
}
```

### [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode-cn.com/problems/sliding-window-maximum/)

#### æ–¹æ³•ä¸€ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå¤§é¡¶å †ï¼‰â­

**æ€è·¯ï¼š**

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(nlog^n)$ ,åœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ•°ç»„ nums ä¸­çš„å…ƒç´ å•è°ƒé€’å¢ï¼Œé‚£ä¹ˆæœ€ç»ˆä¼˜å…ˆé˜Ÿåˆ—ä¸­åŒ…å«äº†æ‰€æœ‰å…ƒç´ ï¼Œæ²¡æœ‰å…ƒç´ è¢«ç§»é™¤ã€‚ç”±äºå°†ä¸€ä¸ªå…ƒç´ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(log^n)$ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸º  $O(nlog^n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    int[] ans = new int[nums.length - k + 1];
    PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> b[0] - a[0]);
    for (int i = 0; i < k; i++) {
        heap.offer(new int[]{nums[i], i});
    }
    ans[0] = heap.peek()[0];
    for (int idx = k; idx < nums.length; idx++) {
        heap.offer(new int[]{nums[idx], idx});
        while (heap.peek()[1] <= idx - k) {
            heap.poll();
        }
        ans[idx - k + 1] = heap.peek()[0];
    }
    return ans;
}
```

#### æ–¹æ³•äºŒ å•è°ƒé˜Ÿåˆ—ï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰

##### æ—¶é—´å¤æ‚åº¦

$O(n)$

æ¯ä¸ªä½ç½®æœ€å¤šè¿›ä¸€æ¬¡é˜Ÿåˆ—ï¼Œå‡ºä¸€æ¬¡é˜Ÿåˆ—ï¼Œæ‰€ä»¥æ€»ä»£ä»·ä¸º $O(n)$,ä½†**ä¸ä»£è¡¨**ä»»ä½•æ—¶å€™çš„è°ƒæ•´ä»£ä»·éƒ½æ˜¯ $O(1)$

##### ç©ºé—´å¤æ‚åº¦

ç©ºé—´å¤æ‚åº¦ä¸çª—å£å¤§å°æœ‰å…³ï¼Œä¸º $O(k)$

**ç®—æ³•æ€è·¯ï¼š**

- æ±‚æ»‘åŠ¨çª—å£æœ€å¤§æœ€å°å€¼é—®é¢˜çš„æ›´æ–°ç»“æ„ **æœ€ä¼˜è§£**ä¸º åŒç«¯é˜Ÿåˆ—ï¼Œæ±‚æ»‘åŠ¨çª—å£æœ€å¤§å€¼çš„åŒç«¯é˜Ÿåˆ—æ›´æ–°ç­–ç•¥ - ç»´æŒä¸€ä¸ªä»å·¦åˆ°å³æ•°ç»„å…ƒç´ å€¼**å•è°ƒé€’å‡**çš„åŒç«¯é˜Ÿåˆ—ï¼ˆå­˜æ”¾å¯¹åº”æ•°ç»„å…ƒç´ ä¸‹æ ‡ï¼‰
- Java ä¸­çš„åŒç«¯é˜Ÿåˆ—åº•å±‚æ˜¯ é“¾è¡¨å®ç°çš„

```java
// åŒç«¯é˜Ÿåˆ—ï¼ˆå•è°ƒé˜Ÿåˆ—ï¼‰æ±‚æ»‘åŠ¨çª—å£æœ€å¤§å€¼
public int[] maxSlidingWindow(int[] nums, int k) {
    LinkedList<Integer> queue = new LinkedList<>();// å•è°ƒé˜Ÿåˆ—ï¼Œå­˜æ”¾æ»‘åŠ¨çª—å£å¯¹åº”å€¼çš„ä¸‹æ ‡
    int[] ans = new int[nums.length - k + 1];// ç­”æ¡ˆæ•°ç»„
    int idx = 0;
    for (int i = 0; i < nums.length; i++) {
        // é˜Ÿå°¾å°äºç­‰äº nums[R]çš„å…ƒç´ å‡ºé˜Ÿ
        while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) {
            queue.pollLast();
        }
        queue.offerLast(i);
        if (queue.peekFirst() == i - k) {
            queue.pollFirst();
        }
        if (i + 1 - k >= 0) {
            ans[idx++] = nums[queue.peekFirst()];
        }
    }
    return ans;
}
```

### [322. é›¶é’±å…‘æ¢](https://leetcode-cn.com/problems/coin-change/)

#### æ–¹æ³•ä¸€ï¼šä»å·¦å¾€å³å°è¯•+èŒƒå›´ä¸Šå°è¯•

**æš´åŠ›é€’å½’**

```java
// æš´åŠ›é€’å½’
public int coinChange(int[] coins, int amount) {
    return DFS(coins, 0, amount);
}

private int DFS(int[] coins, int idx, int amount) {
    if (idx == coins.length) {
        return amount == 0 ? 0 : -1;
    }
    int n = amount / coins[idx];// å½“å‰é¢é¢è´§å¸å¯ä»¥é€‰æ‹©çš„æ•°é‡èŒƒå›´:0~n
    int ans = Integer.MAX_VALUE;// amounté‡‘é¢ä¸‹ï¼Œéœ€è¦çš„ç¡¬å¸æ€»ä¸ªæ•°
    for (int i = 0; i <= n; i++) {
        int num = DFS(coins, idx + 1, amount - i * coins[idx]);
        if (num != -1) {
            ans = Math.min(ans, i + num);
        }
    }
    return ans == Integer.MAX_VALUE ? -1 : ans;
}
```

**è®°å¿†åŒ–æœç´¢**

```java
// è®°å¿†åŒ–æœç´¢
public int coinChange(int[] coins, int amount) {
    int[][] dp = new int[coins.length + 1][amount + 1];
    for (int i = 1; i < dp[0].length; i++) {
        dp[coins.length][i] = -1;
    }
    for (int idx = coins.length - 1; idx >= 0; idx--) {
        for (int balance = amount; balance > 0; balance--) {
            int n = balance / coins[idx];
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i <= n; i++) {
                int num = dp[idx + 1][balance - i * coins[idx]];
                if (num != -1) {
                    ans = Math.min(ans, i + num);
                }
            }
            dp[idx][balance] = ans == Integer.MAX_VALUE ? -1 : ans;
        }
    }
    return dp[0][amount];
}
```

**åŠ¨æ€è§„åˆ’**

```java
// åŠ¨æ€è§„åˆ’
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    for (int i = 1; i < dp.length; i++) {
        dp[i] = -1;
    }
    for (int idx = coins.length - 1; idx >= 0; idx--) {
        int[] temp = new int[amount + 1];
        for (int balance = amount; balance > 0; balance--) {
            int n = balance / coins[idx];
            int ans = Integer.MAX_VALUE;
            for (int i = 0; i <= n; i++) {
                int num = dp[balance - i * coins[idx]];
                if (num != -1) {
                    ans = Math.min(ans, i + num);
                }
            }
            temp[balance] = ans == Integer.MAX_VALUE ? -1 : ans;
        }
        dp = temp;
    }
    return dp[amount];
}
```

#### æ–¹æ³•äºŒï¼šä»å·¦å¾€å³å°è¯•

**æš´åŠ›é€’å½’**

```java
// æš´åŠ›é€’å½’
public int coinChange(int[] coins, int amount) {
    return DFS(coins, amount);
}

private int DFS(int[] coins, int amount) {
    if (amount == 0) {
        return 0;
    }
    if (amount < 0) {
        return -1;
    }
    int num = Integer.MAX_VALUE;
    for (int idx = 0; idx < coins.length; idx++) {
        int n = DFS(coins, amount - coins[idx]);
        if (n != -1) {
            num = Math.min(num, n);
        }
    }
    return num == Integer.MAX_VALUE ? -1 : num + 1;
}
```

**è®°å¿†åŒ–æœç´¢&åŠ¨æ€è§„åˆ’**

```java
// è®°å¿†åŒ–æœç´¢
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    for (int balance = 1; balance <= amount; balance++) {
        int num = Integer.MAX_VALUE;
        for (int idx = 0; idx < coins.length; idx++) {
            if (balance - coins[idx] >= 0) {
                int n = dp[balance - coins[idx]];
                if (n != -1) {
                    num = Math.min(num, n);
                }
            }
        }
        dp[balance] = num == Integer.MAX_VALUE ? -1 : num + 1;
    }
    return dp[amount];
}
```

### [518. é›¶é’±å…‘æ¢ II](https://leetcode-cn.com/problems/coin-change-2/)

#### æ–¹æ³•ä¸€

**æš´åŠ›é€’å½’**

```java
public int change(int amount, int[] coins) {
    return DFS(coins, 0, amount);
}

private int DFS(int[] coins, int idx, int amount) {
    if (idx == coins.length) {
        return amount == 0 ? 1 : 0;
    }
    int count = 0;
    int n = amount / coins[idx];
    for (int i = 0; i <= n; i++) {
        count += DFS(coins, idx + 1, amount - i * coins[idx]);
    }
    return count;
}
```

**è®°å¿†åŒ–æœç´¢**

```java
// è®°å¿†åŒ–æœç´¢
public int change(int amount, int[] coins) {
    int[][] dp = new int[coins.length + 1][amount + 1];
    dp[coins.length][0] = 1;
    for (int idx = coins.length - 1; idx >= 0; idx--) {
        for (int balance = 0; balance <= amount; balance++) {
            int count = 0;
            int n = balance / coins[idx];
            for (int i = 0; i <= n; i++) {
                count += dp[idx + 1][balance - i * coins[idx]];
            }
            dp[idx][balance] = count;
        }
    }
    return dp[0][amount];
}
```

**åŠ¨æ€è§„åˆ’**

```java
// è®°å¿†åŒ–æœç´¢
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int idx = coins.length - 1; idx >= 0; idx--) {
        int[] temp = new int[amount + 1];
        for (int balance = 0; balance <= amount; balance++) {
            int count = 0;
            int n = balance / coins[idx];
            for (int i = 0; i <= n; i++) {
                count += dp[balance - i * coins[idx]];
            }
            temp[balance] = count;
        }
        dp = temp;
    }
    return dp[amount];
}
```

**åŠ¨æ€è§„åˆ’ - æ–œç‡ä¼˜åŒ–**

æ–œç‡ä¼˜åŒ–éœ€è¦ç”»å›¾å»ºç«‹ç©ºé—´æ„Ÿåæ‰èƒ½å†™å‡ºæ¥

```java
// åŠ¨æ€è§„åˆ’ - æ–œç‡ä¼˜åŒ–
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];
    dp[0] = 1;
    for (int idx = coins.length - 1; idx >= 0; idx--) {
        int[] temp = new int[amount + 1];
        for (int balance = 0; balance <= amount; balance++) {
            temp[balance] = dp[balance];
            if (balance - coins[idx] >= 0) {
                temp[balance] += temp[balance - coins[idx]];
            }
        }
        dp = temp;
    }
    return dp[amount];
}
```

### [2. ä¸¤æ•°ç›¸åŠ ](https://leetcode-cn.com/problems/add-two-numbers/)

#### æ–¹æ³•ä¸€ï¼šè¿­ä»£

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode();
    ListNode cur = dummy;
    int sum = 0;
    while (l1 != null && l2 != null) {
        sum += l1.val + l2.val;
        l1 = l1.next;
        l2 = l2.next;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        sum /= 10;
    }
    while (l1 != null) {
        sum += l1.val;
        l1 = l1.next;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        sum /= 10;
    }
    while (l2 != null) {
        sum += l2.val;
        l2 = l2.next;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        sum /= 10;
    }
    if (sum != 0) {
        cur.next = new ListNode(sum);
    }
    return dummy.next;
}
```

#### æ–¹æ³•äºŒï¼šé€’å½’

### [160. ç›¸äº¤é“¾è¡¨](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

#### åŒæŒ‡é’ˆ

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode a = headA, b = headB;
    while (a != b) {
        a = a == null ? headB : a.next;
        b = b == null ? headA : b.next;
    }
    return a;
}
```

#### å·®å€¼æ³•

æ±‚ä¸¤é“¾è¡¨é•¿åº¦å·®å€¼ï¼Œç„¶åé•¿çš„é“¾è¡¨å…ˆèµ°å·®å€¼æ­¥ï¼Œå°±æ˜¯ç­”æ¡ˆ

#### å“ˆå¸Œè¡¨

å“ˆå¸Œè¡¨å­˜ä¸€æ¡é“¾è¡¨ï¼Œç„¶åéå†å¦ä¸€æ¡é“¾è¡¨ï¼Œå¦‚æœå­˜åœ¨åœ¨å“ˆå¸Œè¡¨ä¸­å°±æ˜¯ç­”æ¡ˆ

#### æ ˆè§£æ³•

ä¸¤ä¸ªæ ˆå­˜ä¸¤ä¸ªé“¾è¡¨ï¼Œå¹¶è®°å½•ä¸Šä¸€æ¬¡å‡ºæ ˆå…ƒç´ ï¼Œé‡åˆ°ç¬¬ä¸€ä¸ªä¸åŒå…ƒç´ ï¼Œé‚£ä¹ˆä¸Šä¸€æ¬¡å‡ºæ ˆå…ƒç´ å°±æ˜¯ç­”æ¡ˆ

#### æš´åŠ›å¾ªç¯

### [110. å¹³è¡¡äºŒå‰æ ‘](https://leetcode-cn.com/problems/balanced-binary-tree/)

#### è‡ªåº•å‘ä¸Š - é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public boolean isBalanced(TreeNode root) {
    return process(root) == -1 ? false : true;
}

private int process(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = process(root.left);
    int right = process(root.right);
    if (left == -1 || right == -1 || Math.abs(right - left) > 1) {
        return -1;
    }
    return Math.max(left, right) + 1;
}
```

#### ååºéå† - è¿­ä»£

**æ€è·¯ï¼š**ååºéå†çš„è¿‡ç¨‹ä¸ºæ¯ä¸ªç»“ç‚¹æ‰‹åŠ¨è®°å½•å·¦å³å­æ ‘é«˜åº¦ï¼Œå¹¶åœ¨ååºéå†å›åˆ°å½“å‰ç»“ç‚¹æ—¶æ¯”è¾ƒå·¦å³å­æ ‘é«˜åº¦å·®ï¼Œæœ€åæ¯”è¾ƒæ ¹èŠ‚ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œè¿™é‡Œçš„ç©ºé—´å¤æ‚åº¦ä¸æ ‘é«˜åº¦æœ‰å…³

```java
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }
    Deque<Pair> stack = new LinkedList<>();
    Pair pre = null;// è®°å½•ä¹‹å‰çš„ç»“ç‚¹
    TreeNode preNode = null;// è®°å½•ä¹‹å‰çš„ç»“ç‚¹
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(new Pair(root, 0, 0));
            root = root.left;
        }
        Pair cur = stack.peekFirst();
        root = cur.node;
        if (pre != null && root.right == pre.node) {// ä»å³å­æ ‘å›æ¥
            cur.right = Math.max(pre.left, pre.right) + 1;// æ›´æ–°å³å­æ ‘é«˜åº¦
        } else if (root.left != null) {// ä»å·¦å­æ ‘å›æ¥
            cur.left = Math.max(pre.left, pre.right) + 1;// æ›´æ–°å·¦å­æ ‘é«˜åº¦
        }
        if (root.right != null && root.right != preNode) {
            root = root.right;
        } else {
            pre = stack.pollFirst();
            preNode = root;
            if (Math.abs(pre.left - pre.right) > 1) {// ä»å·¦å³å­æ ‘å›æ¥ååˆ¤æ–­å·¦å³å­æ ‘é«˜åº¦å·®
                return false;
            }
            root = null;
        }
    }
    return Math.abs(pre.left - pre.right) <= 1;// åˆ¤æ–­æ ¹èŠ‚ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®
}

class Pair {
    TreeNode node;
    int left;
    int right;

    public Pair(TreeNode node, int left, int right) {
        this.node = node;
        this.left = left;
        this.right = right;
    }
}
```

### [144. äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

#### é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    return DFS(root, ans);
}

private List<Integer> DFS(TreeNode root, List<Integer> ans) {
    if (root == null) {
        return ans;
    }
    ans.add(root.val);
    DFS(root.left, ans);
    DFS(root.right, ans);
    return ans;
}
```

#### éé€’å½’ï¼ˆä¸€ï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            ans.add(root.val);
            stack.offerFirst(root);
            root = root.left;
        }
        root = stack.pollFirst();
        root = root.right;
    }
    return ans;
}
```

#### éé€’å½’ï¼ˆäºŒï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

**æ€è·¯ï¼š**

å¤´ç»“ç‚¹å…ˆå…¥æ ˆï¼Œå‡ºæ ˆï¼Œæ‰“å°å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹çš„**å³å·¦**å­ç»“ç‚¹å…¥æ ˆï¼Œå…¥æ ˆé¡ºåº **å³å·¦**ï¼Œé‚£ä¹ˆå‡ºæ ˆé¡ºåºå³ä¸º å·¦å³ï¼Œä¾æ¬¡æ‰“å°å¯ä»¥å¾—åˆ°å‰åºéå† ä¸­å·¦å³

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    stack.offerFirst(root);
    while (!stack.isEmpty()) {
        root = stack.pollFirst();
        ans.add(root.val);
        if (root.right != null) {
            stack.offerFirst(root.right);
        }
        if (root.left != null) {
            stack.offerFirst(root.left);
        }
    }
    return ans;
}
```

#### Morris å…ˆåºéå†

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(1)$

```java
// morriså…ˆåºéå†ï¼Œå¯¹äºèƒ½å›åˆ°è‡ªå·±ä¸¤æ¬¡çš„ç»“ç‚¹ï¼Œç¬¬ä¸€æ¬¡é‡åˆ°å°±æ‰“å°ï¼Œåªèƒ½å›åˆ°è‡ªå·±ä¸€æ¬¡çš„ç»“ç‚¹ç›´æ¥æ‰“å°
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    TreeNode cur = root;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                ans.add(cur.val);
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        } else {
            ans.add(cur.val);
        }
        cur = cur.right;
    }
    return ans;
}
```

### [94. äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

#### é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> inorderTraversal(TreeNode root) {
    return DFS(root, new ArrayList<>());
}

private List<Integer> DFS(TreeNode root, List<Integer> ans) {
    if (root == null) {
        return ans;
    }
    DFS(root.left, ans);
    ans.add(root.val);
    DFS(root.right, ans);
    return ans;
}
```

#### éé€’å½’ï¼ˆä¸€ï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(root);
            root = root.left;
        }
        root = stack.pollFirst();
        ans.add(root.val);
        root = root.right;
    }
    return ans;
}
```

#### éé€’å½’ï¼ˆäºŒï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

**æ€è·¯ï¼š**

1. é˜¶æ®µä¸€ï¼šå­æ ‘æ•´æ¡å·¦è¾¹ç•Œè¿›æ ˆï¼Œç›´åˆ°å·¦å­æ ‘ä¸ºç©ºï¼Œè¿›å…¥é˜¶æ®µäºŒ
2. é˜¶æ®µäºŒï¼šæ ˆä¸­å¼¹å‡º curå¹¶æ‰“å°ï¼Œcurçš„å³å­æ ‘é‡å¤é˜¶æ®µä¸€

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        if (root != null) {            // é˜¶æ®µä¸€ï¼šå­æ ‘æ•´æ¡å·¦è¾¹ç•Œè¿›æ ˆ
            stack.offerFirst(root);
            root = root.left;
        } else {
            // é˜¶æ®µäºŒï¼šæ ˆä¸­å¼¹å‡º curå¹¶æ‰“å°ï¼Œcurçš„å³å­æ ‘é‡å¤é˜¶æ®µä¸€
            root = stack.pollFirst();
            ans.add(root.val);
            root = root.right;
        }
    }
    return ans;
}
```

#### Morris ä¸­åºéå†

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(1)$

```java
// morris ä¸­åºéå†ï¼šå¯¹äºèƒ½æ¥åˆ°è‡ªå·±ä¸¤æ¬¡çš„ç»“ç‚¹ï¼Œç¬¬äºŒæ¬¡æ¥åˆ°è‡ªå·±æ—¶æ‰“å°ï¼Œåªèƒ½æ¥åˆ°è‡ªå·±ä¸€æ¬¡çš„ç›´æ¥æ‰“å°
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    TreeNode cur = root;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        }
        ans.add(cur.val);
        cur = cur.right;
    }
    return ans;
}
```

### [145. äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

#### é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> postorderTraversal(TreeNode root) {
    return DFS(root, new ArrayList<>());
}

private List<Integer> DFS(TreeNode root, List<Integer> ans) {
    if (root == null) {
        return ans;
    }
    DFS(root.left, ans);
    DFS(root.right, ans);
    ans.add(root.val);
    return ans;
}
```

#### éé€’å½’ï¼ˆä¸€ï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode child = null;
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(root);
            root = root.left;
        }
        root = stack.peekFirst();
        if (root.right != null && root.right != child) {
            root = root.right;
        } else {
            ans.add(root.val);
            stack.pollFirst();
            child = root;
            root = null;
        }
    }
    return ans;
}
```

#### éé€’å½’ï¼ˆä¸€ï¼‰ - å‰åºéå†é€†åºè¾“å‡º

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack = new LinkedList<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.offerFirst(root);
            ans.add(root.val);
            root = root.right;
        }
        root = stack.pollFirst();
        root = root.left;
    }
    Collections.reverse(ans);
    return ans;
}
```

#### éé€’å½’ï¼ˆäºŒï¼‰

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºæ ˆæ·±åº¦ hï¼Œè€Œæ ˆæ·±åº¦åœ¨äºŒå‰æ ‘ä¸ºä¸€æ¡é“¾çš„æƒ…å†µä¸‹ä¼šè¾¾åˆ°$O(n)$ 

**æ€è·¯ï¼š**

å¤´ç»“ç‚¹å…ˆå…¥æ ˆï¼Œå‡ºæ ˆï¼Œç”¨ stack2 è®°å½•å¤´ç»“ç‚¹ï¼Œå¤´ç»“ç‚¹çš„**å·¦å³**å­ç»“ç‚¹å…¥æ ˆï¼Œå…¥æ ˆé¡ºåº **å·¦å³**ï¼Œé‚£ä¹ˆå‡ºæ ˆé¡ºåºå³ä¸º å³å·¦ï¼Œé‚£ä¹ˆ stack2 æ ˆ ä¸­çš„ç»“ç‚¹é¡ºåº ä¸º  ä¸­å³å·¦ï¼Œå‡ºæ ˆé¡ºåºåˆ™ä¸º å·¦å³ä¸­ï¼Œå³ä¸º ååºéå†

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Deque<TreeNode> stack1 = new LinkedList<>();
    Deque<TreeNode> stack2 = new LinkedList<>();
    stack1.offerFirst(root);
    while (!stack1.isEmpty()) {
        root = stack1.pollFirst();
        stack2.offerFirst(root);
        if (root.left != null) {
            stack1.offerFirst(root.left);
        }
        if (root.right != null) {
            stack1.offerFirst(root.right);
        }
    }
    while (!stack2.isEmpty()) {
        ans.add(stack2.pollFirst().val);
    }
    return ans;
}
```

#### Morris ååºéå†

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(1)$

```java
// morris ååºéå†ï¼šå¯¹äºèƒ½å›åˆ°è‡ªå·±ä¸¤æ¬¡çš„ç»“ç‚¹ï¼Œç¬¬äºŒæ¬¡å›åˆ°è‡ªå·±æ—¶ï¼Œé€†åºæ‰“å°å·¦æ ‘çš„å³è¾¹ç•Œï¼Œæœ€åå•ç‹¬æ‰“å°æ•´æ£µæ ‘çš„å³è¾¹ç•Œ
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    TreeNode cur = root;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                // ç¬¬äºŒæ¬¡å›åˆ°è‡ªå·±ï¼Œé€†åºæ‰“å°å·¦æ ‘çš„å³è¾¹ç•Œ
                mostRight.right = null;

                reversePrint(cur.left, ans);
            }
        }
        cur = cur.right;
    }
    // å•ç‹¬æ‰“å°æ•´é¢—å·¦æ ‘çš„å³è¾¹ç•Œ
    reversePrint(root, ans);
    return ans;
}

private void reversePrint(TreeNode root, List<Integer> ans) {
    root = reverse(root);
    TreeNode cur = root;
    while (cur != null) {
        ans.add(cur.val);
        cur = cur.right;
    }
    reverse(root);
}

// é“¾è¡¨åè½¬
private TreeNode reverse(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode cur = root, pre = null, temp = null;
    while (cur != null) {
        temp = cur.right;
        cur.right = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [1. ä¸¤æ•°ä¹‹å’Œ](https://leetcode-cn.com/problems/two-sum/)

æ¢¦å¼€å§‹çš„åœ°æ–¹

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{-1, -1};
}
```

### [300. æœ€é•¿é€’å¢å­åºåˆ—](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

#### æš´åŠ›é€’å½’ï¼ˆè¶…æ—¶ï¼‰

```java
public int lengthOfLIS(int[] nums) {
    int max = 0;
    int len = 0;
    for (int i = nums.length - 1; i >= 0; i--) {
        len = maxLen(nums, i);
        max = Math.max(len, max);
    }
    return max;
}

// è¿”å›ç´¢å¼•ä¸º idx ä¸ºç»“å°¾ï¼Œæ‰€å¾—åˆ°çš„æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦
private int maxLen(int[] nums, int idx) {
    if (idx == -1) {
        return 0;
    }
    int maxLen = 1;
    int len = 0;
    for (int i = idx - 1; i >= 0; i--) {
        if (nums[i] < nums[idx]) {
            len = maxLen(nums, i) + 1;
            maxLen = Math.max(maxLen, len);
        }
    }
    return maxLen;
}
```

#### åŠ¨æ€è§„åˆ’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n^2)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    int ans = 0;
    for (int idx = 0; idx < nums.length; idx++) {
        dp[idx] = 1;
        for (int i = idx - 1; i >= 0; i--) {
            if (nums[i] < nums[idx]) {
                dp[idx] = Math.max(dp[idx], dp[i] + 1);
            }
        }
        ans = Math.max(ans, dp[idx]);
    }
    return ans;
}
```



#### äºŒåˆ†è§£æ³•

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(nlog^n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

**ç®—æ³•æ€è·¯:**

1. åˆ›å»ºä¸€ä¸ª $ends æ•°ç»„$ï¼Œä¸‹æ ‡ä¸º $i$ çš„ä½ç½®å«ä¹‰ï¼šä»£è¡¨éå†åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæ‰€æœ‰é•¿åº¦ä¸º $i+1$ çš„é€’å¢å­åºåˆ—ä¸­ æœ€å°ç»“å°¾æ˜¯ $ends[i]$ ; å¹¶ä¸”è¿™ä¸ª $ends æ•°ç»„$ æœ‰æ•ˆåŒº ä¸€å®šæ˜¯æœ‰åºçš„ï¼ˆåœ¨æ›´æ–° $endsæ•°ç»„$ çš„è¿‡ç¨‹ä¿è¯äº† $endsæ•°ç»„$ æœ‰æ•ˆåŒºä¸€å®šæ˜¯æœ‰åºçš„ï¼‰
2. ä» $0$ ä½ç½®å¼€å§‹ä»å·¦å¾€å³éå† $numsæ•°ç»„$ï¼Œå¹¶æ›´æ–° $endsæ•°ç»„$
   1. æ‰¾åˆ°æ¯” $endsæ•°ç»„$ æœ‰æ•ˆåŒºæœ€åä¸€ä¸ªä½ç½®çš„æ•°æ›´å¤§çš„æ•° curï¼Œæ‰©å……æœ‰æ•ˆåŒºï¼ši = i+1
   2. æ‰¾åˆ°æ¯” $endsæ•°ç»„$ æœ‰æ•ˆåŒºæœ€åä¸€ä¸ªä½ç½®çš„æ•°æ›´å°çš„æ•° curï¼Œåœ¨æœ‰æ•ˆåŒºä¸­äºŒåˆ†æŸ¥æ‰¾æ¯” cur å¤§çš„æœ€å·¦ä½ç½®çš„æ•°ï¼Œæ›´æ–°ä¸º cur

```java
public int lengthOfLIS(int[] nums) {
    int[] ends = new int[nums.length];
    int len = 0;
    ends[0] = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > ends[len]) {// æ‰¾åˆ°æ¯” ends[len] æ›´å¤§çš„å…ƒç´ ï¼Œæ‰©å……æœ‰æ•ˆåŒº
            ends[++len] = nums[i];
        } else if (nums[i] < ends[len]) {// æ‰¾åˆ°æ¯” ends[len] æ›´å°çš„å…ƒç´ ï¼ŒäºŒåˆ†æŸ¥æ‰¾æ¯” nums[i] å¤§çš„æœ€å°å…ƒç´ ï¼Œæ›´æ–°
            int left = 0, right = len;
            while (left < right) {
                int mid = left + ((right - left) >> 1);
                if (nums[i] > ends[mid]) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            ends[left] = nums[i];
        }
    }
    return len + 1;
}
```

### [NC91 æœ€é•¿ä¸Šå‡å­åºåˆ—(ä¸‰)](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=117)



### [å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

#### å¿«æ…¢æŒ‡é’ˆ

```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode right = head;
    while (k-- > 0) {
        right = right.next;
    }
    ListNode left = head;
    while (right != null) {
        left = left.next;
        right = right.next;
    }
    return left;
}
```

#### æ ˆ

```java
// æ ˆ
public ListNode getKthFromEnd(ListNode head, int k) {
    Deque<ListNode> stack = new LinkedList<>();
    ListNode cur = head;
    while (cur != null) {
        stack.offerFirst(cur);
        cur = cur.next;
    }
    while (k-- > 1) {
        stack.pollFirst();
    }
    return stack.pollFirst();
}
```

### [142. ç¯å½¢é“¾è¡¨ II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

```java
public ListNode detectCycle(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            break;
        }
    }
    if (fast == null || fast.next == null) {
        return null;
    }
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```

### [104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

#### é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(h)$

```java
// é€’å½’
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int depth_1 = maxDepth(root.left);
    int depth_2 = maxDepth(root.right);

    return depth_1 > depth_2 ? depth_1 + 1 : depth_2 + 1;
}
```

#### å±‚åºéå†

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$ 

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
// è¿­ä»£ - å±‚æ¬¡éå†
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int depth = 0;
    while (!queue.isEmpty()) {
        depth++;
        int size = queue.size();
        while (size-- > 0) {
            root = queue.poll();
            if (root.left != null) {
                queue.offer(root.left);
            }
            if (root.right != null) {
                queue.offer(root.right);
            }
        }
    }
    return depth;
}
```

### [43. å­—ç¬¦ä¸²ç›¸ä¹˜](https://leetcode-cn.com/problems/multiply-strings/)

#### æ¨¡æ‹Ÿ - åšåŠ æ³•

**æ€è·¯ï¼š**

ä»å³å¾€å·¦éå†ä¹˜æ•°ï¼Œå°†ä¹˜æ•°çš„æ¯ä¸€ä½ä¸è¢«ä¹˜æ•°ç›¸ä¹˜å¾—åˆ°å¯¹åº”çš„ç»“æœï¼Œå†å°†æ¯æ¬¡å¾—åˆ°çš„ç»“æœç´¯åŠ 

```java
public String multiply(String num1, String num2) {
    if (num1.charAt(0) == '0' || num2.charAt(0) == '0') {
        return "0";
    }
    StringBuilder sb = new StringBuilder();
    char[] num_1 = num1.toCharArray();
    char[] num_2 = num2.toCharArray();
    int n = 0;//
    String b = "";
    String sum = "0";
    for (int i = num_2.length - 1; i >= 0; i--) {
        b = process(num_1, num_2[i], n++);
        sum = sum(sum, b);
    }
    return sum;
}

public String process(char[] num_1, char num_2, int n) {
    int num2 = num_2 - '0';
    if (num2 == 0) {
        return "0";
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < n; i++) {
        sb.append(0);
    }
    if (num2 == 1) {
        return new String(num_1) + sb.toString();
    }
    int offset = 0;// è¿›ä½
    for (int i = num_1.length - 1; i >= 0; i--) {
        int num = (num_1[i] - '0') * num2;
        int value = ((num % 10) + offset);
        sb.append(value % 10);
        offset = (num / 10) + value / 10;// è¿›ä½
    }
    if (offset != 0) {
        sb.append(offset % 10);
        if (offset / 10 != 0) {
            sb.append(offset / 10);
        }
    }
    return sb.reverse().toString();
}

public String sum(String a, String b) {
    int l = a.length() - 1, r = b.length() - 1;
    StringBuilder sb = new StringBuilder();
    int offset = 0;
    while (l >= 0 && r >= 0) {
        int num = a.charAt(l--) - '0' + b.charAt(r--) - '0' + offset;
        sb.append(num % 10);
        offset = num / 10;
    }

    while (l >= 0) {
        int num = a.charAt(l--) - '0' + +offset;
        sb.append(num % 10);
        offset = num / 10;
    }
    while (r >= 0) {
        int num = b.charAt(r--) - '0' + offset;
        sb.append(num % 10);
        offset = num / 10;
    }
    if (offset != 0) {
        sb.append(offset % 10);
        if (offset / 10 != 0) {
            sb.append(offset / 10);
        }
    }
    return sb.reverse().toString();
}
```

#### æ¨¡æ‹Ÿ - åšä¹˜æ³•

æ–¹æ³•ä¸€çš„åšæ³•æ˜¯ä»å³å¾€å·¦éå†ä¹˜æ•°ï¼Œå°†ä¹˜æ•°çš„æ¯ä¸€ä½ä¸è¢«ä¹˜æ•°ç›¸ä¹˜å¾—åˆ°å¯¹åº”çš„ç»“æœï¼Œå†å°†æ¯æ¬¡å¾—åˆ°çš„ç»“æœç´¯åŠ ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸­æ¶‰åŠåˆ°è¾ƒå¤šå­—ç¬¦ä¸²ç›¸åŠ çš„æ“ä½œã€‚å¦‚æœä½¿ç”¨æ•°ç»„ä»£æ›¿å­—ç¬¦ä¸²å­˜å‚¨ç»“æœï¼Œåˆ™å¯ä»¥å‡å°‘å¯¹å­—ç¬¦ä¸²çš„æ“ä½œã€‚

ä»¤ m å’Œ nåˆ†åˆ«è¡¨ç¤º $\textit{num}_1$å’Œ $\textit{num}_2$çš„é•¿åº¦ï¼Œå¹¶ä¸”å®ƒä»¬å‡ä¸ä¸º 0ï¼Œåˆ™ $\textit{num}_1$ å’Œ $\textit{num}_2$ çš„ä¹˜ç§¯çš„é•¿åº¦ä¸º $m+n-1$æˆ– $m+n$ ã€‚

ç”±äº$\textit{num}_1$å’Œ $\textit{num}_2$çš„ä¹˜ç§¯çš„æœ€å¤§é•¿åº¦ä¸º $m+n$ï¼Œå› æ­¤åˆ›å»ºé•¿åº¦ä¸º$m+n$ çš„æ•°ç»„ $\textit{ansArr}$ ç”¨äºå­˜å‚¨ä¹˜ç§¯ã€‚å¯¹äºä»»æ„ $0 \le i < m$ å’Œ $0 \le j < n$ï¼Œ$\textit{num}_1[i] \times \textit{num}_2[j]$çš„ç»“æœä½äº $\textit{ansArr}[i+j+1]$ï¼Œå¦‚æœ $\textit{ansArr}[i+j+1] \ge 10$ï¼Œåˆ™å°†è¿›ä½éƒ¨åˆ†åŠ åˆ° $\textit{ansArr}[i+j]$

æœ€åï¼Œå°†æ•°ç»„ $\textit{ansArr}$ è½¬æˆå­—ç¬¦ä¸²ï¼Œå¦‚æœæœ€é«˜ä½æ˜¯ 0 åˆ™èˆå¼ƒæœ€é«˜ä½ã€‚

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(mn)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(m+n)$

```java
public String multiply(String num1, String num2) {
    if ("0".equals(num1) || "0".equals(num2)) {
        return "0";
    }
    int m = num1.length();
    int n = num2.length();
    int[] ans = new int[m + n];
    for (int i = m - 1; i >= 0; i--) {
        int a = num1.charAt(i) - '0';
        for (int j = n - 1; j >= 0; j--) {
            ans[i + j + 1] += a * (num2.charAt(j) - '0');
        }
    }
    for (int i = ans.length - 1; i > 0; i--) {
        ans[i - 1] += ans[i] / 10;
        ans[i] %= 10;
    }
    int idx = ans[0] == 0 ? 1 : 0;
    StringBuilder sb = new StringBuilder();
    for (int i = idx; i < ans.length; i++) {
        sb.append(ans[i]);
    }
    return sb.toString();
}
```

#### FFT å¿«é€Ÿå‚…é‡Œå¶å˜æ¢

### [199. äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

#### å±‚åºéå†

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    if (root == null) {
        return ans;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size-- > 0) {
            root = queue.poll();
            if (root.left != null) {
                queue.offer(root.left);
            }
            if (root.right != null) {
                queue.offer(root.right);
            }
            if (size == 0) {
                ans.add(root.val);
            }
        }
    }
    return ans;
}
```

#### é€’å½’

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n)$

**ç©ºé—´å¤æ‚åº¦ï¼š**$O(h)$ï¼Œ äºŒå‰æ ‘çš„é«˜åº¦ $h >= log^n$

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ans = new ArrayList<>();
    DFS(root, ans, 1);
    return ans;
}

public void DFS(TreeNode root, List<Integer> ans, int level) {
    if (root == null) {
        return;
    }
    if (ans.size() < level) {
        ans.add(root.val);
    } else {
        ans.set(level - 1, root.val);
    }
    level++;
    DFS(root.left, ans, level);
    DFS(root.right, ans, level);
}
```
