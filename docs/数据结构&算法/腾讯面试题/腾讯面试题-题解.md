### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)

#### 缓存置换策略（缓存淘汰策略）

主存容量远大于CPU缓存，磁盘容量远大于主存，因此无论是哪一层次的缓存都面临一个同样的问题：当容量有限的缓存的空闲空间全部用完后，又有新的内容需要添加进缓存时，如何挑选并舍弃原有的部分内容，从而腾出空间放入这些新的内容。



解决这个问题的算法有几种，如：

- 最久未使用算法（LFU）
  - 按访问频率来淘汰
- 先进先出算法（FIFO）
- 最近最少使用算法（LRU）
  - 按访问时序来淘汰
- 非最近使用算法（NMRU）等，

这些算法在不同层次的缓存上执行时拥有不同的效率和代价，需根据具体场合选择最合适的一种。



#### LRU原理

LRU的设计原理就是，当数据在最近一段时间经常被访问，那么它在以后也会经常被访问。这就意味着，如果经常访问的数据，我们需要能够快速命中，而不常访问的数据，我们在容量超出限制后，要将其淘汰。

LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。

**实例：**

安卓手机后台运行的排序规则，最近使用的应用排在前面，系统会杀死排序最末尾的应用，为新应用腾出空间



#### LRU 算法描述

LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。注意，get 和 put 方法必须都是 O(1) 的时间复杂度。

##### 举例子

可以通过 🌰 来理解，假设我们有容量为 2 的 LRUCache 和 测试键值对 [1-1,2-2,3-3] ，将其按照顺序进行插入 & 查询：

插入 1-1，此时最新的使用数据为 1-1
插入 2-2，此时最新使用数据变为 2-2
查询 1-1，此时最新使用数据为 1-1
插入 3-3，由于容器已经达到容量，需要先淘汰已有数据才能插入，这时候会淘汰 2-2，3-3 成为最新使用数据

键值对存储方面：

- 我们可以使用「哈希表」来确保插入和查询的复杂度为 O(1)；

- 另外我们还需要额外维护一个「使用顺序」序列，
  - 我们期望当「新数据被插入」或「发生键值对查询」时，能够将当前键值对放到序列头部，这样当触发 LRU 淘汰时，只需要从序列尾部进行数据删除即可。
  - 期望在 O(1) 复杂度内调整某个节点在序列中的位置，很自然想到双向链表。

##### 具体分析

具体的，我们使用哈希表来存储「键值对」，键值对的键作为哈希表的 Key，而哈希表的 Value 则使用我们自己封装的 `Node` 类，`Node` 同时作为双向链表的节点。

- 插入：检查当前键值对是否已经存在于哈希表：
  - 如果存在，则更新键值对，并将当前键值对所对应的 Node 节点调整到链表头部（refresh 操作）
  - 如果不存在，则检查哈希表容量是否已经达到容量：
    - 没达到容量：插入哈希表，并将当前键值对所对应的 Node 节点调整到链表头部（refresh 操作）
    - 已达到容量：先从链表尾部找到待删除元素进行删除（delete 操作），然后再插入哈希表，并将当前键值对所对应的 Node 节点调整到链表头部（refresh 操作）
- 查询：
  - 如果没在哈希表中找到该 Key，直接返回 -1−1；
  - 如果存在该 Key，则将对应的值返回，并将当前键值对所对应的 Node 节点调整到链表头部（refresh 操作）

一些细节：

- 为了减少双向链表左右节点的「判空」操作，我们预先建立两个「哨兵」节点 `head` 和 `tail`

#### ⭐算法实现

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

class LRUCache {

    class Node {
        int k, v;
        Node l, r;

        public Node(int k, int v) {
            this.k = k;
            this.v = v;
        }
    }

    int capacity;
    Map<Integer, Node> map;
    Node head, tail;    // 哨兵结点

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.r = tail;
        tail.l = head;
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            refresh(cur);
            return cur.v;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            cur.v = value;
        } else {
            if (capacity == map.size()) {
                Node del = tail.l;
                remove(del);
                map.remove(del.k);
            }
            Node node = new Node(key, value);
            map.put(key, node);
        }
        refresh(map.get(key));
    }

    /**
     * 1.先删除 cur结点（如果存在的话）
     * 2.将当前结点添加到链表头部
     *
     * @param cur
     */
    private void refresh(Node cur) {
        remove(cur);
        cur.l = head;
        cur.r = head.r;
        head.r = cur;
        cur.r.l = cur;
    }

    /**
     * 因为头部存在哨兵结点，所以如果cur.l!=null，则证明cur存在于双链表中
     *
     * @param del
     */
    private void remove(Node del) {
        if (del.l != null) {
            del.l.r = del.r;
            del.r.l = del.l;
        }
    }
}
```

### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
// 双指针
public ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head, temp = null;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
// 快排
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }
    int rand = (int) (Math.random() * (end - start + 1)) + start;
    swap(nums, start, rand);
    int pivot = nums[start];
    int l = start, r = end;
    while (l < r) {
        while (l < r && nums[r] >= pivot) {
            r--;
        }
        while (l < r && nums[l] <= pivot) {
            l++;
        }
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, l);
    quickSort(nums, start, l - 1);
    quickSort(nums, l + 1, end);
}

private void swap(int[] nums, int l, int r) {
    if (nums[l] != nums[r]) {
        nums[r] ^= nums[l];
        nums[l] ^= nums[r];
        nums[r] ^= nums[l];
    }
}
```

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

时间复杂度 $O(m+n)$

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) {
        return list2;
    }
    if (list2 == null) {
        return list1;
    }
    if (list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    }
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
}
```

### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

#### ⭐**归并法**

时间复杂度：$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    return mergeList(lists, 0, lists.length - 1);
}

private ListNode mergeList(ListNode[] lists, int start, int end) {
    if (start == end) {
        return lists[start];
    }
    int mid = (start + end) >> 1;
    ListNode list1 = mergeList(lists, start, mid);
    ListNode list2 = mergeList(lists, mid + 1, end);
    return merge(list1, list2);
}

private ListNode merge(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = merge(l1.next, l2);
        return l1;
    }
    l2.next = merge(l1, l2.next);
    return l2;
}
```

#### ⭐**小根堆**

时间复杂度：$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    PriorityQueue<ListNode> queue = new PriorityQueue<>((l1, l2) -> l1.val - l2.val);
    for (int i = 0; i < lists.length; i++) {
        queue.offer(lists[i]);
    }
    ListNode dummy = new ListNode();
    ListNode res = dummy;
    while (!queue.isEmpty()) {
        ListNode list = queue.poll();
        res.next = list;
        res = res.next;
        if (res.next != null) {
            queue.offer(res.next);
        }
    }
    return dummy.next;
}
```

### [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

算法思路：

1. 去掉前导空格
2. 再是处理正负号
3. 识别数字，注意越界情况

```java
public int myAtoi(String s) {
    int idx = 0;
    while (idx < s.length() && s.charAt(idx) == ' ') {// 移除前导空格
        idx++;
    }
    if (idx == s.length()) {
        return 0;
    }

    int result = 0;
    boolean negative = false;
    if (s.charAt(idx) == '-') {
        negative = true;
        idx++;
    } else if (s.charAt(idx) == '+') {
        idx++;
    }
    for (int i = idx; i < s.length() && Character.isDigit(s.charAt(i)); i++) {
        int digit = s.charAt(i) - '0';
        if ((Integer.MAX_VALUE - digit) / 10 < result) {
            return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        result = result * 10 + digit;
    }
    return negative ? -result : result;
}
```

### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```java
// 方法一：翻转链表后判断是否和原链表相同
public boolean isPalindrome(ListNode head) {
    ListNode reserveList = reserve(head);
    while (head != null) {
        if (head.val != reserveList.val) {
            return false;
        }
        head = head.next;
        reserveList = reserveList.next;
    }
    return true;
}

private ListNode reserve(ListNode head) {
    ListNode pre = null, cur = head, res = null;
    while (cur != null) {
        res = new ListNode(cur.val, res);
        cur = cur.next;
    }
    return res;
}
```

```java
// 方法二：双端队列
public boolean isPalindrome(ListNode head) {
    Deque<Integer> deque = new LinkedList<>();
    while (head != null) {
        deque.offerLast(head.val);
        head = head.next;
    }
    while (!deque.isEmpty() && deque.size() > 1) {
        if (deque.pollFirst() != deque.pollLast()) {
            return false;
        }
    }
    return true;
}
```

```java
// 方法三：快慢指针，翻转后半部分链表然后与前半部分比较
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    // 寻找中间结点
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    if (fast != null) {
        slow = slow.next;
    }
    slow = reserve(slow);
    while (slow != null) {
        if (slow.val != head.val) {
            return false;
        }
        slow = slow.next;
        head = head.next;
    }
    return true;
}

private ListNode reserve(ListNode node) {
    ListNode pre = null, temp = null, cur = node;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

#### ⭐**方法三优化**

优化：在快慢指针寻找中间结点过程，顺便翻转前半部分链表

```java
// 方法三：快慢指针，在快慢指针寻找中间结点过程，顺便翻转前半部分链表
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head, firstNode = head, pre = null;
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
        firstNode.next = pre;
        pre = firstNode;
        firstNode = slow;
    }
    if (fast != null) {
        slow = slow.next;
    }
    while (slow != null) {
        if (slow.val != pre.val) {
            return false;
        }
        pre = pre.next;
        slow = slow.next;
    }
    return true;
}
```

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

#### ⭐左右闭区间写法

求中间数 1.防止溢出，先减后加 2.用移位提高速度

```java
// 二分查找
public int search(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return -1;
}
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

#### ⭐在一个有序数组中，找 >=某个数最左侧（最右侧）的位置

！！！就看这个方法就行，别看网上那些题解，都是垃圾，这个最好理解

找 >=某个数  target 最左侧的位置：

1. 二分查找 nums[mid] = target,记录 当前位置为 mostL
2. 往左继续二分，查找 nums[mid] = target，
   - 如果 nums[mid]<target,则继续往右找，直到没有位置可找，那么最左侧的记录位置就是 >=某个数的最左位置

```java
public int[] searchRange(int[] nums, int target) {
    int[] res = new int[]{-1, -1};
    if (nums == null || nums.length == 0) {
        return res;
    }
    int l = 0, r = nums.length - 1, mostL = -1, mostR = -1;
    // 查找 等于 target 最左侧位置
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostL = mid;
            r = mid - 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    if (mostL == -1) {
        return res;
    }
    res[0] = mostL;
    l = mostL;
    r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostR = mid;
            l = mid + 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    res[1] = mostR;
    return res;
}
```

### [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

#### 拒绝采样问题

#### ⭐方法一：万能构造法：独立随机事件+古典概型

[1,X] 的随机数发生器 randX()  很明显是一个古典概型：它的结果是有限的，且每个结果的概率相同。
独立随机事件的概率：P(AB)=P(A)*P(B) 

那么任意的 randX() 都可以用以下方法构造：

1. 构造 n  次相互独立的采样，其中第 i  次采样有 $m_i$ 种结果，且第 i*i* 次采样中每种结果的概率是 $\frac{1}{m_i}$ 。n 要满足$m_1*m_2*\cdots*m_n\ge X$，即把所有采样结果组合起来，最终的结果数量不少于 X*，保证可以映射到 [1,X] 的每一个元素。*

   这样做的好处是，我们构造了 $m_1*m_2*\cdots*m_n$个结果，并且每个结果的概率都是 $\frac{1}{m_1*m_2*\cdots*m_n}$

2. 从 $m_1*m_2*\cdots*m_n$  个结果中取 X  个，映射到 [1,X]  区间，我们就得到了一个均匀分布在 [1,X]  的随机数发生器。

第二步中的映射是 1:1 映射，实际运用中，第二步可以取 k*X 个结果来做  k:1  映射，以减少调用 rand7()  次数



**rand7() 构造 rand10()**

1. 构造 2 次采样，分别有 2 和 5  种结果，组合起来便有 10 种概率相同的结果。
2. 把这 10  种结果映射到 [1,10]  即可。

第一步具体要如何构造采样是自由的，比如 rand7()  拒绝 7 ，然后对 [1,6] 采样，把奇数和偶数作为 2  种结果，这 2  种结果的概率均为 0.5 , rand7() 拒绝 6,7 ，然后对 [1,5]  采样，有 5  种结果，每种概率均为 0.2 

```java
public int rand10() {
    int rand1 = rand7();
    while (rand1 == 7) {
        rand1 = rand7();
    }
    int rand2 = rand7();
    while (rand2 > 5) {
        rand2 = rand7();
    }
    return (rand1 & 1) == 1 ? rand2 : 5 + rand2;
}
```

上述方法理论上可以构造任何范围的随机数发生器，比如

 rand11() ：

1. 构造 2  次采样，分别有 2   和 6  种结果，组合起来便有 12  种概率相同的结果。
2. 把这 12  种结果映射到 [1,12]，然后再拒绝 12  即可。

rand100()  ：

1. 构造 3  次采样，分别有 4,5,5  种结果，组合起来便有 100  种概率相同的结果。
2. 把这 100 种结果映射到 [1,100] 即可。

#### ⭐方法二：k 进制诸位生成 + 拒绝采样

每次执行 rand7 都可以看作一次独立事件。我们可以将两次 rand7 的结果看作生成 7  进制的两位。从而实现每个数值都唯一对应了一种随机值的组合（等概率），反之亦然。

举个🌰，设随机执行两次 `rand7` 得到的结果分别是 4 （第一次）、7 （第二次），由于我们是要 7  进制的数，因此可以先对 `rand7` 的执行结果进行 -1  操作，将输出域偏移到 [0, 6] （仍为等概率），即得到 3 （第一次）和 6（第二次），最终得到的是数值 $(63)_7$，数值 $(63)_7$  唯一对应了我们的随机值组合方案，反过来随机值组合方案也唯一对应一个 7  进制的数值。

**那么根据「进制转换」的相关知识，如果我们存在一个 `randK` 的函数，对其执行 n  次，我们能够等概率产生 [0, K^n - 1]  范围内的数值。**

回到本题，执行一次 `rand7` 只能产生 [0, 6]  范围内的数值，不足 10  个；而执行 2  次 `rand7` 的话则能产生 [0, 48] ] 范围内的数值，足够 10 个，且等概率。

我们只需要判定生成的值是否为题意的 [1, 10]  即可，如果是的话直接返回，否则一直重试。

```java
public int rand10() {
    int ans = -1;
    while (ans < 1 || ans > 10) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans;
}
```

#### ⭐方法二优化

**进阶**

1. 降低对 `rand7` 的调用次数

我们发现，在上述解法中，范围 [0, 48][0,48] 中，只有 [1, 10][1,10] 范围内的数据会被接受返回，其余情况均被拒绝重试。

为了尽可能少的调用 `rand7` 方法，我们可以从 [0, 48][0,48] 中取与 [1, 10][1,10] 成倍数关系的数，来进行转换。

我们可以取 [0, 48][0,48] 中的 [1, 40][1,40] 范围内的数来代指 [1, 10][1,10]。

首先在 [0, 48][0,48] 中取 [1, 40][1,40] 仍为等概率，其次形如 x1  的数值有 4  个（1 、11 、21 、31 ），形如 x2  的数值有 4  个（2 、12 、22 、32 ）... 因此最终结果仍为等概率。

```java
public int rand10() {
    int ans = -1;
    while (ans < 0 || ans > 40) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans % 10 + 1;
}
```

### [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

#### 方法一：动态规划

用 max 记录结果，temp记录当前的子数组和：

1. 往右遍历，更新temp：
   - 如果当前位置的值，大于temp，更新temp为 当前位置的值，否则 temp 累加 当前位置
2. 用temp更新 max

拓展：

1. 求最大子数组的范围：
   1. 在当前方法基础上新增变量 left和 right
   2. 如果当前位置的值，大于temp，更新left
   3. 如果temp大于 max，更新right

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = nums[0];
    int r = 1;
    while (r < nums.length) {
        if (nums[r] > nums[r] + temp) {
            temp = nums[r];
        } else {
            temp += nums[r];
        }
        ans = Math.max(ans, temp);
        r++;
    }
    return ans;
}
```

方法一优化

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = 0;
    for (int num : nums) {
        temp = Math.max(num, num + temp);
        ans = Math.max(ans, temp);
    }
    return ans;
}
```

#### 方法二 分治



### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### 方法一：哈希表

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0 || s.length() == 1) {
            return s.length();
        }
        int ans = 0, temp = 0;
        int l = 0, r = 0;
        Set<Character> set = new HashSet<>();
        while (r < s.length()) {
            if (!set.contains(s.charAt(r))) {
                set.add(s.charAt(r));
                temp++;
                r++;
                ans = Math.max(ans, temp);
            } else {
                set.remove(s.charAt(l));
                temp--;
                l++;
            }
        }
        return ans;
    }
}
```

#### 方法二：数组

```java
public int lengthOfLongestSubstring(String s) {
    if (s.length() == 0 || s.length() == 1) {
        return s.length();
    }
    int ans = 0, temp = 0;
    int l = 0, r = 0;
    int[] set = new int[150];
    while (r < s.length()) {
        if (set[s.charAt(r)] == 0) {
            set[s.charAt(r)] = 1;
            temp++;
            r++;
            ans = Math.max(ans, temp);
        } else {
            set[s.charAt(l)] = 0;
            temp--;
            l++;
        }
    }
    return ans;
}
```

#### 方法三：如果只包含字母的情况，可以用位运算来加速

### [395. 至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

#### ⭐⭐滑动窗口

**当确定了窗口内所包含的字符数量时，区间重新具有了二段性质**，这是本题的滑动窗口解法和迄今为止做的滑动窗口题目的最大不同，本题需要手动增加限制，即限制窗口内字符种类。

##### 点评

这道题的突破口分析其实和 1178. 猜字谜 类似。

解决思路：当我们采用常规的分析思路发现无法进行时，**要去关注一下数据范围中「数值小」的值。因为数值小其实是代表了「可枚举」，往往是解题或者降低复杂度的一个重要（甚至是唯一）的突破口。**

```java
// 方法一：滑动窗口
public int longestSubstring(String s, int k) {
    int ans = 0;
    int[] count = new int[26];
    int len = s.length();
    for (int kind = 1; kind <= 26; kind++) {// 允许出现的字符种类
        Arrays.fill(count, 0);
        for (int i = 0, j = 0, total = 0, vaild = 0; i < len; i++) {
            int idx = s.charAt(i) - 'a';
            count[idx]++;
            if (count[idx] == 1) {// 出现的字符种类加一
                total++;
            }
            if (count[idx] == k) {// 符合要求的字符种类加一
                vaild++;
            }
            while (total > kind) {// 当出现的字符种类超过限定的字符种类，左指针右移
                int n = s.charAt(j) - 'a';
                count[n]--;
                if (count[n] == 0) {// 出现的字符种类减少一
                    total--;
                }
                if (count[n] == k - 1) {// 符合要求的字符种类减少一
                    vaild--;
                }
                j++;
            }
            if (total == vaild) {
                ans = Math.max(ans, i - j + 1);
            }
        }
    }
    return ans;
}
```

#### ⭐⭐分治

对于出现任何一个出现次数 大于 0 小于 k 的字符 ch，包含该字符的任意子串都不可能符合要求，所以 以 字符 ch 分隔字符串，那么符合要求的最长子串一定出现在某个被分割的段内，因此可以用分治的方式求解此题。

```java
public int longestSubstring(String s, int k) {
    return longestSubstring(s, k, 0, s.length() - 1);
}

private int longestSubstring(String s, int k, int l, int r) {
    // 统计当前范围内各字符的出现次数
    int[] count = new int[26];
    for (int i = l; i <= r; i++) {
        count[s.charAt(i) - 'a']++;
    }
    // 查找 出现次数 大于 0 小于 k 的分割字符
    int split = 0;
    for (int i = l; i <= r; i++) {
        if (count[s.charAt(i) - 'a'] < k) {
            split = s.charAt(i);
            break;
        }
    }
    // 找不到分割字符，则该子串符合要求，直接返回
    if (split == 0) {
        return r - l + 1;
    }
    int ans = 0;
    int left = l;
    while (left <= r) {
        while (left <= r && s.charAt(left) == split) {
            left++;
        }
        if (left > r) {
            break;
        }
        int start = left;
        while (left <= r && s.charAt(left) != split) {
            left++;
        }
        int len = longestSubstring(s, k, start, left - 1);
        ans = Math.max(ans, len);
    }
    return ans;
}
```

### [460. LFU 缓存](https://leetcode-cn.com/problems/lfu-cache/)

**分析需要用到的数据结构：**

- $O(1)$ 时间复杂度的 存取 数据结构：hashMap

- $O(log^n)$ 时间复杂度的 排序数据结构：堆（Java 中的 PriorityQueue 默认就是小根堆）
  - 堆的增删操作是 $O(log^n)$，增删操作会自动调整堆，这个调整时间是$O(log^n)$
  - 堆排序的时间复杂度是$O(nlog^n)$，空间复杂度是 $O(1)$
  - 建堆的时间复杂度是 $O(n)$
- 增删 都是$O(1)$ 时间复杂度的 **有序**的数据结构：链表



#### ⭐时间复杂度 $O(n)$ 解法

- 使用小根堆排序（Java 中的 PriorityQueue 默认就是小根堆），找到访问次数最少的项
  - 访问次数 time **最小且最久未访问**的 项 上浮到堆顶
  - 对于访问次数相同的项，比较访问先后，这里用 全局自增的 idx 表示访问的先后

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * O(1)  get
 * O(logn) put
 */
class LFUCache {
    class Node implements Comparable<Node> {
        int key;
        int value;
        int time;// 访问次数
        int idx;// 访问时间

        public Node(int key, int value, int idx) {
            this.key = key;
            this.value = value;
            this.idx = idx;
            this.time = 1;
        }

        @Override
        public int compareTo(Node o) {
            int diff = this.time - o.time;
            return diff != 0 ? diff : this.idx - o.idx;
        }
    }

    Map<Integer, Node> map;// 负责存取
    PriorityQueue<Node> queue;// 负责排序
    int capacity;
    int idx;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        idx = 0;
        queue = new PriorityQueue<>();
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.time++;
            node.idx = idx++;
            queue.remove(node);
            queue.offer(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            node.time++;
            node.idx++;
            queue.remove(node);
            queue.offer(node);
            return;
        } else {
            if (capacity == 0) {
                return;
            }
            if (map.size() == capacity) {
                Node poll = queue.poll();
                map.remove(poll.key);
            }
            Node node = new Node(key, value, idx++);
            map.put(key, node);
            queue.offer(node);
        }
    }
}
```

#### ⭐时间复杂度$O(1)$解法（一） - 双 hashMap + LinkedHashSet

#### ⭐时间复杂度$O(1)$解法（二） -  双 hashMap + 自定义双向链表

**双 hashMap + 双向链表：**

- `Map<Integer, Node> cacheMap`存储缓存的内容
- `Map<Integer, DoubleLinkedList> freqMap` 按访问频次存储对应Node 的双向链表
- `minFreq` 记录最少访问次数

**分析：**

- **cacheMap** 确保了可以在 O(1) 内 查询（get)
- **frepMap** 与 minFreq 搭配使用，可以在 O(1) 内 获取 最低访问次数项所在的链表

- **双向链表** 确保了 相同访问次数下项的有序性，可以在 O(1) 内 头插入、尾删除 结点 
  - 每当新增项时，新增项头插入，**最久未使用** 的项 永远在 链表尾部

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

/**
 * O(1)解法
 */
class LFUCache {
    int capacity;// 容量
    int minFreq;// 最少访问次数
    Map<Integer, Node> cacheMap;// 存储缓存内容
    Map<Integer, DoubleLinkedList> freqMap;// 按频率存储对应的双向链表


    public LFUCache(int capacity) {
        this.capacity = capacity;
        cacheMap = new HashMap<>();
        freqMap = new HashMap<>();
    }

    public int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            refresh(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            node.value = value;
            refresh(node);
        } else {
            if (cacheMap.size() == capacity) {// 移除 最少访问次数且最久未使用的项
                DoubleLinkedList list = freqMap.get(minFreq);
                Node del = list.removeLast();
                if (list.isEmpty()) {
                    freqMap.remove(minFreq);
                }
                cacheMap.remove(del.key);
            }
            // 新增 项
            Node node = new Node(key, value);
            cacheMap.put(key, node);
            if (!freqMap.containsKey(1)) {
                freqMap.put(1, new DoubleLinkedList());
            }
            DoubleLinkedList list = freqMap.get(1);
            list.add(node);
            minFreq = 1;
        }
    }

    // 更新使用次数
    private void refresh(Node node) {
        DoubleLinkedList list = freqMap.get(node.freq);
        list.remove(node);
        if (list.isEmpty()) {// 移除空链表
            freqMap.remove(node.freq);
            if (minFreq == node.freq) {// 更新最少访问次数
                minFreq++;
            }
        }
        node.freq++;
        if (!freqMap.containsKey(node.freq)) {
            freqMap.put(node.freq, new DoubleLinkedList());
        }
        freqMap.get(node.freq).add(node);// 插入新结点
    }

}

// 自定义双链表
class DoubleLinkedList {
    Node head;
    Node tail;

    public DoubleLinkedList() {
        this.head = new Node(-1, -1);
        this.tail = new Node(-1, -1);
        head.next = tail;
        tail.pre = head;
    }

    // 头插入
    public void add(Node node) {
        node.pre = head;
        node.next = head.next;
        head.next = node;
        node.next.pre = node;
    }

    public void remove(Node node) {
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }

    // 尾删除
    public Node removeLast() {
        Node del = tail.pre;
        remove(del);
        return del;
    }

    public boolean isEmpty() {
        return head.next == tail;
    }
}

/**
 * 自定义结点类
 */
class Node {
    int key, value, freq;
    Node pre, next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
        this.freq = 1;
    }
}
```

#### ⭐最优解 - 时间复杂度$O(1)$解法（三） -  

[甜姨题解](https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/#o1-%E8%A7%A3%E6%B3%95-%E2%80%94%E2%80%94-%E5%AD%98%E5%82%A8%E9%A2%91%E6%AC%A1%E7%9A%84hashmap%E6%94%B9%E4%B8%BA%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%80%E4%BC%98%E5%AE%9E%E7%8E%B0-13ms-%E5%8F%8C100percent%EF%BC%89)



### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

- 时间复杂度：$O(log^n)$，在二分查找的过程中，每一步会忽略一半的区间

- 空间复杂度：$O(1)$

**分析：**

1. 最小值要么在左边，要么在右边
2. 如果 最小值不在右边，那么 `nums[mid] 一定 大于 nums[r]` ,否则，最小值在右边

```java
// 二分
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return nums[l];
}
```

### [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

**分析：**

- 当 `nums[mid] > nums[right]`时，mid  一定在 右边

- 当 `nums[mid] < nums[right]` 时，mid  一定在左边

- 当 `nums[mid] = nums[right]` 时，难以判断最小值区间， 解决方式：`right--;`

  证明：

  1. 此操作保证了数组不会越界，因为迭代条件：`l < r`
  2. 此操作保证了不会丢失最小值
     - 假设 nums[right]  是最小值，那就不可能有 `nums[mid] = nums[right]`

时间复杂度 $O(logN)$，在特例情况下会退化到 $O(N)$（例如 [1, 1, 1, 1]）

```java
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else if (nums[mid] > nums[r]) {
            l = mid + 1;
        } else {
            r--;
        }
    }
    return nums[l];
}
```

### [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

#### 遍历

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0;
    while (arr[l] < arr[l + 1]) {
        l++;
    }
    return l;
}
```

#### ⭐二分

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0, r = arr.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (arr[mid] < arr[mid + 1]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}
```

### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

**归并排序**

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int start1 = 0, start2 = 0, end1 = m - 1, end2 = n - 1;
    int[] result = new int[m + n];
    int idx = 0;
    while (start1 <= end1 && start2 <= end2) {
        if (nums1[start1] <= nums2[start2]) {
            result[idx++] = nums1[start1++];
        } else {
            result[idx++] = nums2[start2++];
        }
    }
    while (start1 <= end1) {
        result[idx++] = nums1[start1++];
    }
    while (start2 <= end2) {
        result[idx++] = nums2[start2++];
    }
    for (int i = 0; i < result.length; i++) {
        nums1[i] = result[i];
    }
}
```

### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

如果对时间复杂度的要求有 $\log$，通常都需要用到二分查找，这道题也可以通过二分查找实现

- 当两个有序数组长度之和为奇数的时候，中位数只有1个，将它返回
- 当两个有序数组长度之和为偶数的时候，中位数有两个，返回这两个数的平均数

#### 方法一 暴力求解

先合并两个有序数组，然后排序找到中位数

#### 方法二 归并排序

归并排序，合并有序数组

时间复杂度：$O(m+n)$

空间复杂度：$O(m+n)$

#### 方法三  二分查找

**整体思路**：只需要给出俩个有序数组的一个恰当的 **分割线**，中位数的值就由 位于这个 **分割线** 两侧的数决定

##### 在只有一个有序数组的时候

中位数：在只有一个有序数组的时候，中位数把数组分割成两个部分

- 当数组长度为偶数的时候，中位数有两个，其中一个是左边数组的最大值，另一个是右边数组的最小值

![image-20211222212403358](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127758.png)

- 当数组长度为奇数的时候，中位数只有1个，不妨把中位数分到左边数组

![image-20211222212431730](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127219.png)

##### 在有两个有序数组的时候

中位数：在有两个有序数组的时候，仍然可以把有序数组分割成两个部分

![image-20211222213559266](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222136540.png)

使用一条分割线把数组分别分割成两个部分：

1. 红线左边和右边的元素个数相等（两个有序数组长度之和为偶数），或左边元素个数比右边元素个数多一个（两个有序数组长度之和为奇数）
2. **红线左边的所有元素数值 <= 红线右边所有元素的数值**（**关键**，满足了这点，使得中位数**只与**分割线左右两侧的元素有关）

如果找到了符合这两点要求的分割线，那么就可以和只有一个有序数组的情况统一起来：

- 那么中位数就一定只与红线两侧的元素有关，确定这条红线的位置，需要使用二分查找。

**（一）当两个有序数组长度之和为奇数的时候**

​	当两个有序数组长度之和为奇数的时候，

- $Size_{left}  = Size_{right} + 1$

- 在满足 **红线左边的所有元素数值 <= 红线右边所有元素的数值** 的前提下，
  - 分割线左边元素的最大值就是数组的中位数
  - 由于两个数组都是有序数组，分割线左边 两个元素的较大者，就是中位数

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222148124.png" alt="image-20211222214827410" style="zoom:50%;" />

**（二）当两个有序数组长度之和为偶数的时候**

当两个有序数组长度之和为偶数的时候

- $Size_{left}  = Size_{right}$
- 在满足 **红线左边的所有元素数值 <= 红线右边所有元素的数值** 的前提下，
  - 分割线左边元素的最大值就是 其中一个中位数
  - 分割线右边元素的最小值就是 其中另一个中位数
  - 由于两个数组都是有序数组，
    - 分割线左边 两个元素的较大者，就是其中一个中位数
    - 分割线右边 两个元素的较小者，就是其中另一个中位数

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222155593.png" alt="image-20211222215458018" style="zoom:50%;" />

##### 其他细节问题

1. 没有必要分别去确定分割线在两个数组上的位置
   - 分割线左边，或则右边的元素个数是可以计算出来的，是一个确定的数

##### 分割线计算

**条件一：合并奇数偶数情况下，分割线位置的确定公式**

![image-20211222220516370](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222205185.png)

**条件二： 满足交叉小于等于关系** 

- 第一个数组在分割线左边的最大值 <= 第二个数组在分割线右边的最小值
- 第二个数组在分割线左边的最大值 <= 第一个数组在分割线右边的最小值



##### 不满足交叉小于等于关系的分割线位置调整

**情况一：**第二个数组分割线左边的最大值 大于 第一个数组分割线右边的最小值

- 调整方案：将中位数分割线在数组 1 的位置 右移

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112231657314.png" alt="image-20211222221932163" style="zoom:50%;" />

**情况二：**第一个数组分割线左边的最大值 大于 第二个数组分割线右边的最小值

- 调整方案：将中位数分割线在数组 1 的位置 左移

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222216455.png" alt="image-20211222221632023" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222215431.png" alt="image-20211222221557476" style="zoom:50%;" />

> **二分查找算法**就是在这样的尝试找到恰当的分割线的过程当中，不断地缩小搜索区间的范围，直到最终找到符合条件的分割线的位置



由于需要比较分割线两侧元素的大小关系，可能出现以下两类极端情况：

##### 极端情况

**第一类情况：**两数组长度不一致时

- 情况一：较短的数组在分割线的右边没有元素
- 情况二：较短的数组在分割线的左边没有元素

为了保证分割线在 较长的数组中 分割线两侧都有元素，因此应该在较短的数组上确定 分割线 的位置，**这样就不会 在访问数组时 出现 数组下标越界的情况**

![image-20211222222953628](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222229922.png)

**第二类情况：**两数组长度一样时

- 情况一：第一个数组在分割线的右边没有元素，并且第二个数组在分割线的左边没有元素
- 情况二：第一个数组在分割线的左边没有元素，并且第二个数组在分割线的右边没有元素

![image-20211222223152519](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222231600.png)

#### 算法描述

1. 交换较短的数组为 第一个数组，较长的数组为第二个数组

   - 这是 为了使得分割线在第二个数组的两侧都有元素，以保证不会出现访问数组下标越界的情况，以方便后续编码

2. 用 变量 m、n 分别保存 数组 num1 和 num2 的长度

3. 统计 分割线左边应该有的元素个数：` int totalLeft = (m+n+1)/2;`

   - 可能会发生整型溢出，解决方法：` int totalLeft = m + (n - m + 1)/2;`

4. 分割线二分查找过程

   1. 分割线定义

      - 分割线在第一个数组右边的第 1 个元素下标 i = 分割线在第一个数组左边的元素个数
      - 分割线在第二个数组右边的第 1 个元素下标 j = 分割线在第二个数组左边的元素个数
      - 根据之前的定义，i+j 满足 关系式：    $i+j = \frac{m+n+1}{2}$

      ![image-20211222224336317](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222243308.png)

   2. 分割线限制条件（交叉小于等于）

      -  `nums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]`

   3. 在 nums1 的区间 [0,m] 里查找恰当的分割线

5. 3

**总结：**

- 二分查找法思路：
  - 只需要给出俩个有序数组的一个恰当的 **分割线**，中位数的值就由 位于这个 **分割线** 两侧的数决定

#### 算法实现

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    // 交换较短数组到 nums1，方便后续编码
    if (nums1.length > nums2.length) {
        int[] temp = nums1;
        nums1 = nums2;
        nums2 = temp;
    }
    // 记录 数组长度
    int m = nums1.length;
    int n = nums2.length;
    // 统计分割线左边元素个数（让左边多一个元素)
    int sizeLeft = (m + n + 1) / 2;
    // 在较短的数组上采用二分查找 寻找分割线位置
    // 二分查找分割线位置,分割线需要满足的条件（交叉小于等于的关系）：nums1[i-1] <= nums2[j]&&nums2[j-1] <=nums1[i]
    int left = 0, right = m;
    while (left < right) {
        // 二分计算中间位置元素下标
        int i = left + ((right - left + 1) >> 1);// 分割线右边元素的下标，在第一个数组
        int j = sizeLeft - i;// 分割线右边的元素下标，在第二个数组
        if (nums1[i - 1] > nums2[j]) {// 分割线靠右，应左移
            right = i - 1;
        } else {
            // 在左边界为 left = i时,若数组中只有两个元素，则会进入死循环，
            // 解决方式：取中位数时加一，中位数=left + ((right - left + 1) >> 1)
            // 同时也保证了 i 不会取到 0 ,保证了 i-1>=0,即 nums1[i-1]不会越界
            left = i;
        }
    }
    int i = left;
    int j = sizeLeft - i; 
    int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
    int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
    int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
    int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
    if (((m + n) & 1) == 1) {// m+n 长度为奇数
        return Math.max(nums1LeftMax, nums2LeftMax);
    } else {
        return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
    }
}
```

另一种 二分条件下的二分查找

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 交换较小的数组为num1
        // 这是为了使得分割线在第二个数组的两侧都有元素，以保证不会出现访问数组下标越界的情况，以方便后续编码
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        // 用 变量 m、n 分别保存 数组 num1 和 num2 的长度
        int m = nums1.length;
        int n = nums2.length;
        // 统计 分割线左边应该有的元素个数
        int totalLeft = (m + n + 1) / 2;
        // 分割线限制条件(交叉小于等于)：nums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]
        // 在 nums1 的区间 [0,m] 里查找恰当的分割线
        int left = 0, right = m;
        // 二分查找,确定分割线在第一个数组右边的元素下标
        while (left < right) {
//            int i = left + ((right - left + 1) >> 1);// 分割线,+1保证了 i大于零，即 i-1>=0,即保证了nums1数组下标不越界
            int i = left + ((right - left) >> 1);// 分割线,+1保证了 i大于零，即 i-1>=0,即保证了nums1数组下标不越界
            int j = totalLeft - i;
//            // 第一个数组在分割线左边的元素数值大于第二个数组在分割线右边的元素数值，证明分割线在第一个数组上的位置太靠右，应左移
//            // 也可以根据另一个条件取反
//            if (nums1[i - 1] > nums2[j]) {
//                // 下一轮的搜索区间 [left,i-1]
//                right = i - 1;
//            } else {
//                // 下一轮的搜索区间 [i,right]
//                left = i;
//            }
            if (nums2[j - 1] > nums1[i]) {
                // 下一轮的搜索区间 [i+1,right]
                left = i + 1;// i+1,那么取中位数时不需要向上取整
            } else {
                // 下一轮的搜索区间 [left,i]
                right = i;
            }
        }
        int i = left;
        int j = totalLeft - i;
        // 分割线左右两侧元素值
        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
        if ((m + n) % 2 == 1) {// 数组长度之和为奇数
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
        }
    }
```

#### 时间复杂度

时间复杂度：$O(log^{min(m,n)})$

空间复杂度：$O(1)$

#### 总结

二分查找逐渐缩小目标元素区间

### [补充题6. 手撕堆排序](https://leetcode-cn.com/problems/sort-an-array)

```java
// 堆排序
public int[] heapSort(int[] nums) {
    buildMaxHeap(nums);// 初始化大顶堆
    // 堆排序，每次循环把堆顶元素与堆尾结点交换，同时堆长度-1
    for (int i = nums.length - 1; i >= 0; i--) {
        swap(nums, 0, i);// 交换堆顶与堆尾元素
        maxHeapFix(nums, 0, i);
    }
    return nums;
}

/**
 * 构建初始大顶堆，从最后一个非叶子结点开始，叶子结点可视为符合堆要求的结点
 *
 * @param nums
 */
private void buildMaxHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

/**
 * 调整大顶堆
 *
 * @param nums
 * @param idx      需要调整的堆元素结点
 * @param heapSize 需要调整的堆的长度
 */
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx <= heapSize / 2 - 1) {// 当目标结点是非叶子结点才进入循环
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

#### 方法一:hashSet

用hashSet记录走过的结点，如果再次经过，则有环

#### 方法二：标记法

`-105 <= Node.val <= 105`，标记已走过的结点值为 Integer.MAX_VALUE,若遇到 Node.val = Integer.MAX_VALUE，则有环

#### 方法三：快慢指针法

快慢指针同时走，相遇，则存在环

```java
// 快慢指针
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

#### 快慢指针

**当 快指针每次走两步，慢指针每次走一步**

假设起点到 环入口距离为 m，环长为 n，第一次相遇时距离环入口距离为 k

结论：

1. 设一个慢指针，一个快指针，若有环快慢指针必会相遇。
   - 这个不需多言，由于快指针比慢指针每次多走一步，存在环的话，必定相遇。
2. 两指针在环中第一次相遇的时候，慢指针一定只走了一次 m+k ,而不会多走一圈
3. 将快指针重新移动到链表开头，并让快慢指针每次都前进一步。当快慢指针第二次相遇时，相遇的节点即为环路的开始点。

证明：

- 关于快慢指针第一次相遇，慢指针一定只走了 m+k ,而不会多走一圈的证明
  1. 由于快指针先入环，当慢指针入环时，快指针一定在环中某个位置，设（顺时针）距离环入口 走过的距离为 p
  2. 一定有 0<= p <= n
  3. 因为 快指针每次比慢指针多走一步，也就是说 快指针只需走 n-p 步就可以追上 慢指针，而慢指针还要走 n 步才能走完第一次环，**所以必定会在慢指针的第一次环内 快指针就追上慢指针，即该两点相遇**
- 关于两指针第二次相遇时，相遇的节点即为环的开始点的证明
  1. 当两指针第一次相遇时，slow走过距离：m+k, fast走过距离：m+k+An(A代表圈数，A>=1)
  2. 由于fast的速度是slow的两倍，所以有: $(m+k)*2 = m+k+An$，得到：$m+k = An$，设 $n-k = y$, 那么有：$m = (A-1)n + y$
  3. 也就是说此时，把fast指针移回链表起点，速度变为和slow一样,那么slow和fast再次相遇的结点必然是环起点，只是 A 的不同会影响从第一次相遇点出发的slow结点多走的环圈数

**当 快指针每次走三步，慢指针每次走一步**

- 同样有第一次相遇时： $k = y/2$

- 将快指针重新移动到链表开头，并让快慢指针每次都前进一步，第二次相遇：$m = (A-1)n + y$



**代码实现**

```java
// 快慢指针
public ListNode detectCycle(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            break;
        }
    }
    if (fast == null || fast.next == null) {
        return null;
    }
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```

### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**斐波那契数列**常见方法： 1.动态规划、 2.递推（动态规划空间优化）、 3.矩阵快速幂、 4.通项公式

#### 递归

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    int count = 0;
    count += climbStairs(n - 1);
    count += climbStairs(n - 2);
    return count;
}
```

#### DP

$f(x) = f(x - 1) + f(x - 2)$

```java
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int m = 2; m <= n; m++) {
        dp[m] = dp[m - 1] + dp[m - 2];
    }
    return dp[n];
}
```

```java
public int climbStairs(int n) {
    int a = 1, b = 1, temp = 0;
    for (int m = 2; m <= n; m++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
```

#### 拓展：不能爬到7及7的倍数

```java
if (m % 7 == 0) {
    continue;
}
```

### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

#### 方法一：堆排 大顶堆

**时间复杂度：**$O(max(n,k*log^n))$

```java
// 大顶堆
public int findKthLargest(int[] nums, int k) {
    buildHeap(nums);
    int heapSize = nums.length;
    for (int i = 1; i < k; i++) {
        nums[0] = Integer.MIN_VALUE;
        maxHeapFix(nums, 0, heapSize);
    }
    return nums[0];
}

// 初始化大顶堆
private void buildHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

// 调整大顶堆
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx < heapSize / 2) {
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### 方法二：堆排 小顶堆

**时间复杂度：**$O(n*log^k)$

#### 方法三：快排

**时间复杂度：**$O(n*log^n)$

#### 方法四：快排 partition

**时间复杂度：**$O(n)$

```java
public int findKthLargest(int[] nums, int k) {
    return findKthLargest(nums, nums.length-k, 0, nums.length - 1);
}

// 在 nums[L...R] 范围，找排序后 位于 index位置的数
public int findKthLargest(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = nums[L + (int) (Math.random() * (R - L + 1))];
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return findKthLargest(nums, k, L, range[0] - 1);
    } else {
        return findKthLargest(nums, k, range[1] + 1, R);
    }
}

// 返回 等于区域的左右边界
private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;// 小于区域的右边界
    int more = R + 1;// 大于区域的左边界
    int idx = L;// 当前数
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, idx, --more);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### 方法五：BFPRT

**时间复杂度：** $O(n)$

```java
// nums[L...R] 返回在有序情况下的位于k位置的数
public int bfprt(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = medianOfMedians(nums, L, R);// 获得 nums[L...R] 区间内中位数的中位数
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return bfprt(nums, k, L, range[0] - 1);
    } else {
        return bfprt(nums, k, range[1] + 1, R);
    }
}

// nums[L...R] 每5个数一组
// 每组数 组内排序
// 用每组的中位数组成中位数数组 M
// 返回中位数数组的中位数 m
private int medianOfMedians(int[] nums, int L, int R) {
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] M = new int[size / 5 + offset];// 中位数数组
    for (int team = 0; team < M.length; team++) {
        int teamFirst = L + team * 5;// 每组的第一个元素下标
        M[team] = getMedian(nums, teamFirst, Math.min(R, teamFirst + 4));
    }
    return bfprt(M, M.length / 2, 0, M.length - 1);
}

private int getMedian(int[] nums, int teamFirst, int teamLast) {
    insertionSort(nums, teamFirst, teamLast);
    return nums[(teamLast + teamFirst) / 2];
}

private void insertionSort(int[] nums, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        int temp = nums[i];
        for (int j = i; j >= L; j--) {
            if (j > L && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
}

private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;
    int more = R + 1;
    int idx = L;
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

时间复杂度：$O(n)$

**算法思路：**

1. 设一个虚拟头dummy 结点指向head
2. 设一个指针 preTail 为前一个组的尾节点
3. cur指针指向当前遍历到的位置
4. 从当前结点cur开始统计够 k 个结点，翻转一次，并用preTail指向翻转后的头结点
5. 更新 preTail
6. 返回 dummy的下一个结点

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode preTail = dummy;// 前一组反转后的尾结点
    ListNode cur = head;
    while (cur != null) {
        ListNode curHead = cur;
        int count = 0;
        for (int i = 0; i < k; i++) {
            count++;
            cur = cur.next;
            if (cur == null) {
                break;
            }
        }
        if (count == k) {// 找到一组满编的链表段
            ListNode newCurHead = reverseListNode(curHead, k);
            preTail.next = newCurHead;
            preTail = curHead;
        } else {
            preTail.next = curHead;
        }
    }
    return dummy.next;
}

private ListNode reverseListNode(ListNode head, int k) {
    ListNode pre = null, cur = head, temp = null;
    while (k-- > 0) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

#### 方法一：暴力枚举

时间复杂度：$O(n^3)$

```java
// 方法一：暴力枚举
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (isPalindrome(chars, i, j) && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}

private boolean isPalindrome(char[] chars, int i, int j) {
    while (i < j) {
        if (chars[i++] != chars[j--]) {
            return false;
        }
    }
    return true;
}
```

#### 方法二：中心扩散法

时间复杂度：$O(n^2)$

枚举的中心位置的个数是 $2(n-1)$, 每次向两边扩散检测是否回文

```java
// 方法二：中心扩散
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    int maxLen = 1;
    int begin = 0;
    char[] chars = s.toCharArray();
    for (int idx = 0; idx < chars.length - 1; idx++) {
        int oddLen = palindromeLen(chars, idx, idx);
        int evenLen = palindromeLen(chars, idx, idx + 1);
        if (oddLen > maxLen || evenLen > maxLen) {
            maxLen = Math.max(oddLen, evenLen);
            begin = idx - ((maxLen + 1) >> 1) + 1;// 回文串奇偶长度统一处理
        }
    }
    return s.substring(begin, begin + maxLen);
}

// 返回以 left、right为回文中心的回文串的长度
private int palindromeLen(char[] chars, int left, int right) {
    while (left >= 0 && right < chars.length && chars[left] == chars[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

#### 方法三：动态规划

时间复杂度：$O(n^2)$

回文串天然具有状态转移性质，方法一中有对 是否回文的重复判断，使用dp二维表记录判断结果，减少重复判断，空间换时间，记忆化搜索

```java
// 方法三：动态规划
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] palindrome = isPalindrome(chars);
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (palindrome[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}


private boolean[][] isPalindrome(char[] chars) {
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }
    }
    return dp;
}
```

**优化**

```java
// 方法三：动态规划
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
            // 当前子串是回文，更新最长回文记录信息
            if (dp[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}
```

#### 方法四：Manacher

时间复杂度：$O(n)$
