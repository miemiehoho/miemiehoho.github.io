### [146. LRU ç¼“å­˜æœºåˆ¶](https://leetcode-cn.com/problems/lru-cache/)

#### ç¼“å­˜ç½®æ¢ç­–ç•¥ï¼ˆç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼‰

ä¸»å­˜å®¹é‡è¿œå¤§äºCPUç¼“å­˜ï¼Œç£ç›˜å®¹é‡è¿œå¤§äºä¸»å­˜ï¼Œå› æ­¤æ— è®ºæ˜¯å“ªä¸€å±‚æ¬¡çš„ç¼“å­˜éƒ½é¢ä¸´ä¸€ä¸ªåŒæ ·çš„é—®é¢˜ï¼šå½“å®¹é‡æœ‰é™çš„ç¼“å­˜çš„ç©ºé—²ç©ºé—´å…¨éƒ¨ç”¨å®Œåï¼Œåˆæœ‰æ–°çš„å†…å®¹éœ€è¦æ·»åŠ è¿›ç¼“å­˜æ—¶ï¼Œå¦‚ä½•æŒ‘é€‰å¹¶èˆå¼ƒåŸæœ‰çš„éƒ¨åˆ†å†…å®¹ï¼Œä»è€Œè…¾å‡ºç©ºé—´æ”¾å…¥è¿™äº›æ–°çš„å†…å®¹ã€‚



è§£å†³è¿™ä¸ªé—®é¢˜çš„ç®—æ³•æœ‰å‡ ç§ï¼Œå¦‚ï¼š

- æœ€ä¹…æœªä½¿ç”¨ç®—æ³•ï¼ˆLFUï¼‰
  - æŒ‰è®¿é—®é¢‘ç‡æ¥æ·˜æ±°
- å…ˆè¿›å…ˆå‡ºç®—æ³•ï¼ˆFIFOï¼‰
- æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³•ï¼ˆLRUï¼‰
  - æŒ‰è®¿é—®æ—¶åºæ¥æ·˜æ±°
- éæœ€è¿‘ä½¿ç”¨ç®—æ³•ï¼ˆNMRUï¼‰ç­‰ï¼Œ

è¿™äº›ç®—æ³•åœ¨ä¸åŒå±‚æ¬¡çš„ç¼“å­˜ä¸Šæ‰§è¡Œæ—¶æ‹¥æœ‰ä¸åŒçš„æ•ˆç‡å’Œä»£ä»·ï¼Œéœ€æ ¹æ®å…·ä½“åœºåˆé€‰æ‹©æœ€åˆé€‚çš„ä¸€ç§ã€‚



#### LRUåŸç†

LRUçš„è®¾è®¡åŸç†å°±æ˜¯ï¼Œå½“æ•°æ®åœ¨æœ€è¿‘ä¸€æ®µæ—¶é—´ç»å¸¸è¢«è®¿é—®ï¼Œé‚£ä¹ˆå®ƒåœ¨ä»¥åä¹Ÿä¼šç»å¸¸è¢«è®¿é—®ã€‚è¿™å°±æ„å‘³ç€ï¼Œå¦‚æœç»å¸¸è®¿é—®çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿå¿«é€Ÿå‘½ä¸­ï¼Œè€Œä¸å¸¸è®¿é—®çš„æ•°æ®ï¼Œæˆ‘ä»¬åœ¨å®¹é‡è¶…å‡ºé™åˆ¶åï¼Œè¦å°†å…¶æ·˜æ±°ã€‚

LRU çš„å…¨ç§°æ˜¯ Least Recently Usedï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è®¤ä¸ºæœ€è¿‘ä½¿ç”¨è¿‡çš„æ•°æ®åº”è¯¥æ˜¯æ˜¯ã€Œæœ‰ç”¨çš„ã€ï¼Œå¾ˆä¹…éƒ½æ²¡ç”¨è¿‡çš„æ•°æ®åº”è¯¥æ˜¯æ— ç”¨çš„ï¼Œå†…å­˜æ»¡äº†å°±ä¼˜å…ˆåˆ é‚£äº›å¾ˆä¹…æ²¡ç”¨è¿‡çš„æ•°æ®ã€‚

**å®ä¾‹ï¼š**

å®‰å“æ‰‹æœºåå°è¿è¡Œçš„æ’åºè§„åˆ™ï¼Œæœ€è¿‘ä½¿ç”¨çš„åº”ç”¨æ’åœ¨å‰é¢ï¼Œç³»ç»Ÿä¼šæ€æ­»æ’åºæœ€æœ«å°¾çš„åº”ç”¨ï¼Œä¸ºæ–°åº”ç”¨è…¾å‡ºç©ºé—´



#### LRU ç®—æ³•æè¿°

LRU ç®—æ³•å®é™…ä¸Šæ˜¯è®©ä½ è®¾è®¡æ•°æ®ç»“æ„ï¼šé¦–å…ˆè¦æ¥æ”¶ä¸€ä¸ª capacity å‚æ•°ä½œä¸ºç¼“å­˜çš„æœ€å¤§å®¹é‡ï¼Œç„¶åå®ç°ä¸¤ä¸ª APIï¼Œä¸€ä¸ªæ˜¯ put(key, val) æ–¹æ³•å­˜å…¥é”®å€¼å¯¹ï¼Œå¦ä¸€ä¸ªæ˜¯ get(key) æ–¹æ³•è·å– key å¯¹åº”çš„ valï¼Œå¦‚æœ key ä¸å­˜åœ¨åˆ™è¿”å› -1ã€‚æ³¨æ„ï¼Œget å’Œ put æ–¹æ³•å¿…é¡»éƒ½æ˜¯ O(1) çš„æ—¶é—´å¤æ‚åº¦ã€‚

##### ä¸¾ä¾‹å­

å¯ä»¥é€šè¿‡ ğŸŒ° æ¥ç†è§£ï¼Œå‡è®¾æˆ‘ä»¬æœ‰å®¹é‡ä¸º 2 çš„ LRUCache å’Œ æµ‹è¯•é”®å€¼å¯¹ [1-1,2-2,3-3] ï¼Œå°†å…¶æŒ‰ç…§é¡ºåºè¿›è¡Œæ’å…¥ & æŸ¥è¯¢ï¼š

æ’å…¥ 1-1ï¼Œæ­¤æ—¶æœ€æ–°çš„ä½¿ç”¨æ•°æ®ä¸º 1-1
æ’å…¥ 2-2ï¼Œæ­¤æ—¶æœ€æ–°ä½¿ç”¨æ•°æ®å˜ä¸º 2-2
æŸ¥è¯¢ 1-1ï¼Œæ­¤æ—¶æœ€æ–°ä½¿ç”¨æ•°æ®ä¸º 1-1
æ’å…¥ 3-3ï¼Œç”±äºå®¹å™¨å·²ç»è¾¾åˆ°å®¹é‡ï¼Œéœ€è¦å…ˆæ·˜æ±°å·²æœ‰æ•°æ®æ‰èƒ½æ’å…¥ï¼Œè¿™æ—¶å€™ä¼šæ·˜æ±° 2-2ï¼Œ3-3 æˆä¸ºæœ€æ–°ä½¿ç”¨æ•°æ®

é”®å€¼å¯¹å­˜å‚¨æ–¹é¢ï¼š

- æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€æ¥ç¡®ä¿æ’å…¥å’ŒæŸ¥è¯¢çš„å¤æ‚åº¦ä¸º O(1)ï¼›

- å¦å¤–æˆ‘ä»¬è¿˜éœ€è¦é¢å¤–ç»´æŠ¤ä¸€ä¸ªã€Œä½¿ç”¨é¡ºåºã€åºåˆ—ï¼Œ
  - æˆ‘ä»¬æœŸæœ›å½“ã€Œæ–°æ•°æ®è¢«æ’å…¥ã€æˆ–ã€Œå‘ç”Ÿé”®å€¼å¯¹æŸ¥è¯¢ã€æ—¶ï¼Œèƒ½å¤Ÿå°†å½“å‰é”®å€¼å¯¹æ”¾åˆ°åºåˆ—å¤´éƒ¨ï¼Œè¿™æ ·å½“è§¦å‘ LRU æ·˜æ±°æ—¶ï¼Œåªéœ€è¦ä»åºåˆ—å°¾éƒ¨è¿›è¡Œæ•°æ®åˆ é™¤å³å¯ã€‚
  - æœŸæœ›åœ¨ O(1) å¤æ‚åº¦å†…è°ƒæ•´æŸä¸ªèŠ‚ç‚¹åœ¨åºåˆ—ä¸­çš„ä½ç½®ï¼Œå¾ˆè‡ªç„¶æƒ³åˆ°åŒå‘é“¾è¡¨ã€‚

##### å…·ä½“åˆ†æ

å…·ä½“çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œè¡¨æ¥å­˜å‚¨ã€Œé”®å€¼å¯¹ã€ï¼Œé”®å€¼å¯¹çš„é”®ä½œä¸ºå“ˆå¸Œè¡¨çš„ Keyï¼Œè€Œå“ˆå¸Œè¡¨çš„ Value åˆ™ä½¿ç”¨æˆ‘ä»¬è‡ªå·±å°è£…çš„ `Node` ç±»ï¼Œ`Node` åŒæ—¶ä½œä¸ºåŒå‘é“¾è¡¨çš„èŠ‚ç‚¹ã€‚

- æ’å…¥ï¼šæ£€æŸ¥å½“å‰é”®å€¼å¯¹æ˜¯å¦å·²ç»å­˜åœ¨äºå“ˆå¸Œè¡¨ï¼š
  - å¦‚æœå­˜åœ¨ï¼Œåˆ™æ›´æ–°é”®å€¼å¯¹ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
  - å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™æ£€æŸ¥å“ˆå¸Œè¡¨å®¹é‡æ˜¯å¦å·²ç»è¾¾åˆ°å®¹é‡ï¼š
    - æ²¡è¾¾åˆ°å®¹é‡ï¼šæ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
    - å·²è¾¾åˆ°å®¹é‡ï¼šå…ˆä»é“¾è¡¨å°¾éƒ¨æ‰¾åˆ°å¾…åˆ é™¤å…ƒç´ è¿›è¡Œåˆ é™¤ï¼ˆdelete æ“ä½œï¼‰ï¼Œç„¶åå†æ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰
- æŸ¥è¯¢ï¼š
  - å¦‚æœæ²¡åœ¨å“ˆå¸Œè¡¨ä¸­æ‰¾åˆ°è¯¥ Keyï¼Œç›´æ¥è¿”å› -1âˆ’1ï¼›
  - å¦‚æœå­˜åœ¨è¯¥ Keyï¼Œåˆ™å°†å¯¹åº”çš„å€¼è¿”å›ï¼Œå¹¶å°†å½“å‰é”®å€¼å¯¹æ‰€å¯¹åº”çš„ Node èŠ‚ç‚¹è°ƒæ•´åˆ°é“¾è¡¨å¤´éƒ¨ï¼ˆrefresh æ“ä½œï¼‰

ä¸€äº›ç»†èŠ‚ï¼š

- ä¸ºäº†å‡å°‘åŒå‘é“¾è¡¨å·¦å³èŠ‚ç‚¹çš„ã€Œåˆ¤ç©ºã€æ“ä½œï¼Œæˆ‘ä»¬é¢„å…ˆå»ºç«‹ä¸¤ä¸ªã€Œå“¨å…µã€èŠ‚ç‚¹ `head` å’Œ `tail`

#### â­ç®—æ³•å®ç°

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

class LRUCache {

    class Node {
        int k, v;
        Node l, r;

        public Node(int k, int v) {
            this.k = k;
            this.v = v;
        }
    }

    int capacity;
    Map<Integer, Node> map;
    Node head, tail;    // å“¨å…µç»“ç‚¹

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.r = tail;
        tail.l = head;
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            refresh(cur);
            return cur.v;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node cur = map.get(key);
            cur.v = value;
        } else {
            if (capacity == map.size()) {
                Node del = tail.l;
                remove(del);
                map.remove(del.k);
            }
            Node node = new Node(key, value);
            map.put(key, node);
        }
        refresh(map.get(key));
    }

    /**
     * 1.å…ˆåˆ é™¤ curç»“ç‚¹ï¼ˆå¦‚æœå­˜åœ¨çš„è¯ï¼‰
     * 2.å°†å½“å‰ç»“ç‚¹æ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨
     *
     * @param cur
     */
    private void refresh(Node cur) {
        remove(cur);
        cur.l = head;
        cur.r = head.r;
        head.r = cur;
        cur.r.l = cur;
    }

    /**
     * å› ä¸ºå¤´éƒ¨å­˜åœ¨å“¨å…µç»“ç‚¹ï¼Œæ‰€ä»¥å¦‚æœcur.l!=nullï¼Œåˆ™è¯æ˜curå­˜åœ¨äºåŒé“¾è¡¨ä¸­
     *
     * @param del
     */
    private void remove(Node del) {
        if (del.l != null) {
            del.l.r = del.r;
            del.r.l = del.l;
        }
    }
}
```

### [206. åè½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
// åŒæŒ‡é’ˆ
public ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head, temp = null;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)

```java
// å¿«æ’
public int[] sortArray(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
    return nums;
}

private void quickSort(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }
    int rand = (int) (Math.random() * (end - start + 1)) + start;
    swap(nums, start, rand);
    int pivot = nums[start];
    int l = start, r = end;
    while (l < r) {
        while (l < r && nums[r] >= pivot) {
            r--;
        }
        while (l < r && nums[l] <= pivot) {
            l++;
        }
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, l);
    quickSort(nums, start, l - 1);
    quickSort(nums, l + 1, end);
}

private void swap(int[] nums, int l, int r) {
    if (nums[l] != nums[r]) {
        nums[r] ^= nums[l];
        nums[l] ^= nums[r];
        nums[r] ^= nums[l];
    }
}
```

### [21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

æ—¶é—´å¤æ‚åº¦ $O(m+n)$

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    if (list1 == null) {
        return list2;
    }
    if (list2 == null) {
        return list1;
    }
    if (list1.val <= list2.val) {
        list1.next = mergeTwoLists(list1.next, list2);
        return list1;
    }
    list2.next = mergeTwoLists(list1, list2.next);
    return list2;
}
```

### [23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

#### â­**å½’å¹¶æ³•**

æ—¶é—´å¤æ‚åº¦ï¼š$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    return mergeList(lists, 0, lists.length - 1);
}

private ListNode mergeList(ListNode[] lists, int start, int end) {
    if (start == end) {
        return lists[start];
    }
    int mid = (start + end) >> 1;
    ListNode list1 = mergeList(lists, start, mid);
    ListNode list2 = mergeList(lists, mid + 1, end);
    return merge(list1, list2);
}

private ListNode merge(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = merge(l1.next, l2);
        return l1;
    }
    l2.next = merge(l1, l2.next);
    return l2;
}
```

#### â­**å°æ ¹å †**

æ—¶é—´å¤æ‚åº¦ï¼š$O(kn*log^k)$

```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) {
        return null;
    }
    PriorityQueue<ListNode> queue = new PriorityQueue<>((l1, l2) -> l1.val - l2.val);
    for (int i = 0; i < lists.length; i++) {
        queue.offer(lists[i]);
    }
    ListNode dummy = new ListNode();
    ListNode res = dummy;
    while (!queue.isEmpty()) {
        ListNode list = queue.poll();
        res.next = list;
        res = res.next;
        if (res.next != null) {
            queue.offer(res.next);
        }
    }
    return dummy.next;
}
```

### [8. å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)

ç®—æ³•æ€è·¯ï¼š

1. å»æ‰å‰å¯¼ç©ºæ ¼
2. å†æ˜¯å¤„ç†æ­£è´Ÿå·
3. è¯†åˆ«æ•°å­—ï¼Œæ³¨æ„è¶Šç•Œæƒ…å†µ

```java
public int myAtoi(String s) {
    int idx = 0;
    while (idx < s.length() && s.charAt(idx) == ' ') {// ç§»é™¤å‰å¯¼ç©ºæ ¼
        idx++;
    }
    if (idx == s.length()) {
        return 0;
    }

    int result = 0;
    boolean negative = false;
    if (s.charAt(idx) == '-') {
        negative = true;
        idx++;
    } else if (s.charAt(idx) == '+') {
        idx++;
    }
    for (int i = idx; i < s.length() && Character.isDigit(s.charAt(i)); i++) {
        int digit = s.charAt(i) - '0';
        if ((Integer.MAX_VALUE - digit) / 10 < result) {
            return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        result = result * 10 + digit;
    }
    return negative ? -result : result;
}
```

### [234. å›æ–‡é“¾è¡¨](https://leetcode-cn.com/problems/palindrome-linked-list/)

```java
// æ–¹æ³•ä¸€ï¼šç¿»è½¬é“¾è¡¨ååˆ¤æ–­æ˜¯å¦å’ŒåŸé“¾è¡¨ç›¸åŒ
public boolean isPalindrome(ListNode head) {
    ListNode reserveList = reserve(head);
    while (head != null) {
        if (head.val != reserveList.val) {
            return false;
        }
        head = head.next;
        reserveList = reserveList.next;
    }
    return true;
}

private ListNode reserve(ListNode head) {
    ListNode pre = null, cur = head, res = null;
    while (cur != null) {
        res = new ListNode(cur.val, res);
        cur = cur.next;
    }
    return res;
}
```

```java
// æ–¹æ³•äºŒï¼šåŒç«¯é˜Ÿåˆ—
public boolean isPalindrome(ListNode head) {
    Deque<Integer> deque = new LinkedList<>();
    while (head != null) {
        deque.offerLast(head.val);
        head = head.next;
    }
    while (!deque.isEmpty() && deque.size() > 1) {
        if (deque.pollFirst() != deque.pollLast()) {
            return false;
        }
    }
    return true;
}
```

```java
// æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œç¿»è½¬ååŠéƒ¨åˆ†é“¾è¡¨ç„¶åä¸å‰åŠéƒ¨åˆ†æ¯”è¾ƒ
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    // å¯»æ‰¾ä¸­é—´ç»“ç‚¹
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    if (fast != null) {
        slow = slow.next;
    }
    slow = reserve(slow);
    while (slow != null) {
        if (slow.val != head.val) {
            return false;
        }
        slow = slow.next;
        head = head.next;
    }
    return true;
}

private ListNode reserve(ListNode node) {
    ListNode pre = null, temp = null, cur = node;
    while (cur != null) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

#### â­**æ–¹æ³•ä¸‰ä¼˜åŒ–**

ä¼˜åŒ–ï¼šåœ¨å¿«æ…¢æŒ‡é’ˆå¯»æ‰¾ä¸­é—´ç»“ç‚¹è¿‡ç¨‹ï¼Œé¡ºä¾¿ç¿»è½¬å‰åŠéƒ¨åˆ†é“¾è¡¨

```java
// æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆï¼Œåœ¨å¿«æ…¢æŒ‡é’ˆå¯»æ‰¾ä¸­é—´ç»“ç‚¹è¿‡ç¨‹ï¼Œé¡ºä¾¿ç¿»è½¬å‰åŠéƒ¨åˆ†é“¾è¡¨
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head, firstNode = head, pre = null;
    while (fast != null && fast.next != null) {
        fast = fast.next;
        slow = slow.next;
        firstNode.next = pre;
        pre = firstNode;
        firstNode = slow;
    }
    if (fast != null) {
        slow = slow.next;
    }
    while (slow != null) {
        if (slow.val != pre.val) {
            return false;
        }
        pre = pre.next;
        slow = slow.next;
    }
    return true;
}
```

### [704. äºŒåˆ†æŸ¥æ‰¾](https://leetcode-cn.com/problems/binary-search/)

#### â­å·¦å³é—­åŒºé—´å†™æ³•

æ±‚ä¸­é—´æ•° 1.é˜²æ­¢æº¢å‡ºï¼Œå…ˆå‡ååŠ  2.ç”¨ç§»ä½æé«˜é€Ÿåº¦

```java
// äºŒåˆ†æŸ¥æ‰¾
public int search(int[] nums, int target) {
    int l = 0, r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return -1;
}
```

### [34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

#### â­åœ¨ä¸€ä¸ªæœ‰åºæ•°ç»„ä¸­ï¼Œæ‰¾ >=æŸä¸ªæ•°æœ€å·¦ä¾§ï¼ˆæœ€å³ä¾§ï¼‰çš„ä½ç½®

ï¼ï¼ï¼å°±çœ‹è¿™ä¸ªæ–¹æ³•å°±è¡Œï¼Œåˆ«çœ‹ç½‘ä¸Šé‚£äº›é¢˜è§£ï¼Œéƒ½æ˜¯åƒåœ¾ï¼Œè¿™ä¸ªæœ€å¥½ç†è§£

æ‰¾ >=æŸä¸ªæ•°  target æœ€å·¦ä¾§çš„ä½ç½®ï¼š

1. äºŒåˆ†æŸ¥æ‰¾ nums[mid] = target,è®°å½• å½“å‰ä½ç½®ä¸º mostL
2. å¾€å·¦ç»§ç»­äºŒåˆ†ï¼ŒæŸ¥æ‰¾ nums[mid] = targetï¼Œ
   - å¦‚æœ nums[mid]<target,åˆ™ç»§ç»­å¾€å³æ‰¾ï¼Œç›´åˆ°æ²¡æœ‰ä½ç½®å¯æ‰¾ï¼Œé‚£ä¹ˆæœ€å·¦ä¾§çš„è®°å½•ä½ç½®å°±æ˜¯ >=æŸä¸ªæ•°çš„æœ€å·¦ä½ç½®

```java
public int[] searchRange(int[] nums, int target) {
    int[] res = new int[]{-1, -1};
    if (nums == null || nums.length == 0) {
        return res;
    }
    int l = 0, r = nums.length - 1, mostL = -1, mostR = -1;
    // æŸ¥æ‰¾ ç­‰äº target æœ€å·¦ä¾§ä½ç½®
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostL = mid;
            r = mid - 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    if (mostL == -1) {
        return res;
    }
    res[0] = mostL;
    l = mostL;
    r = nums.length - 1;
    while (l <= r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] == target) {
            mostR = mid;
            l = mid + 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    res[1] = mostR;
    return res;
}
```

### [470. ç”¨ Rand7() å®ç° Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

#### æ‹’ç»é‡‡æ ·é—®é¢˜

#### â­æ–¹æ³•ä¸€ï¼šä¸‡èƒ½æ„é€ æ³•ï¼šç‹¬ç«‹éšæœºäº‹ä»¶+å¤å…¸æ¦‚å‹

[1,X] çš„éšæœºæ•°å‘ç”Ÿå™¨ randX()  å¾ˆæ˜æ˜¾æ˜¯ä¸€ä¸ªå¤å…¸æ¦‚å‹ï¼šå®ƒçš„ç»“æœæ˜¯æœ‰é™çš„ï¼Œä¸”æ¯ä¸ªç»“æœçš„æ¦‚ç‡ç›¸åŒã€‚
ç‹¬ç«‹éšæœºäº‹ä»¶çš„æ¦‚ç‡ï¼šP(AB)=P(A)*P(B) 

é‚£ä¹ˆä»»æ„çš„ randX() éƒ½å¯ä»¥ç”¨ä»¥ä¸‹æ–¹æ³•æ„é€ ï¼š

1. æ„é€  n  æ¬¡ç›¸äº’ç‹¬ç«‹çš„é‡‡æ ·ï¼Œå…¶ä¸­ç¬¬ i  æ¬¡é‡‡æ ·æœ‰ $m_i$ ç§ç»“æœï¼Œä¸”ç¬¬ i*i* æ¬¡é‡‡æ ·ä¸­æ¯ç§ç»“æœçš„æ¦‚ç‡æ˜¯ $\frac{1}{m_i}$ ã€‚n è¦æ»¡è¶³$m_1*m_2*\cdots*m_n\ge X$ï¼Œå³æŠŠæ‰€æœ‰é‡‡æ ·ç»“æœç»„åˆèµ·æ¥ï¼Œæœ€ç»ˆçš„ç»“æœæ•°é‡ä¸å°‘äº X*ï¼Œä¿è¯å¯ä»¥æ˜ å°„åˆ° [1,X] çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚*

   è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œæˆ‘ä»¬æ„é€ äº† $m_1*m_2*\cdots*m_n$ä¸ªç»“æœï¼Œå¹¶ä¸”æ¯ä¸ªç»“æœçš„æ¦‚ç‡éƒ½æ˜¯ $\frac{1}{m_1*m_2*\cdots*m_n}$

2. ä» $m_1*m_2*\cdots*m_n$  ä¸ªç»“æœä¸­å– X  ä¸ªï¼Œæ˜ å°„åˆ° [1,X]  åŒºé—´ï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªå‡åŒ€åˆ†å¸ƒåœ¨ [1,X]  çš„éšæœºæ•°å‘ç”Ÿå™¨ã€‚

ç¬¬äºŒæ­¥ä¸­çš„æ˜ å°„æ˜¯ 1:1 æ˜ å°„ï¼Œå®é™…è¿ç”¨ä¸­ï¼Œç¬¬äºŒæ­¥å¯ä»¥å– k*X ä¸ªç»“æœæ¥åš  k:1  æ˜ å°„ï¼Œä»¥å‡å°‘è°ƒç”¨ rand7()  æ¬¡æ•°



**rand7() æ„é€  rand10()**

1. æ„é€  2 æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 2 å’Œ 5  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 10 ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 10  ç§ç»“æœæ˜ å°„åˆ° [1,10]  å³å¯ã€‚

ç¬¬ä¸€æ­¥å…·ä½“è¦å¦‚ä½•æ„é€ é‡‡æ ·æ˜¯è‡ªç”±çš„ï¼Œæ¯”å¦‚ rand7()  æ‹’ç» 7 ï¼Œç„¶åå¯¹ [1,6] é‡‡æ ·ï¼ŒæŠŠå¥‡æ•°å’Œå¶æ•°ä½œä¸º 2  ç§ç»“æœï¼Œè¿™ 2  ç§ç»“æœçš„æ¦‚ç‡å‡ä¸º 0.5 , rand7() æ‹’ç» 6,7 ï¼Œç„¶åå¯¹ [1,5]  é‡‡æ ·ï¼Œæœ‰ 5  ç§ç»“æœï¼Œæ¯ç§æ¦‚ç‡å‡ä¸º 0.2 

```java
public int rand10() {
    int rand1 = rand7();
    while (rand1 == 7) {
        rand1 = rand7();
    }
    int rand2 = rand7();
    while (rand2 > 5) {
        rand2 = rand7();
    }
    return (rand1 & 1) == 1 ? rand2 : 5 + rand2;
}
```

ä¸Šè¿°æ–¹æ³•ç†è®ºä¸Šå¯ä»¥æ„é€ ä»»ä½•èŒƒå›´çš„éšæœºæ•°å‘ç”Ÿå™¨ï¼Œæ¯”å¦‚

 rand11() ï¼š

1. æ„é€  2  æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 2   å’Œ 6  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 12  ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 12  ç§ç»“æœæ˜ å°„åˆ° [1,12]ï¼Œç„¶åå†æ‹’ç» 12  å³å¯ã€‚

rand100()  ï¼š

1. æ„é€  3  æ¬¡é‡‡æ ·ï¼Œåˆ†åˆ«æœ‰ 4,5,5  ç§ç»“æœï¼Œç»„åˆèµ·æ¥ä¾¿æœ‰ 100  ç§æ¦‚ç‡ç›¸åŒçš„ç»“æœã€‚
2. æŠŠè¿™ 100 ç§ç»“æœæ˜ å°„åˆ° [1,100] å³å¯ã€‚

#### â­æ–¹æ³•äºŒï¼šk è¿›åˆ¶è¯¸ä½ç”Ÿæˆ + æ‹’ç»é‡‡æ ·

æ¯æ¬¡æ‰§è¡Œ rand7 éƒ½å¯ä»¥çœ‹ä½œä¸€æ¬¡ç‹¬ç«‹äº‹ä»¶ã€‚æˆ‘ä»¬å¯ä»¥å°†ä¸¤æ¬¡ rand7 çš„ç»“æœçœ‹ä½œç”Ÿæˆ 7  è¿›åˆ¶çš„ä¸¤ä½ã€‚ä»è€Œå®ç°æ¯ä¸ªæ•°å€¼éƒ½å”¯ä¸€å¯¹åº”äº†ä¸€ç§éšæœºå€¼çš„ç»„åˆï¼ˆç­‰æ¦‚ç‡ï¼‰ï¼Œåä¹‹äº¦ç„¶ã€‚

ä¸¾ä¸ªğŸŒ°ï¼Œè®¾éšæœºæ‰§è¡Œä¸¤æ¬¡ `rand7` å¾—åˆ°çš„ç»“æœåˆ†åˆ«æ˜¯ 4 ï¼ˆç¬¬ä¸€æ¬¡ï¼‰ã€7 ï¼ˆç¬¬äºŒæ¬¡ï¼‰ï¼Œç”±äºæˆ‘ä»¬æ˜¯è¦ 7  è¿›åˆ¶çš„æ•°ï¼Œå› æ­¤å¯ä»¥å…ˆå¯¹ `rand7` çš„æ‰§è¡Œç»“æœè¿›è¡Œ -1  æ“ä½œï¼Œå°†è¾“å‡ºåŸŸåç§»åˆ° [0, 6] ï¼ˆä»ä¸ºç­‰æ¦‚ç‡ï¼‰ï¼Œå³å¾—åˆ° 3 ï¼ˆç¬¬ä¸€æ¬¡ï¼‰å’Œ 6ï¼ˆç¬¬äºŒæ¬¡ï¼‰ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ˜¯æ•°å€¼ $(63)_7$ï¼Œæ•°å€¼ $(63)_7$  å”¯ä¸€å¯¹åº”äº†æˆ‘ä»¬çš„éšæœºå€¼ç»„åˆæ–¹æ¡ˆï¼Œåè¿‡æ¥éšæœºå€¼ç»„åˆæ–¹æ¡ˆä¹Ÿå”¯ä¸€å¯¹åº”ä¸€ä¸ª 7  è¿›åˆ¶çš„æ•°å€¼ã€‚

**é‚£ä¹ˆæ ¹æ®ã€Œè¿›åˆ¶è½¬æ¢ã€çš„ç›¸å…³çŸ¥è¯†ï¼Œå¦‚æœæˆ‘ä»¬å­˜åœ¨ä¸€ä¸ª `randK` çš„å‡½æ•°ï¼Œå¯¹å…¶æ‰§è¡Œ n  æ¬¡ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç­‰æ¦‚ç‡äº§ç”Ÿ [0, K^n - 1]  èŒƒå›´å†…çš„æ•°å€¼ã€‚**

å›åˆ°æœ¬é¢˜ï¼Œæ‰§è¡Œä¸€æ¬¡ `rand7` åªèƒ½äº§ç”Ÿ [0, 6]  èŒƒå›´å†…çš„æ•°å€¼ï¼Œä¸è¶³ 10  ä¸ªï¼›è€Œæ‰§è¡Œ 2  æ¬¡ `rand7` çš„è¯åˆ™èƒ½äº§ç”Ÿ [0, 48] ] èŒƒå›´å†…çš„æ•°å€¼ï¼Œè¶³å¤Ÿ 10 ä¸ªï¼Œä¸”ç­‰æ¦‚ç‡ã€‚

æˆ‘ä»¬åªéœ€è¦åˆ¤å®šç”Ÿæˆçš„å€¼æ˜¯å¦ä¸ºé¢˜æ„çš„ [1, 10]  å³å¯ï¼Œå¦‚æœæ˜¯çš„è¯ç›´æ¥è¿”å›ï¼Œå¦åˆ™ä¸€ç›´é‡è¯•ã€‚

```java
public int rand10() {
    int ans = -1;
    while (ans < 1 || ans > 10) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans;
}
```

#### â­æ–¹æ³•äºŒä¼˜åŒ–

**è¿›é˜¶**

1. é™ä½å¯¹ `rand7` çš„è°ƒç”¨æ¬¡æ•°

æˆ‘ä»¬å‘ç°ï¼Œåœ¨ä¸Šè¿°è§£æ³•ä¸­ï¼ŒèŒƒå›´ [0, 48][0,48] ä¸­ï¼Œåªæœ‰ [1, 10][1,10] èŒƒå›´å†…çš„æ•°æ®ä¼šè¢«æ¥å—è¿”å›ï¼Œå…¶ä½™æƒ…å†µå‡è¢«æ‹’ç»é‡è¯•ã€‚

ä¸ºäº†å°½å¯èƒ½å°‘çš„è°ƒç”¨ `rand7` æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä» [0, 48][0,48] ä¸­å–ä¸ [1, 10][1,10] æˆå€æ•°å…³ç³»çš„æ•°ï¼Œæ¥è¿›è¡Œè½¬æ¢ã€‚

æˆ‘ä»¬å¯ä»¥å– [0, 48][0,48] ä¸­çš„ [1, 40][1,40] èŒƒå›´å†…çš„æ•°æ¥ä»£æŒ‡ [1, 10][1,10]ã€‚

é¦–å…ˆåœ¨ [0, 48][0,48] ä¸­å– [1, 40][1,40] ä»ä¸ºç­‰æ¦‚ç‡ï¼Œå…¶æ¬¡å½¢å¦‚ x1  çš„æ•°å€¼æœ‰ 4  ä¸ªï¼ˆ1 ã€11 ã€21 ã€31 ï¼‰ï¼Œå½¢å¦‚ x2  çš„æ•°å€¼æœ‰ 4  ä¸ªï¼ˆ2 ã€12 ã€22 ã€32 ï¼‰... å› æ­¤æœ€ç»ˆç»“æœä»ä¸ºç­‰æ¦‚ç‡ã€‚

```java
public int rand10() {
    int ans = -1;
    while (ans < 0 || ans > 40) {
        ans = (rand7() - 1) * 7 + rand7();
    }
    return ans % 10 + 1;
}
```

### [53. æœ€å¤§å­æ•°ç»„å’Œ](https://leetcode-cn.com/problems/maximum-subarray/)

#### æ–¹æ³•ä¸€ï¼šåŠ¨æ€è§„åˆ’

ç”¨ max è®°å½•ç»“æœï¼Œtempè®°å½•å½“å‰çš„å­æ•°ç»„å’Œï¼š

1. å¾€å³éå†ï¼Œæ›´æ–°tempï¼š
   - å¦‚æœå½“å‰ä½ç½®çš„å€¼ï¼Œå¤§äºtempï¼Œæ›´æ–°tempä¸º å½“å‰ä½ç½®çš„å€¼ï¼Œå¦åˆ™ temp ç´¯åŠ  å½“å‰ä½ç½®
2. ç”¨tempæ›´æ–° max

æ‹“å±•ï¼š

1. æ±‚æœ€å¤§å­æ•°ç»„çš„èŒƒå›´ï¼š
   1. åœ¨å½“å‰æ–¹æ³•åŸºç¡€ä¸Šæ–°å¢å˜é‡ leftå’Œ right
   2. å¦‚æœå½“å‰ä½ç½®çš„å€¼ï¼Œå¤§äºtempï¼Œæ›´æ–°left
   3. å¦‚æœtempå¤§äº maxï¼Œæ›´æ–°right

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = nums[0];
    int r = 1;
    while (r < nums.length) {
        if (nums[r] > nums[r] + temp) {
            temp = nums[r];
        } else {
            temp += nums[r];
        }
        ans = Math.max(ans, temp);
        r++;
    }
    return ans;
}
```

æ–¹æ³•ä¸€ä¼˜åŒ–

```java
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int temp = 0;
    for (int num : nums) {
        temp = Math.max(num, num + temp);
        ans = Math.max(ans, temp);
    }
    return ans;
}
```

#### æ–¹æ³•äºŒ åˆ†æ²»



### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

#### æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s.length() == 0 || s.length() == 1) {
            return s.length();
        }
        int ans = 0, temp = 0;
        int l = 0, r = 0;
        Set<Character> set = new HashSet<>();
        while (r < s.length()) {
            if (!set.contains(s.charAt(r))) {
                set.add(s.charAt(r));
                temp++;
                r++;
                ans = Math.max(ans, temp);
            } else {
                set.remove(s.charAt(l));
                temp--;
                l++;
            }
        }
        return ans;
    }
}
```

#### æ–¹æ³•äºŒï¼šæ•°ç»„

```java
public int lengthOfLongestSubstring(String s) {
    if (s.length() == 0 || s.length() == 1) {
        return s.length();
    }
    int ans = 0, temp = 0;
    int l = 0, r = 0;
    int[] set = new int[150];
    while (r < s.length()) {
        if (set[s.charAt(r)] == 0) {
            set[s.charAt(r)] = 1;
            temp++;
            r++;
            ans = Math.max(ans, temp);
        } else {
            set[s.charAt(l)] = 0;
            temp--;
            l++;
        }
    }
    return ans;
}
```

#### æ–¹æ³•ä¸‰ï¼šå¦‚æœåªåŒ…å«å­—æ¯çš„æƒ…å†µï¼Œå¯ä»¥ç”¨ä½è¿ç®—æ¥åŠ é€Ÿ

### [395. è‡³å°‘æœ‰ K ä¸ªé‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

#### â­â­æ»‘åŠ¨çª—å£

**å½“ç¡®å®šäº†çª—å£å†…æ‰€åŒ…å«çš„å­—ç¬¦æ•°é‡æ—¶ï¼ŒåŒºé—´é‡æ–°å…·æœ‰äº†äºŒæ®µæ€§è´¨**ï¼Œè¿™æ˜¯æœ¬é¢˜çš„æ»‘åŠ¨çª—å£è§£æ³•å’Œè¿„ä»Šä¸ºæ­¢åšçš„æ»‘åŠ¨çª—å£é¢˜ç›®çš„æœ€å¤§ä¸åŒï¼Œæœ¬é¢˜éœ€è¦æ‰‹åŠ¨å¢åŠ é™åˆ¶ï¼Œå³é™åˆ¶çª—å£å†…å­—ç¬¦ç§ç±»ã€‚

##### ç‚¹è¯„

è¿™é“é¢˜çš„çªç ´å£åˆ†æå…¶å®å’Œ 1178. çŒœå­—è°œ ç±»ä¼¼ã€‚

è§£å†³æ€è·¯ï¼šå½“æˆ‘ä»¬é‡‡ç”¨å¸¸è§„çš„åˆ†ææ€è·¯å‘ç°æ— æ³•è¿›è¡Œæ—¶ï¼Œ**è¦å»å…³æ³¨ä¸€ä¸‹æ•°æ®èŒƒå›´ä¸­ã€Œæ•°å€¼å°ã€çš„å€¼ã€‚å› ä¸ºæ•°å€¼å°å…¶å®æ˜¯ä»£è¡¨äº†ã€Œå¯æšä¸¾ã€ï¼Œå¾€å¾€æ˜¯è§£é¢˜æˆ–è€…é™ä½å¤æ‚åº¦çš„ä¸€ä¸ªé‡è¦ï¼ˆç”šè‡³æ˜¯å”¯ä¸€ï¼‰çš„çªç ´å£ã€‚**

```java
// æ–¹æ³•ä¸€ï¼šæ»‘åŠ¨çª—å£
public int longestSubstring(String s, int k) {
    int ans = 0;
    int[] count = new int[26];
    int len = s.length();
    for (int kind = 1; kind <= 26; kind++) {// å…è®¸å‡ºç°çš„å­—ç¬¦ç§ç±»
        Arrays.fill(count, 0);
        for (int i = 0, j = 0, total = 0, vaild = 0; i < len; i++) {
            int idx = s.charAt(i) - 'a';
            count[idx]++;
            if (count[idx] == 1) {// å‡ºç°çš„å­—ç¬¦ç§ç±»åŠ ä¸€
                total++;
            }
            if (count[idx] == k) {// ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ç§ç±»åŠ ä¸€
                vaild++;
            }
            while (total > kind) {// å½“å‡ºç°çš„å­—ç¬¦ç§ç±»è¶…è¿‡é™å®šçš„å­—ç¬¦ç§ç±»ï¼Œå·¦æŒ‡é’ˆå³ç§»
                int n = s.charAt(j) - 'a';
                count[n]--;
                if (count[n] == 0) {// å‡ºç°çš„å­—ç¬¦ç§ç±»å‡å°‘ä¸€
                    total--;
                }
                if (count[n] == k - 1) {// ç¬¦åˆè¦æ±‚çš„å­—ç¬¦ç§ç±»å‡å°‘ä¸€
                    vaild--;
                }
                j++;
            }
            if (total == vaild) {
                ans = Math.max(ans, i - j + 1);
            }
        }
    }
    return ans;
}
```

#### â­â­åˆ†æ²»

å¯¹äºå‡ºç°ä»»ä½•ä¸€ä¸ªå‡ºç°æ¬¡æ•° å¤§äº 0 å°äº k çš„å­—ç¬¦ chï¼ŒåŒ…å«è¯¥å­—ç¬¦çš„ä»»æ„å­ä¸²éƒ½ä¸å¯èƒ½ç¬¦åˆè¦æ±‚ï¼Œæ‰€ä»¥ ä»¥ å­—ç¬¦ ch åˆ†éš”å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆç¬¦åˆè¦æ±‚çš„æœ€é•¿å­ä¸²ä¸€å®šå‡ºç°åœ¨æŸä¸ªè¢«åˆ†å‰²çš„æ®µå†…ï¼Œå› æ­¤å¯ä»¥ç”¨åˆ†æ²»çš„æ–¹å¼æ±‚è§£æ­¤é¢˜ã€‚

```java
public int longestSubstring(String s, int k) {
    return longestSubstring(s, k, 0, s.length() - 1);
}

private int longestSubstring(String s, int k, int l, int r) {
    // ç»Ÿè®¡å½“å‰èŒƒå›´å†…å„å­—ç¬¦çš„å‡ºç°æ¬¡æ•°
    int[] count = new int[26];
    for (int i = l; i <= r; i++) {
        count[s.charAt(i) - 'a']++;
    }
    // æŸ¥æ‰¾ å‡ºç°æ¬¡æ•° å¤§äº 0 å°äº k çš„åˆ†å‰²å­—ç¬¦
    int split = 0;
    for (int i = l; i <= r; i++) {
        if (count[s.charAt(i) - 'a'] < k) {
            split = s.charAt(i);
            break;
        }
    }
    // æ‰¾ä¸åˆ°åˆ†å‰²å­—ç¬¦ï¼Œåˆ™è¯¥å­ä¸²ç¬¦åˆè¦æ±‚ï¼Œç›´æ¥è¿”å›
    if (split == 0) {
        return r - l + 1;
    }
    int ans = 0;
    int left = l;
    while (left <= r) {
        while (left <= r && s.charAt(left) == split) {
            left++;
        }
        if (left > r) {
            break;
        }
        int start = left;
        while (left <= r && s.charAt(left) != split) {
            left++;
        }
        int len = longestSubstring(s, k, start, left - 1);
        ans = Math.max(ans, len);
    }
    return ans;
}
```

### [460. LFU ç¼“å­˜](https://leetcode-cn.com/problems/lfu-cache/)

**åˆ†æéœ€è¦ç”¨åˆ°çš„æ•°æ®ç»“æ„ï¼š**

- $O(1)$ æ—¶é—´å¤æ‚åº¦çš„ å­˜å– æ•°æ®ç»“æ„ï¼šhashMap

- $O(log^n)$ æ—¶é—´å¤æ‚åº¦çš„ æ’åºæ•°æ®ç»“æ„ï¼šå †ï¼ˆJava ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †ï¼‰
  - å †çš„å¢åˆ æ“ä½œæ˜¯ $O(log^n)$ï¼Œå¢åˆ æ“ä½œä¼šè‡ªåŠ¨è°ƒæ•´å †ï¼Œè¿™ä¸ªè°ƒæ•´æ—¶é—´æ˜¯$O(log^n)$
  - å †æ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(nlog^n)$ï¼Œç©ºé—´å¤æ‚åº¦æ˜¯ $O(1)$
  - å»ºå †çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$
- å¢åˆ  éƒ½æ˜¯$O(1)$ æ—¶é—´å¤æ‚åº¦çš„ **æœ‰åº**çš„æ•°æ®ç»“æ„ï¼šé“¾è¡¨



#### â­æ—¶é—´å¤æ‚åº¦ $O(n)$ è§£æ³•

- ä½¿ç”¨å°æ ¹å †æ’åºï¼ˆJava ä¸­çš„ PriorityQueue é»˜è®¤å°±æ˜¯å°æ ¹å †ï¼‰ï¼Œæ‰¾åˆ°è®¿é—®æ¬¡æ•°æœ€å°‘çš„é¡¹
  - è®¿é—®æ¬¡æ•° time **æœ€å°ä¸”æœ€ä¹…æœªè®¿é—®**çš„ é¡¹ ä¸Šæµ®åˆ°å †é¡¶
  - å¯¹äºè®¿é—®æ¬¡æ•°ç›¸åŒçš„é¡¹ï¼Œæ¯”è¾ƒè®¿é—®å…ˆåï¼Œè¿™é‡Œç”¨ å…¨å±€è‡ªå¢çš„ idx è¡¨ç¤ºè®¿é—®çš„å…ˆå

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

/**
 * O(1)  get
 * O(logn) put
 */
class LFUCache {
    class Node implements Comparable<Node> {
        int key;
        int value;
        int time;// è®¿é—®æ¬¡æ•°
        int idx;// è®¿é—®æ—¶é—´

        public Node(int key, int value, int idx) {
            this.key = key;
            this.value = value;
            this.idx = idx;
            this.time = 1;
        }

        @Override
        public int compareTo(Node o) {
            int diff = this.time - o.time;
            return diff != 0 ? diff : this.idx - o.idx;
        }
    }

    Map<Integer, Node> map;// è´Ÿè´£å­˜å–
    PriorityQueue<Node> queue;// è´Ÿè´£æ’åº
    int capacity;
    int idx;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        idx = 0;
        queue = new PriorityQueue<>();
    }

    public int get(int key) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.time++;
            node.idx = idx++;
            queue.remove(node);
            queue.offer(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            node.time++;
            node.idx++;
            queue.remove(node);
            queue.offer(node);
            return;
        } else {
            if (capacity == 0) {
                return;
            }
            if (map.size() == capacity) {
                Node poll = queue.poll();
                map.remove(poll.key);
            }
            Node node = new Node(key, value, idx++);
            map.put(key, node);
            queue.offer(node);
        }
    }
}
```

#### â­æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆä¸€ï¼‰ - åŒ hashMap + LinkedHashSet

#### â­æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆäºŒï¼‰ -  åŒ hashMap + è‡ªå®šä¹‰åŒå‘é“¾è¡¨

**åŒ hashMap + åŒå‘é“¾è¡¨ï¼š**

- `Map<Integer, Node> cacheMap`å­˜å‚¨ç¼“å­˜çš„å†…å®¹
- `Map<Integer, DoubleLinkedList> freqMap` æŒ‰è®¿é—®é¢‘æ¬¡å­˜å‚¨å¯¹åº”Node çš„åŒå‘é“¾è¡¨
- `minFreq` è®°å½•æœ€å°‘è®¿é—®æ¬¡æ•°

**åˆ†æï¼š**

- **cacheMap** ç¡®ä¿äº†å¯ä»¥åœ¨ O(1) å†… æŸ¥è¯¢ï¼ˆget)
- **frepMap** ä¸ minFreq æ­é…ä½¿ç”¨ï¼Œå¯ä»¥åœ¨ O(1) å†… è·å– æœ€ä½è®¿é—®æ¬¡æ•°é¡¹æ‰€åœ¨çš„é“¾è¡¨

- **åŒå‘é“¾è¡¨** ç¡®ä¿äº† ç›¸åŒè®¿é—®æ¬¡æ•°ä¸‹é¡¹çš„æœ‰åºæ€§ï¼Œå¯ä»¥åœ¨ O(1) å†… å¤´æ’å…¥ã€å°¾åˆ é™¤ ç»“ç‚¹ 
  - æ¯å½“æ–°å¢é¡¹æ—¶ï¼Œæ–°å¢é¡¹å¤´æ’å…¥ï¼Œ**æœ€ä¹…æœªä½¿ç”¨** çš„é¡¹ æ°¸è¿œåœ¨ é“¾è¡¨å°¾éƒ¨

```java
package code_top.tx;

import java.util.HashMap;
import java.util.Map;

/**
 * O(1)è§£æ³•
 */
class LFUCache {
    int capacity;// å®¹é‡
    int minFreq;// æœ€å°‘è®¿é—®æ¬¡æ•°
    Map<Integer, Node> cacheMap;// å­˜å‚¨ç¼“å­˜å†…å®¹
    Map<Integer, DoubleLinkedList> freqMap;// æŒ‰é¢‘ç‡å­˜å‚¨å¯¹åº”çš„åŒå‘é“¾è¡¨


    public LFUCache(int capacity) {
        this.capacity = capacity;
        cacheMap = new HashMap<>();
        freqMap = new HashMap<>();
    }

    public int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            refresh(node);
            return node.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        if (cacheMap.containsKey(key)) {
            Node node = cacheMap.get(key);
            node.value = value;
            refresh(node);
        } else {
            if (cacheMap.size() == capacity) {// ç§»é™¤ æœ€å°‘è®¿é—®æ¬¡æ•°ä¸”æœ€ä¹…æœªä½¿ç”¨çš„é¡¹
                DoubleLinkedList list = freqMap.get(minFreq);
                Node del = list.removeLast();
                if (list.isEmpty()) {
                    freqMap.remove(minFreq);
                }
                cacheMap.remove(del.key);
            }
            // æ–°å¢ é¡¹
            Node node = new Node(key, value);
            cacheMap.put(key, node);
            if (!freqMap.containsKey(1)) {
                freqMap.put(1, new DoubleLinkedList());
            }
            DoubleLinkedList list = freqMap.get(1);
            list.add(node);
            minFreq = 1;
        }
    }

    // æ›´æ–°ä½¿ç”¨æ¬¡æ•°
    private void refresh(Node node) {
        DoubleLinkedList list = freqMap.get(node.freq);
        list.remove(node);
        if (list.isEmpty()) {// ç§»é™¤ç©ºé“¾è¡¨
            freqMap.remove(node.freq);
            if (minFreq == node.freq) {// æ›´æ–°æœ€å°‘è®¿é—®æ¬¡æ•°
                minFreq++;
            }
        }
        node.freq++;
        if (!freqMap.containsKey(node.freq)) {
            freqMap.put(node.freq, new DoubleLinkedList());
        }
        freqMap.get(node.freq).add(node);// æ’å…¥æ–°ç»“ç‚¹
    }

}

// è‡ªå®šä¹‰åŒé“¾è¡¨
class DoubleLinkedList {
    Node head;
    Node tail;

    public DoubleLinkedList() {
        this.head = new Node(-1, -1);
        this.tail = new Node(-1, -1);
        head.next = tail;
        tail.pre = head;
    }

    // å¤´æ’å…¥
    public void add(Node node) {
        node.pre = head;
        node.next = head.next;
        head.next = node;
        node.next.pre = node;
    }

    public void remove(Node node) {
        Node pre = node.pre;
        Node next = node.next;
        pre.next = next;
        next.pre = pre;
    }

    // å°¾åˆ é™¤
    public Node removeLast() {
        Node del = tail.pre;
        remove(del);
        return del;
    }

    public boolean isEmpty() {
        return head.next == tail;
    }
}

/**
 * è‡ªå®šä¹‰ç»“ç‚¹ç±»
 */
class Node {
    int key, value, freq;
    Node pre, next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
        this.freq = 1;
    }
}
```

#### â­æœ€ä¼˜è§£ - æ—¶é—´å¤æ‚åº¦$O(1)$è§£æ³•ï¼ˆä¸‰ï¼‰ -  

[ç”œå§¨é¢˜è§£](https://leetcode-cn.com/problems/lfu-cache/solution/java-13ms-shuang-100-shuang-xiang-lian-biao-duo-ji/#o1-%E8%A7%A3%E6%B3%95-%E2%80%94%E2%80%94-%E5%AD%98%E5%82%A8%E9%A2%91%E6%AC%A1%E7%9A%84hashmap%E6%94%B9%E4%B8%BA%E7%9B%B4%E6%8E%A5%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%80%E4%BC%98%E5%AE%9E%E7%8E%B0-13ms-%E5%8F%8C100percent%EF%BC%89)



### [153. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

- æ—¶é—´å¤æ‚åº¦ï¼š$O(log^n)$ï¼Œåœ¨äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€æ­¥ä¼šå¿½ç•¥ä¸€åŠçš„åŒºé—´

- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

**åˆ†æï¼š**

1. æœ€å°å€¼è¦ä¹ˆåœ¨å·¦è¾¹ï¼Œè¦ä¹ˆåœ¨å³è¾¹
2. å¦‚æœ æœ€å°å€¼ä¸åœ¨å³è¾¹ï¼Œé‚£ä¹ˆ `nums[mid] ä¸€å®š å¤§äº nums[r]` ,å¦åˆ™ï¼Œæœ€å°å€¼åœ¨å³è¾¹

```java
// äºŒåˆ†
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return nums[l];
}
```

### [154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

**åˆ†æï¼š**

- å½“ `nums[mid] > nums[right]`æ—¶ï¼Œmid  ä¸€å®šåœ¨ å³è¾¹

- å½“ `nums[mid] < nums[right]` æ—¶ï¼Œmid  ä¸€å®šåœ¨å·¦è¾¹

- å½“ `nums[mid] = nums[right]` æ—¶ï¼Œéš¾ä»¥åˆ¤æ–­æœ€å°å€¼åŒºé—´ï¼Œ è§£å†³æ–¹å¼ï¼š`right--;`

  è¯æ˜ï¼š

  1. æ­¤æ“ä½œä¿è¯äº†æ•°ç»„ä¸ä¼šè¶Šç•Œï¼Œå› ä¸ºè¿­ä»£æ¡ä»¶ï¼š`l < r`
  2. æ­¤æ“ä½œä¿è¯äº†ä¸ä¼šä¸¢å¤±æœ€å°å€¼
     - å‡è®¾ nums[right]  æ˜¯æœ€å°å€¼ï¼Œé‚£å°±ä¸å¯èƒ½æœ‰ `nums[mid] = nums[right]`

æ—¶é—´å¤æ‚åº¦ $O(logN)$ï¼Œåœ¨ç‰¹ä¾‹æƒ…å†µä¸‹ä¼šé€€åŒ–åˆ° $O(N)$ï¼ˆä¾‹å¦‚ [1, 1, 1, 1]ï¼‰

```java
public int findMin(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (nums[mid] < nums[r]) {
            r = mid;
        } else if (nums[mid] > nums[r]) {
            l = mid + 1;
        } else {
            r--;
        }
    }
    return nums[l];
}
```

### [852. å±±è„‰æ•°ç»„çš„å³°é¡¶ç´¢å¼•](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

#### éå†

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0;
    while (arr[l] < arr[l + 1]) {
        l++;
    }
    return l;
}
```

#### â­äºŒåˆ†

```java
public int peakIndexInMountainArray(int[] arr) {
    int l = 0, r = arr.length - 1;
    while (l < r) {
        int mid = l + ((r - l) >> 1);
        if (arr[mid] < arr[mid + 1]) {
            l = mid + 1;
        } else {
            r = mid;
        }
    }
    return l;
}
```

### [88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„](https://leetcode-cn.com/problems/merge-sorted-array/)

**å½’å¹¶æ’åº**

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int start1 = 0, start2 = 0, end1 = m - 1, end2 = n - 1;
    int[] result = new int[m + n];
    int idx = 0;
    while (start1 <= end1 && start2 <= end2) {
        if (nums1[start1] <= nums2[start2]) {
            result[idx++] = nums1[start1++];
        } else {
            result[idx++] = nums2[start2++];
        }
    }
    while (start1 <= end1) {
        result[idx++] = nums1[start1++];
    }
    while (start2 <= end2) {
        result[idx++] = nums2[start2++];
    }
    for (int i = 0; i < result.length; i++) {
        nums1[i] = result[i];
    }
}
```

### [4. å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

å¦‚æœå¯¹æ—¶é—´å¤æ‚åº¦çš„è¦æ±‚æœ‰ $\log$ï¼Œé€šå¸¸éƒ½éœ€è¦ç”¨åˆ°äºŒåˆ†æŸ¥æ‰¾ï¼Œè¿™é“é¢˜ä¹Ÿå¯ä»¥é€šè¿‡äºŒåˆ†æŸ¥æ‰¾å®ç°

- å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°åªæœ‰1ä¸ªï¼Œå°†å®ƒè¿”å›
- å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°æœ‰ä¸¤ä¸ªï¼Œè¿”å›è¿™ä¸¤ä¸ªæ•°çš„å¹³å‡æ•°

#### æ–¹æ³•ä¸€ æš´åŠ›æ±‚è§£

å…ˆåˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼Œç„¶åæ’åºæ‰¾åˆ°ä¸­ä½æ•°

#### æ–¹æ³•äºŒ å½’å¹¶æ’åº

å½’å¹¶æ’åºï¼Œåˆå¹¶æœ‰åºæ•°ç»„

æ—¶é—´å¤æ‚åº¦ï¼š$O(m+n)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(m+n)$

#### æ–¹æ³•ä¸‰  äºŒåˆ†æŸ¥æ‰¾

**æ•´ä½“æ€è·¯**ï¼šåªéœ€è¦ç»™å‡ºä¿©ä¸ªæœ‰åºæ•°ç»„çš„ä¸€ä¸ªæ°å½“çš„ **åˆ†å‰²çº¿**ï¼Œä¸­ä½æ•°çš„å€¼å°±ç”± ä½äºè¿™ä¸ª **åˆ†å‰²çº¿** ä¸¤ä¾§çš„æ•°å†³å®š

##### åœ¨åªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™

ä¸­ä½æ•°ï¼šåœ¨åªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™ï¼Œä¸­ä½æ•°æŠŠæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†

- å½“æ•°ç»„é•¿åº¦ä¸ºå¶æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°æœ‰ä¸¤ä¸ªï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯å·¦è¾¹æ•°ç»„çš„æœ€å¤§å€¼ï¼Œå¦ä¸€ä¸ªæ˜¯å³è¾¹æ•°ç»„çš„æœ€å°å€¼

![image-20211222212403358](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127758.png)

- å½“æ•°ç»„é•¿åº¦ä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œä¸­ä½æ•°åªæœ‰1ä¸ªï¼Œä¸å¦¨æŠŠä¸­ä½æ•°åˆ†åˆ°å·¦è¾¹æ•°ç»„

![image-20211222212431730](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222127219.png)

##### åœ¨æœ‰ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™

ä¸­ä½æ•°ï¼šåœ¨æœ‰ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„æ—¶å€™ï¼Œä»ç„¶å¯ä»¥æŠŠæœ‰åºæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†

![image-20211222213559266](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222136540.png)

ä½¿ç”¨ä¸€æ¡åˆ†å‰²çº¿æŠŠæ•°ç»„åˆ†åˆ«åˆ†å‰²æˆä¸¤ä¸ªéƒ¨åˆ†ï¼š

1. çº¢çº¿å·¦è¾¹å’Œå³è¾¹çš„å…ƒç´ ä¸ªæ•°ç›¸ç­‰ï¼ˆä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°ï¼‰ï¼Œæˆ–å·¦è¾¹å…ƒç´ ä¸ªæ•°æ¯”å³è¾¹å…ƒç´ ä¸ªæ•°å¤šä¸€ä¸ªï¼ˆä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°ï¼‰
2. **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼**ï¼ˆ**å…³é”®**ï¼Œæ»¡è¶³äº†è¿™ç‚¹ï¼Œä½¿å¾—ä¸­ä½æ•°**åªä¸**åˆ†å‰²çº¿å·¦å³ä¸¤ä¾§çš„å…ƒç´ æœ‰å…³ï¼‰

å¦‚æœæ‰¾åˆ°äº†ç¬¦åˆè¿™ä¸¤ç‚¹è¦æ±‚çš„åˆ†å‰²çº¿ï¼Œé‚£ä¹ˆå°±å¯ä»¥å’Œåªæœ‰ä¸€ä¸ªæœ‰åºæ•°ç»„çš„æƒ…å†µç»Ÿä¸€èµ·æ¥ï¼š

- é‚£ä¹ˆä¸­ä½æ•°å°±ä¸€å®šåªä¸çº¢çº¿ä¸¤ä¾§çš„å…ƒç´ æœ‰å…³ï¼Œç¡®å®šè¿™æ¡çº¢çº¿çš„ä½ç½®ï¼Œéœ€è¦ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚

**ï¼ˆä¸€ï¼‰å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™**

â€‹	å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œ

- $Size_{left}  = Size_{right} + 1$

- åœ¨æ»¡è¶³ **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼** çš„å‰æä¸‹ï¼Œ
  - åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ çš„æœ€å¤§å€¼å°±æ˜¯æ•°ç»„çš„ä¸­ä½æ•°
  - ç”±äºä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯æœ‰åºæ•°ç»„ï¼Œåˆ†å‰²çº¿å·¦è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå¤§è€…ï¼Œå°±æ˜¯ä¸­ä½æ•°

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222148124.png" alt="image-20211222214827410" style="zoom:50%;" />

**ï¼ˆäºŒï¼‰å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™**

å½“ä¸¤ä¸ªæœ‰åºæ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¶æ•°çš„æ—¶å€™

- $Size_{left}  = Size_{right}$
- åœ¨æ»¡è¶³ **çº¢çº¿å·¦è¾¹çš„æ‰€æœ‰å…ƒç´ æ•°å€¼ <= çº¢çº¿å³è¾¹æ‰€æœ‰å…ƒç´ çš„æ•°å€¼** çš„å‰æä¸‹ï¼Œ
  - åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ çš„æœ€å¤§å€¼å°±æ˜¯ å…¶ä¸­ä¸€ä¸ªä¸­ä½æ•°
  - åˆ†å‰²çº¿å³è¾¹å…ƒç´ çš„æœ€å°å€¼å°±æ˜¯ å…¶ä¸­å¦ä¸€ä¸ªä¸­ä½æ•°
  - ç”±äºä¸¤ä¸ªæ•°ç»„éƒ½æ˜¯æœ‰åºæ•°ç»„ï¼Œ
    - åˆ†å‰²çº¿å·¦è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå¤§è€…ï¼Œå°±æ˜¯å…¶ä¸­ä¸€ä¸ªä¸­ä½æ•°
    - åˆ†å‰²çº¿å³è¾¹ ä¸¤ä¸ªå…ƒç´ çš„è¾ƒå°è€…ï¼Œå°±æ˜¯å…¶ä¸­å¦ä¸€ä¸ªä¸­ä½æ•°

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222155593.png" alt="image-20211222215458018" style="zoom:50%;" />

##### å…¶ä»–ç»†èŠ‚é—®é¢˜

1. æ²¡æœ‰å¿…è¦åˆ†åˆ«å»ç¡®å®šåˆ†å‰²çº¿åœ¨ä¸¤ä¸ªæ•°ç»„ä¸Šçš„ä½ç½®
   - åˆ†å‰²çº¿å·¦è¾¹ï¼Œæˆ–åˆ™å³è¾¹çš„å…ƒç´ ä¸ªæ•°æ˜¯å¯ä»¥è®¡ç®—å‡ºæ¥çš„ï¼Œæ˜¯ä¸€ä¸ªç¡®å®šçš„æ•°

##### åˆ†å‰²çº¿è®¡ç®—

**æ¡ä»¶ä¸€ï¼šåˆå¹¶å¥‡æ•°å¶æ•°æƒ…å†µä¸‹ï¼Œåˆ†å‰²çº¿ä½ç½®çš„ç¡®å®šå…¬å¼**

![image-20211222220516370](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222205185.png)

**æ¡ä»¶äºŒï¼š æ»¡è¶³äº¤å‰å°äºç­‰äºå…³ç³»** 

- ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ <= ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼
- ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ <= ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼



##### ä¸æ»¡è¶³äº¤å‰å°äºç­‰äºå…³ç³»çš„åˆ†å‰²çº¿ä½ç½®è°ƒæ•´

**æƒ…å†µä¸€ï¼š**ç¬¬äºŒä¸ªæ•°ç»„åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ å¤§äº ç¬¬ä¸€ä¸ªæ•°ç»„åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼

- è°ƒæ•´æ–¹æ¡ˆï¼šå°†ä¸­ä½æ•°åˆ†å‰²çº¿åœ¨æ•°ç»„ 1 çš„ä½ç½® å³ç§»

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112231657314.png" alt="image-20211222221932163" style="zoom:50%;" />

**æƒ…å†µäºŒï¼š**ç¬¬ä¸€ä¸ªæ•°ç»„åˆ†å‰²çº¿å·¦è¾¹çš„æœ€å¤§å€¼ å¤§äº ç¬¬äºŒä¸ªæ•°ç»„åˆ†å‰²çº¿å³è¾¹çš„æœ€å°å€¼

- è°ƒæ•´æ–¹æ¡ˆï¼šå°†ä¸­ä½æ•°åˆ†å‰²çº¿åœ¨æ•°ç»„ 1 çš„ä½ç½® å·¦ç§»

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222216455.png" alt="image-20211222221632023" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222215431.png" alt="image-20211222221557476" style="zoom:50%;" />

> **äºŒåˆ†æŸ¥æ‰¾ç®—æ³•**å°±æ˜¯åœ¨è¿™æ ·çš„å°è¯•æ‰¾åˆ°æ°å½“çš„åˆ†å‰²çº¿çš„è¿‡ç¨‹å½“ä¸­ï¼Œä¸æ–­åœ°ç¼©å°æœç´¢åŒºé—´çš„èŒƒå›´ï¼Œç›´åˆ°æœ€ç»ˆæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„åˆ†å‰²çº¿çš„ä½ç½®



ç”±äºéœ€è¦æ¯”è¾ƒåˆ†å‰²çº¿ä¸¤ä¾§å…ƒç´ çš„å¤§å°å…³ç³»ï¼Œå¯èƒ½å‡ºç°ä»¥ä¸‹ä¸¤ç±»æç«¯æƒ…å†µï¼š

##### æç«¯æƒ…å†µ

**ç¬¬ä¸€ç±»æƒ…å†µï¼š**ä¸¤æ•°ç»„é•¿åº¦ä¸ä¸€è‡´æ—¶

- æƒ…å†µä¸€ï¼šè¾ƒçŸ­çš„æ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ 
- æƒ…å†µäºŒï¼šè¾ƒçŸ­çš„æ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ 

ä¸ºäº†ä¿è¯åˆ†å‰²çº¿åœ¨ è¾ƒé•¿çš„æ•°ç»„ä¸­ åˆ†å‰²çº¿ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œå› æ­¤åº”è¯¥åœ¨è¾ƒçŸ­çš„æ•°ç»„ä¸Šç¡®å®š åˆ†å‰²çº¿ çš„ä½ç½®ï¼Œ**è¿™æ ·å°±ä¸ä¼š åœ¨è®¿é—®æ•°ç»„æ—¶ å‡ºç° æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µ**

![image-20211222222953628](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222229922.png)

**ç¬¬äºŒç±»æƒ…å†µï¼š**ä¸¤æ•°ç»„é•¿åº¦ä¸€æ ·æ—¶

- æƒ…å†µä¸€ï¼šç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ 
- æƒ…å†µäºŒï¼šç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿çš„å³è¾¹æ²¡æœ‰å…ƒç´ 

![image-20211222223152519](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222231600.png)

#### ç®—æ³•æè¿°

1. äº¤æ¢è¾ƒçŸ­çš„æ•°ç»„ä¸º ç¬¬ä¸€ä¸ªæ•°ç»„ï¼Œè¾ƒé•¿çš„æ•°ç»„ä¸ºç¬¬äºŒä¸ªæ•°ç»„

   - è¿™æ˜¯ ä¸ºäº†ä½¿å¾—åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„çš„ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œä»¥ä¿è¯ä¸ä¼šå‡ºç°è®¿é—®æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µï¼Œä»¥æ–¹ä¾¿åç»­ç¼–ç 

2. ç”¨ å˜é‡ mã€n åˆ†åˆ«ä¿å­˜ æ•°ç»„ num1 å’Œ num2 çš„é•¿åº¦

3. ç»Ÿè®¡ åˆ†å‰²çº¿å·¦è¾¹åº”è¯¥æœ‰çš„å…ƒç´ ä¸ªæ•°ï¼š` int totalLeft = (m+n+1)/2;`

   - å¯èƒ½ä¼šå‘ç”Ÿæ•´å‹æº¢å‡ºï¼Œè§£å†³æ–¹æ³•ï¼š` int totalLeft = m + (n - m + 1)/2;`

4. åˆ†å‰²çº¿äºŒåˆ†æŸ¥æ‰¾è¿‡ç¨‹

   1. åˆ†å‰²çº¿å®šä¹‰

      - åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å³è¾¹çš„ç¬¬ 1 ä¸ªå…ƒç´ ä¸‹æ ‡ i = åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å·¦è¾¹çš„å…ƒç´ ä¸ªæ•°
      - åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„å³è¾¹çš„ç¬¬ 1 ä¸ªå…ƒç´ ä¸‹æ ‡ j = åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„å·¦è¾¹çš„å…ƒç´ ä¸ªæ•°
      - æ ¹æ®ä¹‹å‰çš„å®šä¹‰ï¼Œi+j æ»¡è¶³ å…³ç³»å¼ï¼š    $i+j = \frac{m+n+1}{2}$

      ![image-20211222224336317](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112222243308.png)

   2. åˆ†å‰²çº¿é™åˆ¶æ¡ä»¶ï¼ˆäº¤å‰å°äºç­‰äºï¼‰

      -  `nums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]`

   3. åœ¨ nums1 çš„åŒºé—´ [0,m] é‡ŒæŸ¥æ‰¾æ°å½“çš„åˆ†å‰²çº¿

5. 3

**æ€»ç»“ï¼š**

- äºŒåˆ†æŸ¥æ‰¾æ³•æ€è·¯ï¼š
  - åªéœ€è¦ç»™å‡ºä¿©ä¸ªæœ‰åºæ•°ç»„çš„ä¸€ä¸ªæ°å½“çš„ **åˆ†å‰²çº¿**ï¼Œä¸­ä½æ•°çš„å€¼å°±ç”± ä½äºè¿™ä¸ª **åˆ†å‰²çº¿** ä¸¤ä¾§çš„æ•°å†³å®š

#### ç®—æ³•å®ç°

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    // äº¤æ¢è¾ƒçŸ­æ•°ç»„åˆ° nums1ï¼Œæ–¹ä¾¿åç»­ç¼–ç 
    if (nums1.length > nums2.length) {
        int[] temp = nums1;
        nums1 = nums2;
        nums2 = temp;
    }
    // è®°å½• æ•°ç»„é•¿åº¦
    int m = nums1.length;
    int n = nums2.length;
    // ç»Ÿè®¡åˆ†å‰²çº¿å·¦è¾¹å…ƒç´ ä¸ªæ•°ï¼ˆè®©å·¦è¾¹å¤šä¸€ä¸ªå…ƒç´ )
    int sizeLeft = (m + n + 1) / 2;
    // åœ¨è¾ƒçŸ­çš„æ•°ç»„ä¸Šé‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾ å¯»æ‰¾åˆ†å‰²çº¿ä½ç½®
    // äºŒåˆ†æŸ¥æ‰¾åˆ†å‰²çº¿ä½ç½®,åˆ†å‰²çº¿éœ€è¦æ»¡è¶³çš„æ¡ä»¶ï¼ˆäº¤å‰å°äºç­‰äºçš„å…³ç³»ï¼‰ï¼šnums1[i-1] <= nums2[j]&&nums2[j-1] <=nums1[i]
    int left = 0, right = m;
    while (left < right) {
        // äºŒåˆ†è®¡ç®—ä¸­é—´ä½ç½®å…ƒç´ ä¸‹æ ‡
        int i = left + ((right - left + 1) >> 1);// åˆ†å‰²çº¿å³è¾¹å…ƒç´ çš„ä¸‹æ ‡ï¼Œåœ¨ç¬¬ä¸€ä¸ªæ•°ç»„
        int j = sizeLeft - i;// åˆ†å‰²çº¿å³è¾¹çš„å…ƒç´ ä¸‹æ ‡ï¼Œåœ¨ç¬¬äºŒä¸ªæ•°ç»„
        if (nums1[i - 1] > nums2[j]) {// åˆ†å‰²çº¿é å³ï¼Œåº”å·¦ç§»
            right = i - 1;
        } else {
            // åœ¨å·¦è¾¹ç•Œä¸º left = iæ—¶,è‹¥æ•°ç»„ä¸­åªæœ‰ä¸¤ä¸ªå…ƒç´ ï¼Œåˆ™ä¼šè¿›å…¥æ­»å¾ªç¯ï¼Œ
            // è§£å†³æ–¹å¼ï¼šå–ä¸­ä½æ•°æ—¶åŠ ä¸€ï¼Œä¸­ä½æ•°=left + ((right - left + 1) >> 1)
            // åŒæ—¶ä¹Ÿä¿è¯äº† i ä¸ä¼šå–åˆ° 0 ,ä¿è¯äº† i-1>=0,å³ nums1[i-1]ä¸ä¼šè¶Šç•Œ
            left = i;
        }
    }
    int i = left;
    int j = sizeLeft - i; 
    int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
    int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
    int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
    int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
    if (((m + n) & 1) == 1) {// m+n é•¿åº¦ä¸ºå¥‡æ•°
        return Math.max(nums1LeftMax, nums2LeftMax);
    } else {
        return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
    }
}
```

å¦ä¸€ç§ äºŒåˆ†æ¡ä»¶ä¸‹çš„äºŒåˆ†æŸ¥æ‰¾

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // äº¤æ¢è¾ƒå°çš„æ•°ç»„ä¸ºnum1
        // è¿™æ˜¯ä¸ºäº†ä½¿å¾—åˆ†å‰²çº¿åœ¨ç¬¬äºŒä¸ªæ•°ç»„çš„ä¸¤ä¾§éƒ½æœ‰å…ƒç´ ï¼Œä»¥ä¿è¯ä¸ä¼šå‡ºç°è®¿é—®æ•°ç»„ä¸‹æ ‡è¶Šç•Œçš„æƒ…å†µï¼Œä»¥æ–¹ä¾¿åç»­ç¼–ç 
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        // ç”¨ å˜é‡ mã€n åˆ†åˆ«ä¿å­˜ æ•°ç»„ num1 å’Œ num2 çš„é•¿åº¦
        int m = nums1.length;
        int n = nums2.length;
        // ç»Ÿè®¡ åˆ†å‰²çº¿å·¦è¾¹åº”è¯¥æœ‰çš„å…ƒç´ ä¸ªæ•°
        int totalLeft = (m + n + 1) / 2;
        // åˆ†å‰²çº¿é™åˆ¶æ¡ä»¶(äº¤å‰å°äºç­‰äº)ï¼šnums1[i-1]<=nums2[j]&& nums2[j-1]<=num1[i]
        // åœ¨ nums1 çš„åŒºé—´ [0,m] é‡ŒæŸ¥æ‰¾æ°å½“çš„åˆ†å‰²çº¿
        int left = 0, right = m;
        // äºŒåˆ†æŸ¥æ‰¾,ç¡®å®šåˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„å³è¾¹çš„å…ƒç´ ä¸‹æ ‡
        while (left < right) {
//            int i = left + ((right - left + 1) >> 1);// åˆ†å‰²çº¿,+1ä¿è¯äº† iå¤§äºé›¶ï¼Œå³ i-1>=0,å³ä¿è¯äº†nums1æ•°ç»„ä¸‹æ ‡ä¸è¶Šç•Œ
            int i = left + ((right - left) >> 1);// åˆ†å‰²çº¿,+1ä¿è¯äº† iå¤§äºé›¶ï¼Œå³ i-1>=0,å³ä¿è¯äº†nums1æ•°ç»„ä¸‹æ ‡ä¸è¶Šç•Œ
            int j = totalLeft - i;
//            // ç¬¬ä¸€ä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å·¦è¾¹çš„å…ƒç´ æ•°å€¼å¤§äºç¬¬äºŒä¸ªæ•°ç»„åœ¨åˆ†å‰²çº¿å³è¾¹çš„å…ƒç´ æ•°å€¼ï¼Œè¯æ˜åˆ†å‰²çº¿åœ¨ç¬¬ä¸€ä¸ªæ•°ç»„ä¸Šçš„ä½ç½®å¤ªé å³ï¼Œåº”å·¦ç§»
//            // ä¹Ÿå¯ä»¥æ ¹æ®å¦ä¸€ä¸ªæ¡ä»¶å–å
//            if (nums1[i - 1] > nums2[j]) {
//                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [left,i-1]
//                right = i - 1;
//            } else {
//                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [i,right]
//                left = i;
//            }
            if (nums2[j - 1] > nums1[i]) {
                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [i+1,right]
                left = i + 1;// i+1,é‚£ä¹ˆå–ä¸­ä½æ•°æ—¶ä¸éœ€è¦å‘ä¸Šå–æ•´
            } else {
                // ä¸‹ä¸€è½®çš„æœç´¢åŒºé—´ [left,i]
                right = i;
            }
        }
        int i = left;
        int j = totalLeft - i;
        // åˆ†å‰²çº¿å·¦å³ä¸¤ä¾§å…ƒç´ å€¼
        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums2RightMin = j == n ? Integer.MAX_VALUE : nums2[j];
        if ((m + n) % 2 == 1) {// æ•°ç»„é•¿åº¦ä¹‹å’Œä¸ºå¥‡æ•°
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (double) (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;
        }
    }
```

#### æ—¶é—´å¤æ‚åº¦

æ—¶é—´å¤æ‚åº¦ï¼š$O(log^{min(m,n)})$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

#### æ€»ç»“

äºŒåˆ†æŸ¥æ‰¾é€æ¸ç¼©å°ç›®æ ‡å…ƒç´ åŒºé—´

### [è¡¥å……é¢˜6. æ‰‹æ’•å †æ’åº](https://leetcode-cn.com/problems/sort-an-array)

```java
// å †æ’åº
public int[] heapSort(int[] nums) {
    buildMaxHeap(nums);// åˆå§‹åŒ–å¤§é¡¶å †
    // å †æ’åºï¼Œæ¯æ¬¡å¾ªç¯æŠŠå †é¡¶å…ƒç´ ä¸å †å°¾ç»“ç‚¹äº¤æ¢ï¼ŒåŒæ—¶å †é•¿åº¦-1
    for (int i = nums.length - 1; i >= 0; i--) {
        swap(nums, 0, i);// äº¤æ¢å †é¡¶ä¸å †å°¾å…ƒç´ 
        maxHeapFix(nums, 0, i);
    }
    return nums;
}

/**
 * æ„å»ºåˆå§‹å¤§é¡¶å †ï¼Œä»æœ€åä¸€ä¸ªéå¶å­ç»“ç‚¹å¼€å§‹ï¼Œå¶å­ç»“ç‚¹å¯è§†ä¸ºç¬¦åˆå †è¦æ±‚çš„ç»“ç‚¹
 *
 * @param nums
 */
private void buildMaxHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

/**
 * è°ƒæ•´å¤§é¡¶å †
 *
 * @param nums
 * @param idx      éœ€è¦è°ƒæ•´çš„å †å…ƒç´ ç»“ç‚¹
 * @param heapSize éœ€è¦è°ƒæ•´çš„å †çš„é•¿åº¦
 */
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx <= heapSize / 2 - 1) {// å½“ç›®æ ‡ç»“ç‚¹æ˜¯éå¶å­ç»“ç‚¹æ‰è¿›å…¥å¾ªç¯
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [141. ç¯å½¢é“¾è¡¨](https://leetcode-cn.com/problems/linked-list-cycle/)

#### æ–¹æ³•ä¸€:hashSet

ç”¨hashSetè®°å½•èµ°è¿‡çš„ç»“ç‚¹ï¼Œå¦‚æœå†æ¬¡ç»è¿‡ï¼Œåˆ™æœ‰ç¯

#### æ–¹æ³•äºŒï¼šæ ‡è®°æ³•

`-105 <= Node.val <= 105`ï¼Œæ ‡è®°å·²èµ°è¿‡çš„ç»“ç‚¹å€¼ä¸º Integer.MAX_VALUE,è‹¥é‡åˆ° Node.val = Integer.MAX_VALUEï¼Œåˆ™æœ‰ç¯

#### æ–¹æ³•ä¸‰ï¼šå¿«æ…¢æŒ‡é’ˆæ³•

å¿«æ…¢æŒ‡é’ˆåŒæ—¶èµ°ï¼Œç›¸é‡ï¼Œåˆ™å­˜åœ¨ç¯

```java
// å¿«æ…¢æŒ‡é’ˆ
public boolean hasCycle(ListNode head) {
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

### [142. ç¯å½¢é“¾è¡¨ II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

#### å¿«æ…¢æŒ‡é’ˆ

**å½“ å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥**

å‡è®¾èµ·ç‚¹åˆ° ç¯å…¥å£è·ç¦»ä¸º mï¼Œç¯é•¿ä¸º nï¼Œç¬¬ä¸€æ¬¡ç›¸é‡æ—¶è·ç¦»ç¯å…¥å£è·ç¦»ä¸º k

ç»“è®ºï¼š

1. è®¾ä¸€ä¸ªæ…¢æŒ‡é’ˆï¼Œä¸€ä¸ªå¿«æŒ‡é’ˆï¼Œè‹¥æœ‰ç¯å¿«æ…¢æŒ‡é’ˆå¿…ä¼šç›¸é‡ã€‚
   - è¿™ä¸ªä¸éœ€å¤šè¨€ï¼Œç”±äºå¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆæ¯æ¬¡å¤šèµ°ä¸€æ­¥ï¼Œå­˜åœ¨ç¯çš„è¯ï¼Œå¿…å®šç›¸é‡ã€‚
2. ä¸¤æŒ‡é’ˆåœ¨ç¯ä¸­ç¬¬ä¸€æ¬¡ç›¸é‡çš„æ—¶å€™ï¼Œæ…¢æŒ‡é’ˆä¸€å®šåªèµ°äº†ä¸€æ¬¡ m+k ,è€Œä¸ä¼šå¤šèµ°ä¸€åœˆ
3. å°†å¿«æŒ‡é’ˆé‡æ–°ç§»åŠ¨åˆ°é“¾è¡¨å¼€å¤´ï¼Œå¹¶è®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½å‰è¿›ä¸€æ­¥ã€‚å½“å¿«æ…¢æŒ‡é’ˆç¬¬äºŒæ¬¡ç›¸é‡æ—¶ï¼Œç›¸é‡çš„èŠ‚ç‚¹å³ä¸ºç¯è·¯çš„å¼€å§‹ç‚¹ã€‚

è¯æ˜ï¼š

- å…³äºå¿«æ…¢æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡ï¼Œæ…¢æŒ‡é’ˆä¸€å®šåªèµ°äº† m+k ,è€Œä¸ä¼šå¤šèµ°ä¸€åœˆçš„è¯æ˜
  1. ç”±äºå¿«æŒ‡é’ˆå…ˆå…¥ç¯ï¼Œå½“æ…¢æŒ‡é’ˆå…¥ç¯æ—¶ï¼Œå¿«æŒ‡é’ˆä¸€å®šåœ¨ç¯ä¸­æŸä¸ªä½ç½®ï¼Œè®¾ï¼ˆé¡ºæ—¶é’ˆï¼‰è·ç¦»ç¯å…¥å£ èµ°è¿‡çš„è·ç¦»ä¸º p
  2. ä¸€å®šæœ‰ 0<= p <= n
  3. å› ä¸º å¿«æŒ‡é’ˆæ¯æ¬¡æ¯”æ…¢æŒ‡é’ˆå¤šèµ°ä¸€æ­¥ï¼Œä¹Ÿå°±æ˜¯è¯´ å¿«æŒ‡é’ˆåªéœ€èµ° n-p æ­¥å°±å¯ä»¥è¿½ä¸Š æ…¢æŒ‡é’ˆï¼Œè€Œæ…¢æŒ‡é’ˆè¿˜è¦èµ° n æ­¥æ‰èƒ½èµ°å®Œç¬¬ä¸€æ¬¡ç¯ï¼Œ**æ‰€ä»¥å¿…å®šä¼šåœ¨æ…¢æŒ‡é’ˆçš„ç¬¬ä¸€æ¬¡ç¯å†… å¿«æŒ‡é’ˆå°±è¿½ä¸Šæ…¢æŒ‡é’ˆï¼Œå³è¯¥ä¸¤ç‚¹ç›¸é‡**
- å…³äºä¸¤æŒ‡é’ˆç¬¬äºŒæ¬¡ç›¸é‡æ—¶ï¼Œç›¸é‡çš„èŠ‚ç‚¹å³ä¸ºç¯çš„å¼€å§‹ç‚¹çš„è¯æ˜
  1. å½“ä¸¤æŒ‡é’ˆç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼Œslowèµ°è¿‡è·ç¦»ï¼šm+k, fastèµ°è¿‡è·ç¦»ï¼šm+k+An(Aä»£è¡¨åœˆæ•°ï¼ŒA>=1)
  2. ç”±äºfastçš„é€Ÿåº¦æ˜¯slowçš„ä¸¤å€ï¼Œæ‰€ä»¥æœ‰: $(m+k)*2 = m+k+An$ï¼Œå¾—åˆ°ï¼š$m+k = An$ï¼Œè®¾ $n-k = y$, é‚£ä¹ˆæœ‰ï¼š$m = (A-1)n + y$
  3. ä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶ï¼ŒæŠŠfastæŒ‡é’ˆç§»å›é“¾è¡¨èµ·ç‚¹ï¼Œé€Ÿåº¦å˜ä¸ºå’Œslowä¸€æ ·,é‚£ä¹ˆslowå’Œfastå†æ¬¡ç›¸é‡çš„ç»“ç‚¹å¿…ç„¶æ˜¯ç¯èµ·ç‚¹ï¼Œåªæ˜¯ A çš„ä¸åŒä¼šå½±å“ä»ç¬¬ä¸€æ¬¡ç›¸é‡ç‚¹å‡ºå‘çš„slowç»“ç‚¹å¤šèµ°çš„ç¯åœˆæ•°

**å½“ å¿«æŒ‡é’ˆæ¯æ¬¡èµ°ä¸‰æ­¥ï¼Œæ…¢æŒ‡é’ˆæ¯æ¬¡èµ°ä¸€æ­¥**

- åŒæ ·æœ‰ç¬¬ä¸€æ¬¡ç›¸é‡æ—¶ï¼š $k = y/2$

- å°†å¿«æŒ‡é’ˆé‡æ–°ç§»åŠ¨åˆ°é“¾è¡¨å¼€å¤´ï¼Œå¹¶è®©å¿«æ…¢æŒ‡é’ˆæ¯æ¬¡éƒ½å‰è¿›ä¸€æ­¥ï¼Œç¬¬äºŒæ¬¡ç›¸é‡ï¼š$m = (A-1)n + y$



**ä»£ç å®ç°**

```java
// å¿«æ…¢æŒ‡é’ˆ
public ListNode detectCycle(ListNode head) {
    ListNode fast = head, slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) {
            break;
        }
    }
    if (fast == null || fast.next == null) {
        return null;
    }
    fast = head;
    while (fast != slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```

### [70. çˆ¬æ¥¼æ¢¯](https://leetcode-cn.com/problems/climbing-stairs/)

**æ–æ³¢é‚£å¥‘æ•°åˆ—**å¸¸è§æ–¹æ³•ï¼š 1.åŠ¨æ€è§„åˆ’ã€ 2.é€’æ¨ï¼ˆåŠ¨æ€è§„åˆ’ç©ºé—´ä¼˜åŒ–ï¼‰ã€ 3.çŸ©é˜µå¿«é€Ÿå¹‚ã€ 4.é€šé¡¹å…¬å¼

#### é€’å½’

```java
public int climbStairs(int n) {
    if (n == 0 || n == 1) {
        return 1;
    }
    int count = 0;
    count += climbStairs(n - 1);
    count += climbStairs(n - 2);
    return count;
}
```

#### DP

$f(x) = f(x - 1) + f(x - 2)$

```java
public int climbStairs(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int m = 2; m <= n; m++) {
        dp[m] = dp[m - 1] + dp[m - 2];
    }
    return dp[n];
}
```

```java
public int climbStairs(int n) {
    int a = 1, b = 1, temp = 0;
    for (int m = 2; m <= n; m++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
```

#### æ‹“å±•ï¼šä¸èƒ½çˆ¬åˆ°7åŠ7çš„å€æ•°

```java
if (m % 7 == 0) {
    continue;
}
```

### [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

#### æ–¹æ³•ä¸€ï¼šå †æ’ å¤§é¡¶å †

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(max(n,k*log^n))$

```java
// å¤§é¡¶å †
public int findKthLargest(int[] nums, int k) {
    buildHeap(nums);
    int heapSize = nums.length;
    for (int i = 1; i < k; i++) {
        nums[0] = Integer.MIN_VALUE;
        maxHeapFix(nums, 0, heapSize);
    }
    return nums[0];
}

// åˆå§‹åŒ–å¤§é¡¶å †
private void buildHeap(int[] nums) {
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapFix(nums, i, nums.length);
    }
}

// è°ƒæ•´å¤§é¡¶å †
private void maxHeapFix(int[] nums, int idx, int heapSize) {
    while (idx < heapSize / 2) {
        int left = idx * 2 + 1;
        int right = left + 1;
        int maxIdx = left;
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[idx] > nums[maxIdx]) {
            break;
        }
        swap(nums, idx, maxIdx);
        idx = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### æ–¹æ³•äºŒï¼šå †æ’ å°é¡¶å †

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n*log^k)$

#### æ–¹æ³•ä¸‰ï¼šå¿«æ’

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n*log^n)$

#### æ–¹æ³•å››ï¼šå¿«æ’ partition

**æ—¶é—´å¤æ‚åº¦ï¼š**$O(n)$

```java
public int findKthLargest(int[] nums, int k) {
    return findKthLargest(nums, nums.length-k, 0, nums.length - 1);
}

// åœ¨ nums[L...R] èŒƒå›´ï¼Œæ‰¾æ’åºå ä½äº indexä½ç½®çš„æ•°
public int findKthLargest(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = nums[L + (int) (Math.random() * (R - L + 1))];
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return findKthLargest(nums, k, L, range[0] - 1);
    } else {
        return findKthLargest(nums, k, range[1] + 1, R);
    }
}

// è¿”å› ç­‰äºåŒºåŸŸçš„å·¦å³è¾¹ç•Œ
private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;// å°äºåŒºåŸŸçš„å³è¾¹ç•Œ
    int more = R + 1;// å¤§äºåŒºåŸŸçš„å·¦è¾¹ç•Œ
    int idx = L;// å½“å‰æ•°
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, idx, --more);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### æ–¹æ³•äº”ï¼šBFPRT

**æ—¶é—´å¤æ‚åº¦ï¼š** $O(n)$

```java
// nums[L...R] è¿”å›åœ¨æœ‰åºæƒ…å†µä¸‹çš„ä½äºkä½ç½®çš„æ•°
public int bfprt(int[] nums, int k, int L, int R) {
    if (L == R) {
        return nums[L];
    }
    int pivot = medianOfMedians(nums, L, R);// è·å¾— nums[L...R] åŒºé—´å†…ä¸­ä½æ•°çš„ä¸­ä½æ•°
    int[] range = partition(nums, pivot, L, R);
    if (k >= range[0] && k <= range[1]) {
        return nums[k];
    } else if (k < range[0]) {
        return bfprt(nums, k, L, range[0] - 1);
    } else {
        return bfprt(nums, k, range[1] + 1, R);
    }
}

// nums[L...R] æ¯5ä¸ªæ•°ä¸€ç»„
// æ¯ç»„æ•° ç»„å†…æ’åº
// ç”¨æ¯ç»„çš„ä¸­ä½æ•°ç»„æˆä¸­ä½æ•°æ•°ç»„ M
// è¿”å›ä¸­ä½æ•°æ•°ç»„çš„ä¸­ä½æ•° m
private int medianOfMedians(int[] nums, int L, int R) {
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] M = new int[size / 5 + offset];// ä¸­ä½æ•°æ•°ç»„
    for (int team = 0; team < M.length; team++) {
        int teamFirst = L + team * 5;// æ¯ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        M[team] = getMedian(nums, teamFirst, Math.min(R, teamFirst + 4));
    }
    return bfprt(M, M.length / 2, 0, M.length - 1);
}

private int getMedian(int[] nums, int teamFirst, int teamLast) {
    insertionSort(nums, teamFirst, teamLast);
    return nums[(teamLast + teamFirst) / 2];
}

private void insertionSort(int[] nums, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        int temp = nums[i];
        for (int j = i; j >= L; j--) {
            if (j > L && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
}

private int[] partition(int[] nums, int pivot, int L, int R) {
    int less = L - 1;
    int more = R + 1;
    int idx = L;
    while (idx < more) {
        if (nums[idx] < pivot) {
            swap(nums, ++less, idx++);
        } else if (nums[idx] > pivot) {
            swap(nums, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

### [25. K ä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

**ç®—æ³•æ€è·¯ï¼š**

1. è®¾ä¸€ä¸ªè™šæ‹Ÿå¤´dummy ç»“ç‚¹æŒ‡å‘head
2. è®¾ä¸€ä¸ªæŒ‡é’ˆ preTail ä¸ºå‰ä¸€ä¸ªç»„çš„å°¾èŠ‚ç‚¹
3. curæŒ‡é’ˆæŒ‡å‘å½“å‰éå†åˆ°çš„ä½ç½®
4. ä»å½“å‰ç»“ç‚¹curå¼€å§‹ç»Ÿè®¡å¤Ÿ k ä¸ªç»“ç‚¹ï¼Œç¿»è½¬ä¸€æ¬¡ï¼Œå¹¶ç”¨preTailæŒ‡å‘ç¿»è½¬åçš„å¤´ç»“ç‚¹
5. æ›´æ–° preTail
6. è¿”å› dummyçš„ä¸‹ä¸€ä¸ªç»“ç‚¹

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    ListNode preTail = dummy;// å‰ä¸€ç»„åè½¬åçš„å°¾ç»“ç‚¹
    ListNode cur = head;
    while (cur != null) {
        ListNode curHead = cur;
        int count = 0;
        for (int i = 0; i < k; i++) {
            count++;
            cur = cur.next;
            if (cur == null) {
                break;
            }
        }
        if (count == k) {// æ‰¾åˆ°ä¸€ç»„æ»¡ç¼–çš„é“¾è¡¨æ®µ
            ListNode newCurHead = reverseListNode(curHead, k);
            preTail.next = newCurHead;
            preTail = curHead;
        } else {
            preTail.next = curHead;
        }
    }
    return dummy.next;
}

private ListNode reverseListNode(ListNode head, int k) {
    ListNode pre = null, cur = head, temp = null;
    while (k-- > 0) {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

### [5. æœ€é•¿å›æ–‡å­ä¸²](https://leetcode-cn.com/problems/longest-palindromic-substring/)

#### æ–¹æ³•ä¸€ï¼šæš´åŠ›æšä¸¾

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^3)$

```java
// æ–¹æ³•ä¸€ï¼šæš´åŠ›æšä¸¾
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (isPalindrome(chars, i, j) && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}

private boolean isPalindrome(char[] chars, int i, int j) {
    while (i < j) {
        if (chars[i++] != chars[j--]) {
            return false;
        }
    }
    return true;
}
```

#### æ–¹æ³•äºŒï¼šä¸­å¿ƒæ‰©æ•£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$

æšä¸¾çš„ä¸­å¿ƒä½ç½®çš„ä¸ªæ•°æ˜¯ $2(n-1)$, æ¯æ¬¡å‘ä¸¤è¾¹æ‰©æ•£æ£€æµ‹æ˜¯å¦å›æ–‡

```java
// æ–¹æ³•äºŒï¼šä¸­å¿ƒæ‰©æ•£
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    int maxLen = 1;
    int begin = 0;
    char[] chars = s.toCharArray();
    for (int idx = 0; idx < chars.length - 1; idx++) {
        int oddLen = palindromeLen(chars, idx, idx);
        int evenLen = palindromeLen(chars, idx, idx + 1);
        if (oddLen > maxLen || evenLen > maxLen) {
            maxLen = Math.max(oddLen, evenLen);
            begin = idx - ((maxLen + 1) >> 1) + 1;// å›æ–‡ä¸²å¥‡å¶é•¿åº¦ç»Ÿä¸€å¤„ç†
        }
    }
    return s.substring(begin, begin + maxLen);
}

// è¿”å›ä»¥ leftã€rightä¸ºå›æ–‡ä¸­å¿ƒçš„å›æ–‡ä¸²çš„é•¿åº¦
private int palindromeLen(char[] chars, int left, int right) {
    while (left >= 0 && right < chars.length && chars[left] == chars[right]) {
        left--;
        right++;
    }
    return right - left - 1;
}
```

#### æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$

å›æ–‡ä¸²å¤©ç„¶å…·æœ‰çŠ¶æ€è½¬ç§»æ€§è´¨ï¼Œæ–¹æ³•ä¸€ä¸­æœ‰å¯¹ æ˜¯å¦å›æ–‡çš„é‡å¤åˆ¤æ–­ï¼Œä½¿ç”¨dpäºŒç»´è¡¨è®°å½•åˆ¤æ–­ç»“æœï¼Œå‡å°‘é‡å¤åˆ¤æ–­ï¼Œç©ºé—´æ¢æ—¶é—´ï¼Œè®°å¿†åŒ–æœç´¢

```java
// æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] palindrome = isPalindrome(chars);
    for (int i = 0; i < chars.length; i++) {
        for (int j = i + 1; j < chars.length; j++) {
            if (palindrome[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}


private boolean[][] isPalindrome(char[] chars) {
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }
    }
    return dp;
}
```

**ä¼˜åŒ–**

```java
// æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’
public String longestPalindrome(String s) {
    if (s.length() < 2) {
        return s;
    }
    char[] chars = s.toCharArray();
    int maxLen = 1;
    int begin = 0;
    boolean[][] dp = new boolean[chars.length][chars.length];
    for (int i = 0; i < dp.length; i++) {
        dp[i][i] = true;
    }
    for (int i = dp.length - 1; i >= 0; i--) {
        for (int j = i + 1; j < dp.length; j++) {
            if (i + 1 == j) {
                dp[i][j] = chars[i] == chars[j];
            } else {
                if (chars[i] == chars[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
            // å½“å‰å­ä¸²æ˜¯å›æ–‡ï¼Œæ›´æ–°æœ€é•¿å›æ–‡è®°å½•ä¿¡æ¯
            if (dp[i][j] && (j - i + 1) > maxLen) {
                maxLen = j - i + 1;
                begin = i;
            }
        }
    }
    return s.substring(begin, begin + maxLen);
}
```

#### æ–¹æ³•å››ï¼šManacher

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$
