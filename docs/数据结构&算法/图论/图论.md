# 图论

- [相关题目](/docs/数据结构&算法/图论/图论-Leetcode.md)
- [题解](/docs/数据结构&算法/图论/图论-题解.md)

> 拓展知识：
>
> 三类核心的图算法：路径搜索（Pathfinding and Search）、中心性计算（Centrality Computation）和社群发现（Community Detection）
>
> [关于图算法 & 图分析的基础知识概览](https://www.jiqizhixin.com/articles/2019-05-16-14)

# 总结归纳解题模板

### 并查集

**简单实现**

```java
class UnionFind {
        int[] root;
        int[] rank;// 秩

        // 初始化并查集
        public UnionFind(int size) {
            root = new int[size];
            rank = new int[size];
            for (int i = 0; i < size; i++) {
                root[i] = i;
                rank[i] = 1;
            }
        }

        // 查找节点 x 的根节点;路径压缩
        private int find(int x) {
            if (x == root[x]) {
                return x;
            }
            return root[x] = find(root[x]);
        }

        // 按秩合并
        public void union(int x, int y) {
            int xF = find(x);
            int yF = find(y);
            if (xF != yF) {
                if (rank[xF] > rank[yF]) {
                    root[yF] = xF;
                } else if (rank[yF] > rank[xF]) {
                    root[xF] = yF;
                } else {
                    root[yF] = xF;
                    rank[xF]++;
                }
            }
        }

        public boolean isSameSet(int x, int y) {
            return find(x) == find(y);
        }
    }
```

**完整实现**

```java
// 基本元素包装类
class Element<V> {
    V value;

    public Element(V value) {
        this.value = value;
    }
}

class UnionFindSet<V> {
    HashMap<V, Element<V>> elementMap;
    HashMap<Element<V>, Element<V>> fatherMap;
    HashMap<Element<V>, Integer> sizeMap;// 当前根节点下元素个数

    // 初始化并查集
    public UnionFindSet(List<V> list) {
        elementMap = new HashMap<>();
        fatherMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (V value : list) {
            Element<V> element = new Element<>(value);
            fatherMap.put(element, element);
            sizeMap.put(element, 1);
        }
    }

    // 查找根节点，完全路径压缩
    private Element<V> findHead(Element<V> element) {
        Stack<Element<V>> path = new Stack<>();// 记录沿途路径
        while (element != fatherMap.get(element)) {
            path.push(element);
            element = fatherMap.get(element);
        }
        // 把沿途所有节点的根节点更新为element
        while (!path.isEmpty()) {
            fatherMap.put(path.pop(), element);
        }
        return element;
    }

    public void union(V x, V y) {
        if (elementMap.containsKey(x) && elementMap.containsKey(y)) {
            Element<V> xF = fatherMap.get(elementMap.get(x));
            Element<V> yF = fatherMap.get(elementMap.get(y));
            if (xF != yF) {
                Element<V> big = sizeMap.get(xF) >= sizeMap.get(yF) ? xF : yF;
                Element<V> small = big == xF ? yF : xF;
                fatherMap.put(small, big);
                sizeMap.put(big, sizeMap.get(xF) + sizeMap.get(yF));
                sizeMap.remove(small);
            }
        }
    }

    public boolean isSameSet(V x, V y) {
        if (elementMap.containsKey(x) && elementMap.containsKey(y)) {
            return findHead(elementMap.get(x)) == findHead(elementMap.get(y));
        }
        return false;
    }
}
```

### 存图方式

**邻接矩阵法** - 常用

- 这是一种使用二维矩阵来进行存图的方式


- 适用于边数较多的稠密图使用，当边数量接近点的数量的平方，即 $m \approx n^2$

```java
// 邻接矩阵法，graph[a][b]=c 代表从 a 到 b 有权重为 c 的边
int[][] graph = new int[N][N];
```

**邻接表法** - 适用于边较少的情况

```java
// 存储每个节点的next节点
List<Integer>[] graph = new List[N];
// 存储每个节点的入度
int[] in = new int[N];
```

**类** - 更易于理解

```java
class Node {
    int value;
    int in;// 入度
    int out;// 出度
    List<Node> nexts;// 当前节点发散出去的直接邻居集合
    List<Edge> edges;// 当前节点发散出去的边集合

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

class Edge {
    int weight;// 权重
    Node from;
    Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

class Graph {
    HashMap<Integer, Node> nodes;
    HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

### 图的深度优先搜索算法

[797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)：有 n 个节点的 有向无环图，找出所有从节点 0 到节点 n-1 的路径（不要求按特定顺序）

```java
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    List<List<Integer>> res = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    path.add(0);
    dfs(graph, 0, path, res);
    return res;
}

private void dfs(int[][] graph, int next, List<Integer> path, List<List<Integer>> res) {
    if (next == graph.length - 1) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i : graph[next]) {
        if (i != 0) {
            path.add(i);
            dfs(graph, i, path, res);
            path.remove(path.size() - 1);
        }
    }
}
```

### 图的广度优先搜索算法

#### ⭐待补充~~~

### 最小生成树算法

#### Kruskal 算法

「Kruskal 算法」是求解「加权无向图」的「最小生成树」的一种算法

核心思想：不构成环的情况下选择最小边

算法基本步骤：

1. 所有边从小到大排序
2. 把排序后的边依次加入最小生成树，如果形成环则跳过这条边
3. 直到选择N-1 条边为止（N是顶点个数）

[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

```java
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    int n = points.length;
    UnionFind unionFind = new UnionFind(n);
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.len - y.len);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int[] pointA = points[i];
            int[] pointB = points[j];
            int len = Math.abs(pointA[0] - pointB[0]) + Math.abs(pointA[1] - pointB[1]);
            edgePriorityQueue.add(new Edge(i, j, len));
        }
    }
    int count = 0;
    int num = n - 1;
    while (edgePriorityQueue.size() > 0 && num > 0) {
        Edge edge = edgePriorityQueue.poll();
        if (!unionFind.isSameSet(edge.pointA, edge.pointB)) {
            unionFind.union(edge.pointA, edge.pointB);
            count += edge.len;
            num--;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int len;

    public Edge(int pointA, int pointB, int len) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.len = len;
    }
}

/**
 * 并查集
 */
class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // 路径压缩
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // 按秩合并
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[yF] > rank[xF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### Prim算法

「Prim 算法」是求解「加权无向图」的「最小生成树」的另一种算法

算法思路：

1. 选取一个起始点
2. 找到起始点到其他点的最短路径，确定下一个点
3. 在所有已经确定的点中选取最短的一条边，确定下一个点
4. 重复步骤 3

[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

```java
// Prim算法
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    PriorityQueue<int[]> edges = new PriorityQueue<>((a, b) -> a[1] - b[1]);//a[0]:发散出去的顶点，a[1]:边权重
    boolean[] visited = new boolean[points.length];
    // 选取一个初始点
    visited[0] = true;
    for (int i = 1; i < points.length; i++) {
        int distance = Math.abs(points[0][0] - points[i][0]) + Math.abs(points[0][1] - points[i][1]);
        edges.offer(new int[]{i, distance});
    }
    int res = 0;
    int n = 0;// 边指针
    while (!edges.isEmpty() && n < points.length - 1) {
        int[] edge = edges.poll();
        if (!visited[edge[0]]) {
            visited[edge[0]] = true;
            res += edge[1];
            n++;
            for (int i = 0; i < points.length; i++) {
                if (!visited[i]) {// 没有连接到的顶点
                    int distance = Math.abs(points[edge[0]][0] - points[i][0]) + Math.abs(points[edge[0]][1] - points[i][1]);
                    edges.offer(new int[]{i, distance});
                }
            }
        }
    }
    return res;
}
```

#### Kruskal 算法和Prim 算法的比较

Kruskal 算法是通过边 **连通**（所以需要并查集）不同的集合；

Prim 算法是通过边把其它元素加入它的集合

### 单源最短路径算法

#### Dijkstra算法

「Dijkstra 算法」解决的是**加权（非负权）有向图**「单源最短路径」问题

**主要思想**
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。

**优化方案：**使用斐波那契堆来寻找未确定顶点中距离点k最近的点

```java
    // dijkstra算法：求所有点到from点的最短路径
    public HashMap<Node, Integer> dijkstra(Node from) {
        HashMap<Node, Integer> distanceMap = new HashMap<>();//key:从from出发到达key；value:从from出发到达key的最短距离
        distanceMap.put(from, 0);
        Set<Node> confirmNode = new HashSet<>();// 已经确定了最短距离的节点
        Node minNode = getMinDistanceNode(distanceMap, confirmNode);
        while (minNode != null) {
            for (Edge edge : minNode.edges) {
                if (!distanceMap.containsKey(edge.to)) {
                    distanceMap.put(edge.to, distanceMap.get(minNode) + edge.weight);
                } else {
                    distanceMap.put(edge.to, Math.min(distanceMap.get(edge.to), distanceMap.get(minNode) + edge.weight));
                }
            }
            confirmNode.add(minNode);
            minNode = getMinDistanceNode(distanceMap, confirmNode);
        }
        return distanceMap;
    }

    private Node getMinDistanceNode(HashMap<Node, Integer> distanceMap, Set<Node> confirmNode) {
        int dis = Integer.MAX_VALUE;
        Node minNode = null;
        for (Node node : distanceMap.keySet()) {
            if (!confirmNode.contains(node) && dis > distanceMap.get(node)) {
                minNode = node;
                dis = distanceMap.get(minNode);
            }
        }
        return minNode;
    }

    class Node {
        int value;
        int in;
        int out;
        List<Node> nexts;
        List<Edge> edges;

        public Node(int value) {
            this.value = value;
            this.in = 0;
            this.out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
```

[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

朴素 Dijkstra 算法

```java
public int networkDelayTime(int[][] times, int n, int k) {
    int INF = Integer.MAX_VALUE >> 1;// 无穷
    int[][] graph = new int[n][n];// 邻接矩阵
    for (int i = 0; i < n; i++) {
        Arrays.fill(graph[i], INF);
    }
    for (int i = 0; i < times.length; i++) {
        int x = times[i][0] - 1, y = times[i][1] - 1, dis = times[i][2];
        graph[x][y] = dis;
    }
    int[] distance = new int[n];// 距离k点的距离
    Arrays.fill(distance, INF);
    distance[k - 1] = 0;
    boolean[] confirm = new boolean[n];
    int res = 0;
    for (int i = 0; i < n; i++) {// n个元素，最多 循环n次
        // 在尚未确定最短距离的点中找出最短的那个
        int idx = -1;
        for (int j = 0; j < n; j++) {
            if (!confirm[j] && (idx == -1 || distance[j] < distance[idx])) {// 注意这里的条件
                idx = j;
            }
        }
        res = Math.max(res, distance[idx]);
        confirm[idx] = true;
        for (int j = 0; j < n; j++) {
            int dis = distance[idx] + graph[idx][j];
            if (distance[j] > dis) {
                distance[j] = dis;
            }
        }
    }
    return res == INF ? -1 : res;
}
```

**使用小根堆来寻找 未确定节点中距离点k最近的点的Dijkstra算法**

- 时间复杂度：$O(m\log m)$，其中 $m$ 是数组 $\textit{times}$的长度。
- 空间复杂度：$O(n+m)$

```java
public int networkDelayTime(int[][] times, int n, int k) {
    int INF = Integer.MAX_VALUE >> 1;// 正无穷值
    int[][] graph = new int[n][n];// 采用邻接矩阵法表示图
    // 初始化所有点之间的距离为正无穷
    for (int i = 0; i < n; i++) {
        Arrays.fill(graph[i], INF);
    }
    // 更新正确的距离
    for (int i = 0; i < times.length; i++) {
        int a = times[i][0] - 1, b = times[i][1] - 1, distance = times[i][2];
        graph[a][b] = distance;
    }
    int[] dist = new int[n];// 到k的距离
    Arrays.fill(dist, INF);
    dist[k - 1] = 0;
    PriorityQueue<int[]> unConfirmNode = new PriorityQueue<>((a, b) -> a[1] - b[1]);// 小根堆，存放所有未确定点及其到k点的距离
    for (int i = 0; i < n; i++) {
        if (i != k - 1) {
            unConfirmNode.add(new int[]{i, INF});
        }
    }
    unConfirmNode.add(new int[]{k - 1, 0});
    while (!unConfirmNode.isEmpty()) {// 最多n个节点，所以循环n次
        // 在未确定的节点中找到距离k最近的节点
        int[] confirmNode = unConfirmNode.poll();
        for (int j = 0; j < n; j++) {
            int d = confirmNode[1] + graph[confirmNode[0]][j];
            if (dist[j] > d) {
                dist[j] = d;
                unConfirmNode.offer(new int[]{j, d});
            }
        }
    }
    int ans = Arrays.stream(dist).max().getAsInt();
    return ans == INF ? -1 : ans;
}
```

#### Bellman-Ford 算法

##### ⭐待补充~~~

### 拓扑排序算法

拓扑排序的本质是应用了经典的算法思想：广度优先搜索、贪心算法；

**适用范围：**要求有向图，且有入度为0的节点，且没有环；无向图没有拓扑排序，拓扑排序只存在于**有向无环图**中

算法实现 - 用类存图

（也可以不使用inMap,但是这样会改变节点的入度值）

```java
    public List<Node> sortedTopology(Graph graph) {
        Queue<Node> zeroQueue = new LinkedList<>();// 存放入度为0的点
        HashMap<Node, Integer> inMap = new HashMap<>();// 存放所有点和它们的入度
        // 遍历一次图，找到所有入度为0的点
        for (Node node : graph.nodes.values()) {
            inMap.put(node, node.in);
            if (node.in == 0) {
                zeroQueue.add(node);
            }
        }
        List<Node> res = new ArrayList<>();
        while (!zeroQueue.isEmpty()) {
            Node cur = zeroQueue.poll();
            res.add(cur);
            for (Node next : cur.nexts) {
                inMap.put(next, inMap.get(next) - 1);
                if (inMap.get(next) == 0) {
                    zeroQueue.add(next);
                }
            }
        }
        return res;
    }

    class Graph {
        HashMap<Integer, Node> nodes;
        Set<Edge> edges;

        public Graph() {
            this.nodes = nodes;
            this.edges = edges;
        }
    }

    class Node {
        int value;
        int in;
        int out;
        List<Node> nexts;
        List<Edge> edges;

        public Node(int value) {
            this.value = value;
            this.in = 0;
            this.out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
```

算法实现-邻接矩阵

[210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    boolean[][] graph = new boolean[numCourses][numCourses];
    int[] in = new int[numCourses];
    for (int[] prerequisite : prerequisites) {
        int a = prerequisite[0], b = prerequisite[1];
        graph[b][a] = true;
        in[a]++;
    }
    Queue<Integer> zeroQueue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (in[i] == 0) {
            zeroQueue.add(i);
        }
    }
    int[] res = new int[numCourses];
    int count = 0;
    while (!zeroQueue.isEmpty()) {
        int cur = zeroQueue.poll();
        res[count++] = cur;
        for (int i = 0; i < numCourses; i++) {
            if (graph[cur][i]) {
                in[i]--;
                if (in[i] == 0) {
                    zeroQueue.add(i);
                }
            }
        }
    }
    return count == numCourses ? res : new int[]{};
}
```

算法实现-邻接表

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    HashMap<Integer, List<Integer>> graph = new HashMap<>();
    int[] in = new int[numCourses];
    for (int[] prerequisite : prerequisites) {
        int a = prerequisite[0], b = prerequisite[1];
        if (!graph.containsKey(b)) {
            graph.put(b, new ArrayList<>());
        }
        graph.get(b).add(a);
        in[a]++;
    }
    Queue<Integer> zeroQueue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (in[i] == 0) {
            zeroQueue.add(i);
        }
    }
    int[] res = new int[numCourses];
    int count = 0;
    while (!zeroQueue.isEmpty()) {
        int cur = zeroQueue.poll();
        res[count++] = cur;
        List<Integer> nexts = graph.get(cur);
        if (nexts != null) {
            for (int next : nexts) {
                in[next]--;
                if (in[next] == 0) {
                    zeroQueue.add(next);
                }
            }
        }
    }
    return count == numCourses ? res : new int[]{};
}
```



# 学习笔记

### 图结构的表达方法

邻接矩阵法、邻接表法

#### 设计自己的图结构

```java
package first_round.data_structure.graph;

import java.util.ArrayList;

/**
 * 图中点结构
 *
 * @author miemiehoho
 * @date 2021/11/26 16:58
 */
public class Node {
    public int value;// 点的值
    public int in;// 入度
    public int out;// 出度
    public ArrayList<Node> nexts;// 从该点发散出去的直接邻居集合
    public ArrayList<Edge> edges;// 从该点发散出去的边的集合

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<Edge>();
    }
}
```

```java
package first_round.data_structure.graph;

/**
 * 图的边
 *
 * @author miemiehoho
 * @date 2021/11/26 17:00
 */
public class Edge {
    public int weight;// 权重
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

```java
package first_round.data_structure.graph;

import java.util.*;

/**
 * 图
 *
 * @author miemiehoho
 * @date 2021/11/26 11:03
 */
public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

### 并查集

[借这个问题科普一下并查集各种情况下的时间复杂度](https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/)

#### Quick Find

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:43
 */
public class QuickFind {
    int[] root;

    // 初始化
    public QuickFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(1)
    public int find(int x) {
        return root[x];
    }

    // O(N)
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            for (int i = 0; i < root.length; i++) {
                if (root[i] == yF) {
                    root[i] = xF;
                }
            }
        }
    }

    // 0(1)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

}
```

#### Quick Union

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:55
 */
public class QuickUnion {
    int[] root;

    public QuickUnion(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(N)
    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    // O(N)
    public void union(int x, int y) {
        int xF = root[x];
        int yF = root[y];
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    // O(N)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 按秩合并

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 路径压缩优化

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 基于路径压缩的按秩合并优化的「并查集」

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 图的深度优先搜索算法

### 图的广度优先搜索算法

### 最小生成树相关算法

**生成树** 指的是「无向图」中，具有该图的 **全部顶点** 且 **边数最少** 的连通子图。一个「无向图」的生成树可以是多个。

**最小生成树**指的是「加权无向图」中总权重最小的生成树。一个「加权无向图」的最小生成树可以是多个。

#### 切分定理

切分定理」的两个基本概念：

- 切分：将「图」切成两个部分，称之为一个「切分」。下图 就是一个「切分」，其中(B, A, E)为一个部分，(C, D)为另外一个部分。
- 横切边：如果一条边连接的两个顶点属于切分的两个部分，这个边称为「横切边」。在下图中，(B, C), (A, C), (A, D), (E, D) 均为「横切边」。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111261623855.png)

切分定理是 Kruskal 算法和 Prim 算法的重要的理论支撑。根据 [维基百科](https://zh.wikipedia.org/wiki/最小生成树#切分定理) 的定义，「切分定理」指的是：

>在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。



#### Kruskal 算法

核心思想：不构成环的情况下选择最小边

算法基本步骤：

1. 所有边从小到大排序
2. 把排序后的边依次加入最小生成树，如果形成环则跳过这条边
3. 直到选择N-1 条边为止（N是顶点个数）

##### 代码实现

```java
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    int n = points.length;
    UnionFind unionFind = new UnionFind(n);
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.len - y.len);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int[] pointA = points[i];
            int[] pointB = points[j];
            int len = Math.abs(pointA[0] - pointB[0]) + Math.abs(pointA[1] - pointB[1]);
            edgePriorityQueue.add(new Edge(i, j, len));
        }
    }
    int count = 0;
    int num = n - 1;
    while (edgePriorityQueue.size() > 0 && num > 0) {
        Edge edge = edgePriorityQueue.poll();
        if (!unionFind.isSameSet(edge.pointA, edge.pointB)) {
            unionFind.union(edge.pointA, edge.pointB);
            count += edge.len;
            num--;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int len;

    public Edge(int pointA, int pointB, int len) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.len = len;
    }
}

/**
 * 并查集
 */
class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // 路径压缩
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // 按秩合并
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[yF] > rank[xF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### Prim 算法

「Prim 算法」是求解「加权无向图」的「最小生成树」的另一种算法

算法步骤：

1. 选取一个起始点
2. 找到起始点到其他点的最短路径，确定下一个点
3. 重复步骤2，直到找到了n个点

##### 代码实现

```java
// Prim算法
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    boolean[] visited = new boolean[points.length];
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.cost - y.cost);
    int count = 0;
    for (int i = 1; i < points.length; i++) {
        edgePriorityQueue.offer(new Edge(0, i, Math.abs(points[0][0] - points[i][0]) + Math.abs(points[0][1] - points[i][1])));
    }
    int n = 0;
    visited[0] = true;
    while (!edgePriorityQueue.isEmpty() && n < points.length - 1) {
        Edge edge = edgePriorityQueue.poll();
        if (!visited[edge.pointB]) {
            n++;
            count += edge.cost;
            for (int i = 1; i < points.length; i++) {
                if (!visited[i]) {
                    edgePriorityQueue.offer(new Edge(edge.pointB, i, Math.abs(points[edge.pointB][0] - points[i][0]) + Math.abs(points[edge.pointB][1] - points[i][1])));
                }
            }
            visited[edge.pointB] = true;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int cost;

    public Edge(int pointA, int pointB, int cost) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.cost = cost;
    }
}
```



#### Kruskal 算法和Prim 算法的比较

Kruskal 算法是通过边 **连通**（所以需要并查集）不同的集合；

Prim 算法是通过边把其它元素加入它的集合

### 单源最短路径相关算法

#### Dijkstra 算法

「Dijkstra 算法」解决的是加权有向图「单源最短路径」问题，其中该图的所有权重必须为非负数

**主要思想**
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。

![image-20211127092751297](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111270927816.png)

**算法证明**
由于「贪心思想」只能保证每一步都采取当前状态下最优的选择，但它不能保证最终的结果是最优解。那么「Dijkstra 算法」又是如何保证它最终的结果是最优解呢？

- 反证法
  - Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。
  - 如果存在更短路径则说明之前的路径选取错误，这显然是不成立的

**算法限制**

「Dijkstra 算法」针对的「图」的类型 **必须** 满足以下条件：

- 所有边的权重为**非负数**。

##### 算法实现

```java
package first_round.data_structure.graph;

import java.util.*;

/**
 * @author miemiehoho
 * @date 2021/11/27 9:39
 */
public class Dijkstra {

    // 单源最短路径Dijkstra算法
    public HashMap<Node, Integer> networkDelayTime(int[][] times, int k) {
        Graph graph = new Graph();
        graph.createGraph(times);
        // 从from点出发到所有点的最小距离
        // key：从from出发到达key
        // value:从from出发到key的最小距离
        HashMap<Node, Integer> distanceMap = new HashMap<>();
        distanceMap.put(graph.nodes.get(k), 0);
        HashSet<Node> visited = new HashSet<>();// 已经访问过的点
        Node minNode = minDistanceNode(distanceMap, visited);
        while (minNode != null) {
            Integer distance = distanceMap.get(minNode);
            for (Edge edge : minNode.edges) {
                Node to = edge.to;
                // 更新到from点的距离
                if (!distanceMap.containsKey(to)) {
                    distanceMap.put(to, distance + edge.weight);
                } else {
                    distanceMap.put(to, Math.min(distanceMap.get(to), distance + edge.weight));
                }
            }
            visited.add(minNode);
            minNode = minDistanceNode(distanceMap, visited);
        }
        return distanceMap;
    }

    // 找到没有访问过的，最短距离的点
    public Node minDistanceNode(HashMap<Node, Integer> distanceMap, HashSet<Node> visited) {
        Node minNode = null;
        int minDistance = Integer.MAX_VALUE;
        for (Map.Entry<Node, Integer> entry : distanceMap.entrySet()) {
            Node node = entry.getKey();
            int distance = entry.getValue();
            if (!visited.contains(node) && distance < minDistance) {
                minNode = node;
                minDistance = distance;
            }
        }
        return minNode;
    }

    class Graph {
        HashMap<Integer, Node> nodes;
        HashSet<Edge> edges;

        public Graph() {
            nodes = new HashMap<>();
            edges = new HashSet<>();
        }

        // 构造图
        public void createGraph(int[][] times) {
            for (int i = 0; i < times.length; i++) {
                int from = times[i][0];
                int to = times[i][1];
                int weight = times[i][2];
                if (!nodes.containsKey(from)) {
                    nodes.put(from, new Node(from));
                }
                if (!nodes.containsKey(to)) {
                    nodes.put(to, new Node(to));
                }
                Node fromNode = nodes.get(from);
                Node toNode = nodes.get(to);
                Edge edge = new Edge(weight, fromNode, toNode);
                fromNode.nexts.add(toNode);
                fromNode.out++;
                toNode.in++;
                fromNode.edges.add(edge);
                edges.add(edge);
            }
        }
    }

    class Node {
        int value;// 该点的值
        int in;// 入度
        int out;// 出度
        List<Node> nexts;// 从该点发散出去的直接邻居集合
        List<Edge> edges;// 从该点发散出去的边集合

        public Node(int value) {
            this.value = value;
            in = 0;
            out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;// 权重
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }

}
```

##### 时间复杂度

如果使用「斐波那契堆」实现的「最小堆」。则时间复杂度为：O(E + VlogV)

V 表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。

#### Bellman-Ford 算法

「Dijkstra 算法」只能解决没有「负权图」的「单源最短路径」问题。如果遇到有「负权图」，应该使用「Bellman-Ford 算法」

运用 Bellman Ford 可以求解**有限制的**最短路问题

##### **基础定理**

- 定理一：在一个有 N 个顶点的「非负权环图」中，**两点之间的最短路径最多经过 N-1 条边。**
- 定理二：「负权环」没有最短路径。

##### **算法思路：**

利用动态规划思路求最多经历 m 条边时的最短路径(m从0到N-1)

1. 求最多经历0条边时最短路径
2. 求最多经历1条边时最短路径（利用最多经历0条边时最短路径去更新）
3. 直到求到最多经历 N-1条边时最短路径，即为答案

##### **优化思路:**

- 求最多经历m条边时最短路径时不再利用m-1条边时最短路径,而是改为利用前面已经求得的相邻点的最短路径
- 这样就可以在求最多经历m条边最短路径时，**不仅仅求得了最多经历m条边时的最短路径**，从而提高了效率，从而**最多** 需要求 N-1 条边的最短路径
- 终止条件：第m-1次和m次所求结果相同时可以跳出循环，因为第m-1次和m次所求结果相同，那么以后再求，结果也不会改变，即已经获得的最终结果

**注意：**优化方法只适用于求不限制最多经历多少条边的情况下的最短路径；**对于限制了最多只能经历 m 条边情况下的最短路径，无法使用优化的方法！**

##### 算法限制

「Bellman-Ford 算法」针对的「图」的类型**必须**满足以下条件：

- 「图」中不能包含「负权环」。

##### Bellman-Ford 算法如何检测「负权环」

「Bellman-Ford 算法」虽然不能检测到「负权环图」的最短路径，但是它能检测到「图」中是否存在「负权环」。

**检测方法：** 当小伙伴对所有边进行 N-1次松弛之后，再进行第 N 次松弛。根据「Bellman-Ford 算法」，所有的边在 N-1 次松弛之后，所有的距离必然是最短距离。如果在进行第 N次松弛后，对于一条边 edge(u, v)，还存在 $distances[u] + weight(u, v) < distances(v)$ 的情况，也就是说，还存在更短的路径。此时就能说明「图」中存在「负权环」。

##### 时间复杂度

O(V*E)

V表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。



#### 基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法

在前面我们介绍了「Bellman-Ford 算法」，也同时引进了优化版的 Bellman-Ford 算法：针对一个无负权环的图来说，对所有边进行 N-1 次的松弛操作之后，我们就可以得出一个起点到所有其他顶点的最短距离。但是，这个算法在选择边遍历的时候会做很多无用功，这无疑会增加我们算法的运行时间。

##### SPFA 算法

SPFA 是 Shortest Path Faster Algorithm 的简写，它是对「Bellman Ford算法」的优化。

「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了。

##### 时间复杂度

O(V*E)

V表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。

### 拓扑排序 - Kahn算法

- 拓扑排序的本质是应用了经典的算法思想：广度优先搜索、贪心算法；
- 拓扑排序 是广度优先搜索和贪心算法应用于有向图的一个专有名词

**应用场景：**Java中类的依赖包的遍历顺序、任务调度计划、课程安排

**适用范围：**要求有向图，且有入度为0的节点，且没有环

无向图没有拓扑排序，拓扑排序只存在于**有向无环图**中

**拓扑排序特点：**

- 「拓扑排序」的结果不唯一；
- 删除结点的操作，通过「入度数组」体现，这个技巧要掌握；
- 「拓扑排序」的一个附加效果是：**能够顺带检测有向图中是否存在环**（这个知识点非常重要，如果在面试的过程中遇到这个问题，要把这一点说出来）
  - 如果存在结点不能被删除，证明存在环（即结果集中的数量不等于结点的数量）（环上的结点由于永远不会入度为0所以入不了队列）
- 无向图 检测是否有环使用的数据结构是**并查集**（比如Kruskal 算法会跳过成环的边：在建立两点之间的边时应查询它们的根节点是否相同，如果相同就是有环的，否则无环）
- Bellman-Ford 算法附加的作用是可以用于检测是否有负权环

##### 算法思路

1. 找到入度为0的点，消去该点的所有发散出去的边
2. 重复上述过程

##### 算法实现

```java
// 拓扑排序
public List<Node> SortedTopology(Graph graph) {
    HashMap<Node, Integer> inMap = new HashMap<>();// 所有的点及它们的入度
    Queue<Node> zeroQueue = new LinkedList<>();// 存放入度为0的点
    for (Node node : graph.nodes.values()) {
        inMap.put(node, node.in);
        if (node.in == 0) {
            zeroQueue.offer(node);
        }
    }
    List<Node> result = new ArrayList<>();// 拓扑排序结果
    while (!zeroQueue.isEmpty()) {
        Node cur = zeroQueue.poll();
        result.add(cur);
        // 消除点cur对next的影响（入度-1）
        for (Node next : cur.nexts) {
            inMap.put(next, inMap.get(next) - 1);
            if (inMap.get(next) == 0) {
                zeroQueue.offer(next);
            }
        }
    }
    return result;
}

class Graph {
    HashMap<Integer, Node> nodes;
    HashSet<Edge> edges;

    public Graph() {
        this.nodes = new HashMap<>();
        this.edges = new HashSet<>();
    }
}

class Node {
    int value;
    int in;
    int out;
    List<Node> nexts;
    List<Edge> edges;

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

class Edge {
    int weight;
    Node from;
    Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```