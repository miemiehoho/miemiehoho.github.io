# 图论

- [相关题目](/docs/数据结构&算法/图论/图论-Leetcode.md)
- [题解](/docs/数据结构&算法/图论/图论-题解.md)

## 总结归纳



## 学习笔记

### 图结构的表达方法

邻接矩阵法、邻接表法

#### 设计自己的图结构

```java
package first_round.data_structure.graph;

import java.util.ArrayList;

/**
 * 图中点结构
 *
 * @author miemiehoho
 * @date 2021/11/26 16:58
 */
public class Node {
    public int value;// 点的值
    public int in;// 入度
    public int out;// 出度
    public ArrayList<Node> nexts;// 从该点发散出去的直接邻居集合
    public ArrayList<Edge> edges;// 从该点发散出去的边的集合

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<Edge>();
    }
}
```

```java
package first_round.data_structure.graph;

/**
 * 图的边
 *
 * @author miemiehoho
 * @date 2021/11/26 17:00
 */
public class Edge {
    public int weight;// 权重
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

```java
package first_round.data_structure.graph;

import java.util.*;

/**
 * 图
 *
 * @author miemiehoho
 * @date 2021/11/26 11:03
 */
public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

### 并查集

#### Quick Find

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:43
 */
public class QuickFind {
    int[] root;

    // 初始化
    public QuickFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(1)
    public int find(int x) {
        return root[x];
    }

    // O(N)
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            for (int i = 0; i < root.length; i++) {
                if (root[i] == yF) {
                    root[i] = xF;
                }
            }
        }
    }

    // 0(1)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

}
```

#### Quick Union

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:55
 */
public class QuickUnion {
    int[] root;

    public QuickUnion(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(N)
    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    // O(N)
    public void union(int x, int y) {
        int xF = root[x];
        int yF = root[y];
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    // O(N)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 按秩合并

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 路径压缩优化

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 基于路径压缩的按秩合并优化的「并查集」

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 图的深度优先搜索算法

### 图的广度优先搜索算法

### 最小生成树相关算法

**生成树** 指的是「无向图」中，具有该图的 **全部顶点** 且 **边数最少** 的连通子图。一个「无向图」的生成树可以是多个。

**最小生成树**指的是「加权无向图」中总权重最小的生成树。一个「加权无向图」的最小生成树可以是多个。

#### 切分定理

切分定理」的两个基本概念：

- 切分：将「图」切成两个部分，称之为一个「切分」。下图 就是一个「切分」，其中(B, A, E)为一个部分，(C, D)为另外一个部分。
- 横切边：如果一条边连接的两个顶点属于切分的两个部分，这个边称为「横切边」。在下图中，(B, C), (A, C), (A, D), (E, D) 均为「横切边」。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111261623855.png)

切分定理是 Kruskal 算法和 Prim 算法的重要的理论支撑。根据 [维基百科](https://zh.wikipedia.org/wiki/最小生成树#切分定理) 的定义，「切分定理」指的是：

>在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。



#### Kruskal 算法

核心思想：不构成环的情况下选择最小边

算法基本步骤：

1. 所有边从小到大排序
2. 把排序后的边依次加入最小生成树，如果形成环则跳过这条边
3. 直到选择N-1 条边为止（N是顶点个数）

##### 代码实现

```java
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    int n = points.length;
    UnionFind unionFind = new UnionFind(n);
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.len - y.len);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int[] pointA = points[i];
            int[] pointB = points[j];
            int len = Math.abs(pointA[0] - pointB[0]) + Math.abs(pointA[1] - pointB[1]);
            edgePriorityQueue.add(new Edge(i, j, len));
        }
    }
    int count = 0;
    int num = n - 1;
    while (edgePriorityQueue.size() > 0 && num > 0) {
        Edge edge = edgePriorityQueue.poll();
        if (!unionFind.isSameSet(edge.pointA, edge.pointB)) {
            unionFind.union(edge.pointA, edge.pointB);
            count += edge.len;
            num--;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int len;

    public Edge(int pointA, int pointB, int len) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.len = len;
    }
}

/**
 * 并查集
 */
class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // 路径压缩
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // 按秩合并
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[yF] > rank[xF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### Prim 算法

#### Kruskal 算法和Prim 算法的比较

Kruskal 算法是通过边 **连通**（所以需要并查集）不同的集合；

Prim 算法是通过边把其它元素加入它的集合

### 单源最短路径相关算法

### 拓扑排序 相关算法