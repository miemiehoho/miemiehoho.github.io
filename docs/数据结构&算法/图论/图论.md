# 图论

- [相关题目](/docs/数据结构&算法/图论/图论-Leetcode.md)
- [题解](/docs/数据结构&算法/图论/图论-题解.md)

> 拓展知识：
>
> 三类核心的图算法：路径搜索（Pathfinding and Search）、中心性计算（Centrality Computation）和社群发现（Community Detection）
>
> [关于图算法 & 图分析的基础知识概览](https://www.jiqizhixin.com/articles/2019-05-16-14)

# 总结归纳解题模板

### 并查集

**简单实现**

```java
class UnionFind {
        int[] root;
        int[] rank;// 秩

        // 初始化并查集
        public UnionFind(int size) {
            root = new int[size];
            rank = new int[size];
            for (int i = 0; i < size; i++) {
                root[i] = i;
                rank[i] = 1;
            }
        }

        // 查找节点 x 的根节点;路径压缩
        private int find(int x) {
            if (x == root[x]) {
                return x;
            }
            return root[x] = find(root[x]);
        }

        // 按秩合并
        public void union(int x, int y) {
            int xF = find(x);
            int yF = find(y);
            if (xF != yF) {
                if (rank[xF] > rank[yF]) {
                    root[yF] = xF;
                } else if (rank[yF] > rank[xF]) {
                    root[xF] = yF;
                } else {
                    root[yF] = xF;
                    rank[xF]++;
                }
            }
        }

        public boolean isSameSet(int x, int y) {
            return find(x) == find(y);
        }
    }
```

**完整实现**

```java
// 基本元素包装类
class Element<V> {
    V value;

    public Element(V value) {
        this.value = value;
    }
}

class UnionFindSet<V> {
    HashMap<V, Element<V>> elementMap;
    HashMap<Element<V>, Element<V>> fatherMap;
    HashMap<Element<V>, Integer> sizeMap;// 当前根节点下元素个数

    // 初始化并查集
    public UnionFindSet(List<V> list) {
        elementMap = new HashMap<>();
        fatherMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (V value : list) {
            Element<V> element = new Element<>(value);
            fatherMap.put(element, element);
            sizeMap.put(element, 1);
        }
    }

    // 查找根节点，完全路径压缩
    private Element<V> findHead(Element<V> element) {
        Stack<Element<V>> path = new Stack<>();// 记录沿途路径
        while (element != fatherMap.get(element)) {
            path.push(element);
            element = fatherMap.get(element);
        }
        // 把沿途所有节点的根节点更新为element
        while (!path.isEmpty()) {
            fatherMap.put(path.pop(), element);
        }
        return element;
    }

    public void union(V x, V y) {
        if (elementMap.containsKey(x) && elementMap.containsKey(y)) {
            Element<V> xF = fatherMap.get(elementMap.get(x));
            Element<V> yF = fatherMap.get(elementMap.get(y));
            if (xF != yF) {
                Element<V> big = sizeMap.get(xF) >= sizeMap.get(yF) ? xF : yF;
                Element<V> small = big == xF ? yF : xF;
                fatherMap.put(small, big);
                sizeMap.put(big, sizeMap.get(xF) + sizeMap.get(yF));
                sizeMap.remove(small);
            }
        }
    }

    public boolean isSameSet(V x, V y) {
        if (elementMap.containsKey(x) && elementMap.containsKey(y)) {
            return findHead(elementMap.get(x)) == findHead(elementMap.get(y));
        }
        return false;
    }
}
```

### 存图方式

**邻接矩阵法** - 常用

- 这是一种使用二维矩阵来进行存图的方式


- 适用于边数较多的稠密图使用，当边数量接近点的数量的平方，即 $m \approx n^2$

```java
// 邻接矩阵法，graph[a][b]=c 代表从 a 到 b 有权重为 c 的边
int[][] graph = new int[N][N];
```

**邻接表法** - 适用于边较少的情况

```java
// 存储每个节点的next节点
List<Integer>[] graph = new List[N];
// 存储每个节点的入度
int[] in = new int[N];
```

**类** - 更易于理解

```java
class Node {
    int value;
    int in;// 入度
    int out;// 出度
    List<Node> nexts;// 当前节点发散出去的直接邻居集合
    List<Edge> edges;// 当前节点发散出去的边集合

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

class Edge {
    int weight;// 权重
    Node from;
    Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}

class Graph {
    HashMap<Integer, Node> nodes;
    HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

### 图的深度优先搜索算法

[797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)：有 n 个节点的 有向无环图，找出所有从节点 0 到节点 n-1 的路径（不要求按特定顺序）

```java
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    List<List<Integer>> res = new ArrayList<>();
    ArrayList<Integer> path = new ArrayList<>();
    path.add(0);
    dfs(graph, 0, path, res);
    return res;
}

private void dfs(int[][] graph, int next, List<Integer> path, List<List<Integer>> res) {
    if (next == graph.length - 1) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i : graph[next]) {
        if (i != 0) {
            path.add(i);
            dfs(graph, i, path, res);
            path.remove(path.size() - 1);
        }
    }
}
```

### 图的广度优先搜索算法

#### ⭐待补充~~~

### 最小生成树算法

#### Kruskal 算法

「Kruskal 算法」是求解「加权无向图」的「最小生成树」的一种算法

核心思想：不构成环的情况下选择最小边

算法基本步骤：

1. 所有边从小到大排序
2. 把排序后的边依次加入最小生成树，如果形成环则跳过这条边
3. 直到选择N-1 条边为止（N是顶点个数）

[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

```java
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    int n = points.length;
    UnionFind unionFind = new UnionFind(n);
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.len - y.len);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int[] pointA = points[i];
            int[] pointB = points[j];
            int len = Math.abs(pointA[0] - pointB[0]) + Math.abs(pointA[1] - pointB[1]);
            edgePriorityQueue.add(new Edge(i, j, len));
        }
    }
    int count = 0;
    int num = n - 1;
    while (edgePriorityQueue.size() > 0 && num > 0) {
        Edge edge = edgePriorityQueue.poll();
        if (!unionFind.isSameSet(edge.pointA, edge.pointB)) {
            unionFind.union(edge.pointA, edge.pointB);
            count += edge.len;
            num--;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int len;

    public Edge(int pointA, int pointB, int len) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.len = len;
    }
}

/**
 * 并查集
 */
class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // 路径压缩
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // 按秩合并
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[yF] > rank[xF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### Prim算法

「Prim 算法」是求解「加权无向图」的「最小生成树」的另一种算法

算法思路：

1. 选取一个起始点
2. 找到起始点到其他点的最短路径，确定下一个点
3. 在所有已经确定的点中选取最短的一条边，确定下一个点
4. 重复步骤 3

[1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

```java
// Prim算法
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    PriorityQueue<int[]> edges = new PriorityQueue<>((a, b) -> a[1] - b[1]);//a[0]:发散出去的顶点，a[1]:边权重
    boolean[] visited = new boolean[points.length];
    // 选取一个初始点
    visited[0] = true;
    for (int i = 1; i < points.length; i++) {
        int distance = Math.abs(points[0][0] - points[i][0]) + Math.abs(points[0][1] - points[i][1]);
        edges.offer(new int[]{i, distance});
    }
    int res = 0;
    int n = 0;// 边指针
    while (!edges.isEmpty() && n < points.length - 1) {
        int[] edge = edges.poll();
        if (!visited[edge[0]]) {
            visited[edge[0]] = true;
            res += edge[1];
            n++;
            for (int i = 0; i < points.length; i++) {
                if (!visited[i]) {// 没有连接到的顶点
                    int distance = Math.abs(points[edge[0]][0] - points[i][0]) + Math.abs(points[edge[0]][1] - points[i][1]);
                    edges.offer(new int[]{i, distance});
                }
            }
        }
    }
    return res;
}
```

#### Kruskal 算法和Prim 算法的比较

Kruskal 算法是通过边 **连通**（所以需要并查集）不同的集合；

Prim 算法是通过边把其它元素加入它的集合

### 单源最短路径算法

#### Dijkstra算法

「Dijkstra 算法」解决的是**加权（非负权）有向图**「单源最短路径」问题

**主要思想**
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。

**优化方案：**使用斐波那契堆来寻找未确定顶点中距离点k最近的点

```java
    // dijkstra算法：求所有点到from点的最短路径
    public HashMap<Node, Integer> dijkstra(Node from) {
        HashMap<Node, Integer> distanceMap = new HashMap<>();//key:从from出发到达key；value:从from出发到达key的最短距离
        distanceMap.put(from, 0);
        Set<Node> confirmNode = new HashSet<>();// 已经确定了最短距离的节点
        Node minNode = getMinDistanceNode(distanceMap, confirmNode);
        while (minNode != null) {
            for (Edge edge : minNode.edges) {
                if (!distanceMap.containsKey(edge.to)) {
                    distanceMap.put(edge.to, distanceMap.get(minNode) + edge.weight);
                } else {
                    distanceMap.put(edge.to, Math.min(distanceMap.get(edge.to), distanceMap.get(minNode) + edge.weight));
                }
            }
            confirmNode.add(minNode);
            minNode = getMinDistanceNode(distanceMap, confirmNode);
        }
        return distanceMap;
    }

    private Node getMinDistanceNode(HashMap<Node, Integer> distanceMap, Set<Node> confirmNode) {
        int dis = Integer.MAX_VALUE;
        Node minNode = null;
        for (Node node : distanceMap.keySet()) {
            if (!confirmNode.contains(node) && dis > distanceMap.get(node)) {
                minNode = node;
                dis = distanceMap.get(minNode);
            }
        }
        return minNode;
    }

    class Node {
        int value;
        int in;
        int out;
        List<Node> nexts;
        List<Edge> edges;

        public Node(int value) {
            this.value = value;
            this.in = 0;
            this.out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
```

[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

朴素 Dijkstra 算法

```java
public int networkDelayTime(int[][] times, int n, int k) {
    int INF = Integer.MAX_VALUE >> 1;// 无穷
    int[][] graph = new int[n][n];// 邻接矩阵
    for (int i = 0; i < n; i++) {
        Arrays.fill(graph[i], INF);
    }
    for (int i = 0; i < times.length; i++) {
        int x = times[i][0] - 1, y = times[i][1] - 1, dis = times[i][2];
        graph[x][y] = dis;
    }
    int[] distance = new int[n];// 距离k点的距离
    Arrays.fill(distance, INF);
    distance[k - 1] = 0;
    boolean[] confirm = new boolean[n];
    int res = 0;
    for (int i = 0; i < n; i++) {// n个元素，最多 循环n次
        // 在尚未确定最短距离的点中找出最短的那个
        int idx = -1;
        for (int j = 0; j < n; j++) {
            if (!confirm[j] && (idx == -1 || distance[j] < distance[idx])) {// 注意这里的条件
                idx = j;
            }
        }
        res = Math.max(res, distance[idx]);
        confirm[idx] = true;
        for (int j = 0; j < n; j++) {
            int dis = distance[idx] + graph[idx][j];
            if (distance[j] > dis) {
                distance[j] = dis;
            }
        }
    }
    return res == INF ? -1 : res;
}
```

**使用小根堆来寻找 未确定节点中距离点k最近的点的Dijkstra算法**

- 时间复杂度：$O(m\log m)$，其中 $m$ 是数组 $\textit{times}$的长度。
- 空间复杂度：$O(n+m)$

```java
public int networkDelayTime(int[][] times, int n, int k) {
    int INF = Integer.MAX_VALUE >> 1;// 正无穷值
    int[][] graph = new int[n][n];// 采用邻接矩阵法表示图
    // 初始化所有点之间的距离为正无穷
    for (int i = 0; i < n; i++) {
        Arrays.fill(graph[i], INF);
    }
    // 更新正确的距离
    for (int i = 0; i < times.length; i++) {
        int a = times[i][0] - 1, b = times[i][1] - 1, distance = times[i][2];
        graph[a][b] = distance;
    }
    int[] dist = new int[n];// 到k的距离
    Arrays.fill(dist, INF);
    dist[k - 1] = 0;
    PriorityQueue<int[]> unConfirmNode = new PriorityQueue<>((a, b) -> a[1] - b[1]);// 小根堆，存放所有未确定点及其到k点的距离
    for (int i = 0; i < n; i++) {
        if (i != k - 1) {
            unConfirmNode.add(new int[]{i, INF});
        }
    }
    unConfirmNode.add(new int[]{k - 1, 0});
    while (!unConfirmNode.isEmpty()) {// 最多n个节点，所以循环n次
        // 在未确定的节点中找到距离k最近的节点
        int[] confirmNode = unConfirmNode.poll();
        for (int j = 0; j < n; j++) {
            int d = confirmNode[1] + graph[confirmNode[0]][j];
            if (dist[j] > d) {
                dist[j] = d;
                unConfirmNode.offer(new int[]{j, d});
            }
        }
    }
    int ans = Arrays.stream(dist).max().getAsInt();
    return ans == INF ? -1 : ans;
}
```

#### Bellman-Ford 算法

##### ⭐待补充~~~

### 拓扑排序算法

拓扑排序的本质是应用了经典的算法思想：广度优先搜索、贪心算法；

**适用范围：**要求有向图，且有入度为0的节点，且没有环；无向图没有拓扑排序，拓扑排序只存在于**有向无环图**中

算法实现 - 用类存图

（也可以不使用inMap,但是这样会改变节点的入度值）

```java
    public List<Node> sortedTopology(Graph graph) {
        Queue<Node> zeroQueue = new LinkedList<>();// 存放入度为0的点
        HashMap<Node, Integer> inMap = new HashMap<>();// 存放所有点和它们的入度
        // 遍历一次图，找到所有入度为0的点
        for (Node node : graph.nodes.values()) {
            inMap.put(node, node.in);
            if (node.in == 0) {
                zeroQueue.add(node);
            }
        }
        List<Node> res = new ArrayList<>();
        while (!zeroQueue.isEmpty()) {
            Node cur = zeroQueue.poll();
            res.add(cur);
            for (Node next : cur.nexts) {
                inMap.put(next, inMap.get(next) - 1);
                if (inMap.get(next) == 0) {
                    zeroQueue.add(next);
                }
            }
        }
        return res;
    }

    class Graph {
        HashMap<Integer, Node> nodes;
        Set<Edge> edges;

        public Graph() {
            this.nodes = nodes;
            this.edges = edges;
        }
    }

    class Node {
        int value;
        int in;
        int out;
        List<Node> nexts;
        List<Edge> edges;

        public Node(int value) {
            this.value = value;
            this.in = 0;
            this.out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }
```

算法实现-邻接矩阵

[210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    boolean[][] graph = new boolean[numCourses][numCourses];
    int[] in = new int[numCourses];
    for (int[] prerequisite : prerequisites) {
        int a = prerequisite[0], b = prerequisite[1];
        graph[b][a] = true;
        in[a]++;
    }
    Queue<Integer> zeroQueue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (in[i] == 0) {
            zeroQueue.add(i);
        }
    }
    int[] res = new int[numCourses];
    int count = 0;
    while (!zeroQueue.isEmpty()) {
        int cur = zeroQueue.poll();
        res[count++] = cur;
        for (int i = 0; i < numCourses; i++) {
            if (graph[cur][i]) {
                in[i]--;
                if (in[i] == 0) {
                    zeroQueue.add(i);
                }
            }
        }
    }
    return count == numCourses ? res : new int[]{};
}
```

算法实现-邻接表

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    HashMap<Integer, List<Integer>> graph = new HashMap<>();
    int[] in = new int[numCourses];
    for (int[] prerequisite : prerequisites) {
        int a = prerequisite[0], b = prerequisite[1];
        if (!graph.containsKey(b)) {
            graph.put(b, new ArrayList<>());
        }
        graph.get(b).add(a);
        in[a]++;
    }
    Queue<Integer> zeroQueue = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (in[i] == 0) {
            zeroQueue.add(i);
        }
    }
    int[] res = new int[numCourses];
    int count = 0;
    while (!zeroQueue.isEmpty()) {
        int cur = zeroQueue.poll();
        res[count++] = cur;
        List<Integer> nexts = graph.get(cur);
        if (nexts != null) {
            for (int next : nexts) {
                in[next]--;
                if (in[next] == 0) {
                    zeroQueue.add(next);
                }
            }
        }
    }
    return count == numCourses ? res : new int[]{};
}
```



# 学习笔记

### 图结构的表达方法

邻接矩阵法、邻接表法

#### 设计自己的图结构

```java
package first_round.data_structure.graph;

import java.util.ArrayList;

/**
 * 图中点结构
 *
 * @author miemiehoho
 * @date 2021/11/26 16:58
 */
public class Node {
    public int value;// 点的值
    public int in;// 入度
    public int out;// 出度
    public ArrayList<Node> nexts;// 从该点发散出去的直接邻居集合
    public ArrayList<Edge> edges;// 从该点发散出去的边的集合

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<Edge>();
    }
}
```

```java
package first_round.data_structure.graph;

/**
 * 图的边
 *
 * @author miemiehoho
 * @date 2021/11/26 17:00
 */
public class Edge {
    public int weight;// 权重
    public Node from;
    public Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

```java
package first_round.data_structure.graph;

import java.util.*;

/**
 * 图
 *
 * @author miemiehoho
 * @date 2021/11/26 11:03
 */
public class Graph {
    public HashMap<Integer, Node> nodes;
    public HashSet<Edge> edges;

    public Graph() {
        nodes = new HashMap<>();
        edges = new HashSet<>();
    }
}
```

### 并查集

[借这个问题科普一下并查集各种情况下的时间复杂度](https://leetcode-cn.com/problems/number-of-provinces/solution/jie-zhe-ge-wen-ti-ke-pu-yi-xia-bing-cha-0unne/)

#### Quick Find

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:43
 */
public class QuickFind {
    int[] root;

    // 初始化
    public QuickFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(1)
    public int find(int x) {
        return root[x];
    }

    // O(N)
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            for (int i = 0; i < root.length; i++) {
                if (root[i] == yF) {
                    root[i] = xF;
                }
            }
        }
    }

    // 0(1)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }

}
```

#### Quick Union

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 11:55
 */
public class QuickUnion {
    int[] root;

    public QuickUnion(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    // O(N)
    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    // O(N)
    public void union(int x, int y) {
        int xF = root[x];
        int yF = root[y];
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    // O(N)
    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 按秩合并

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 路径压缩优化

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            root[yF] = xF;
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### 基于路径压缩的按秩合并优化的「并查集」

```java
package first_round.data_structure.graph;

/**
 * @author miemiehoho
 * @date 2021/11/26 12:19
 */
public class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[xF] < rank[yF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isConnected(int x, int y) {
        return find(x) == find(y);
    }
}
```

### 图的深度优先搜索算法

### 图的广度优先搜索算法

### 最小生成树相关算法

**生成树** 指的是「无向图」中，具有该图的 **全部顶点** 且 **边数最少** 的连通子图。一个「无向图」的生成树可以是多个。

**最小生成树**指的是「加权无向图」中总权重最小的生成树。一个「加权无向图」的最小生成树可以是多个。

#### 切分定理

切分定理」的两个基本概念：

- 切分：将「图」切成两个部分，称之为一个「切分」。下图 就是一个「切分」，其中(B, A, E)为一个部分，(C, D)为另外一个部分。
- 横切边：如果一条边连接的两个顶点属于切分的两个部分，这个边称为「横切边」。在下图中，(B, C), (A, C), (A, D), (E, D) 均为「横切边」。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111261623855.png)

切分定理是 Kruskal 算法和 Prim 算法的重要的理论支撑。根据 [维基百科](https://zh.wikipedia.org/wiki/最小生成树#切分定理) 的定义，「切分定理」指的是：

>在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。



#### Kruskal 算法

核心思想：不构成环的情况下选择最小边

算法基本步骤：

1. 所有边从小到大排序
2. 把排序后的边依次加入最小生成树，如果形成环则跳过这条边
3. 直到选择N-1 条边为止（N是顶点个数）

##### 代码实现

```java
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    int n = points.length;
    UnionFind unionFind = new UnionFind(n);
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.len - y.len);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            int[] pointA = points[i];
            int[] pointB = points[j];
            int len = Math.abs(pointA[0] - pointB[0]) + Math.abs(pointA[1] - pointB[1]);
            edgePriorityQueue.add(new Edge(i, j, len));
        }
    }
    int count = 0;
    int num = n - 1;
    while (edgePriorityQueue.size() > 0 && num > 0) {
        Edge edge = edgePriorityQueue.poll();
        if (!unionFind.isSameSet(edge.pointA, edge.pointB)) {
            unionFind.union(edge.pointA, edge.pointB);
            count += edge.len;
            num--;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int len;

    public Edge(int pointA, int pointB, int len) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.len = len;
    }
}

/**
 * 并查集
 */
class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    // 路径压缩
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

    // 按秩合并
    public void union(int x, int y) {
        int xF = find(x);
        int yF = find(y);
        if (xF != yF) {
            if (rank[xF] > rank[yF]) {
                root[yF] = xF;
            } else if (rank[yF] > rank[xF]) {
                root[xF] = yF;
            } else {
                root[yF] = xF;
                rank[xF]++;
            }
        }
    }

    public boolean isSameSet(int x, int y) {
        return find(x) == find(y);
    }
}
```

#### Prim 算法

「Prim 算法」是求解「加权无向图」的「最小生成树」的另一种算法

算法步骤：

1. 选取一个起始点
2. 找到起始点到其他点的最短路径，确定下一个点
3. 重复步骤2，直到找到了n个点

##### 代码实现

```java
// Prim算法
public int minCostConnectPoints(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    boolean[] visited = new boolean[points.length];
    PriorityQueue<Edge> edgePriorityQueue = new PriorityQueue<>((x, y) -> x.cost - y.cost);
    int count = 0;
    for (int i = 1; i < points.length; i++) {
        edgePriorityQueue.offer(new Edge(0, i, Math.abs(points[0][0] - points[i][0]) + Math.abs(points[0][1] - points[i][1])));
    }
    int n = 0;
    visited[0] = true;
    while (!edgePriorityQueue.isEmpty() && n < points.length - 1) {
        Edge edge = edgePriorityQueue.poll();
        if (!visited[edge.pointB]) {
            n++;
            count += edge.cost;
            for (int i = 1; i < points.length; i++) {
                if (!visited[i]) {
                    edgePriorityQueue.offer(new Edge(edge.pointB, i, Math.abs(points[edge.pointB][0] - points[i][0]) + Math.abs(points[edge.pointB][1] - points[i][1])));
                }
            }
            visited[edge.pointB] = true;
        }
    }
    return count;
}

class Edge {
    int pointA;
    int pointB;
    int cost;

    public Edge(int pointA, int pointB, int cost) {
        this.pointA = pointA;
        this.pointB = pointB;
        this.cost = cost;
    }
}
```



#### Kruskal 算法和Prim 算法的比较

Kruskal 算法是通过边 **连通**（所以需要并查集）不同的集合；

Prim 算法是通过边把其它元素加入它的集合

### 单源最短路径相关算法

#### Dijkstra 算法

「Dijkstra 算法」解决的是加权有向图「单源最短路径」问题，其中该图的所有权重必须为非负数

**主要思想**
以起点 u 为中心，逐步向外扩展并更新其他顶点的「最短路径」。

「Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。

![image-20211127092751297](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111270927816.png)

**算法证明**
由于「贪心思想」只能保证每一步都采取当前状态下最优的选择，但它不能保证最终的结果是最优解。那么「Dijkstra 算法」又是如何保证它最终的结果是最优解呢？

- 反证法
  - Dijkstra 算法」运用了「贪心思想」，它运行的**每一步都是选择当前已知的顶点的「最小权重」去寻找其他顶点的「最短路径」**（保证了局部最优解即是全局最优解）。
  - 如果存在更短路径则说明之前的路径选取错误，这显然是不成立的

**算法限制**

「Dijkstra 算法」针对的「图」的类型 **必须** 满足以下条件：

- 所有边的权重为**非负数**。

##### 算法实现

##### [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

```java
package first_round.data_structure.graph;

import java.util.*;

/**
 * @author miemiehoho
 * @date 2021/11/27 9:39
 */
public class Dijkstra {

    // 单源最短路径Dijkstra算法
    public HashMap<Node, Integer> networkDelayTime(int[][] times, int k) {
        Graph graph = new Graph();
        graph.createGraph(times);
        // 从from点出发到所有点的最小距离
        // key：从from出发到达key
        // value:从from出发到key的最小距离
        HashMap<Node, Integer> distanceMap = new HashMap<>();
        distanceMap.put(graph.nodes.get(k), 0);
        HashSet<Node> visited = new HashSet<>();// 已经访问过的点
        Node minNode = minDistanceNode(distanceMap, visited);
        while (minNode != null) {
            Integer distance = distanceMap.get(minNode);
            for (Edge edge : minNode.edges) {
                Node to = edge.to;
                // 更新到from点的距离
                if (!distanceMap.containsKey(to)) {
                    distanceMap.put(to, distance + edge.weight);
                } else {
                    distanceMap.put(to, Math.min(distanceMap.get(to), distance + edge.weight));
                }
            }
            visited.add(minNode);
            minNode = minDistanceNode(distanceMap, visited);
        }
        return distanceMap;
    }

    // 找到没有访问过的，最短距离的点
    public Node minDistanceNode(HashMap<Node, Integer> distanceMap, HashSet<Node> visited) {
        Node minNode = null;
        int minDistance = Integer.MAX_VALUE;
        for (Map.Entry<Node, Integer> entry : distanceMap.entrySet()) {
            Node node = entry.getKey();
            int distance = entry.getValue();
            if (!visited.contains(node) && distance < minDistance) {
                minNode = node;
                minDistance = distance;
            }
        }
        return minNode;
    }

    class Graph {
        HashMap<Integer, Node> nodes;
        HashSet<Edge> edges;

        public Graph() {
            nodes = new HashMap<>();
            edges = new HashSet<>();
        }

        // 构造图
        public void createGraph(int[][] times) {
            for (int i = 0; i < times.length; i++) {
                int from = times[i][0];
                int to = times[i][1];
                int weight = times[i][2];
                if (!nodes.containsKey(from)) {
                    nodes.put(from, new Node(from));
                }
                if (!nodes.containsKey(to)) {
                    nodes.put(to, new Node(to));
                }
                Node fromNode = nodes.get(from);
                Node toNode = nodes.get(to);
                Edge edge = new Edge(weight, fromNode, toNode);
                fromNode.nexts.add(toNode);
                fromNode.out++;
                toNode.in++;
                fromNode.edges.add(edge);
                edges.add(edge);
            }
        }
    }

    class Node {
        int value;// 该点的值
        int in;// 入度
        int out;// 出度
        List<Node> nexts;// 从该点发散出去的直接邻居集合
        List<Edge> edges;// 从该点发散出去的边集合

        public Node(int value) {
            this.value = value;
            in = 0;
            out = 0;
            nexts = new ArrayList<>();
            edges = new ArrayList<>();
        }
    }

    class Edge {
        int weight;// 权重
        Node from;
        Node to;

        public Edge(int weight, Node from, Node to) {
            this.weight = weight;
            this.from = from;
            this.to = to;
        }
    }

}
```

##### 时间复杂度

如果使用「斐波那契堆」实现的「最小堆」。则时间复杂度为：O(E + VlogV)

V 表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。

#### Bellman-Ford 算法

「Dijkstra 算法」只能解决没有「负权图」的「单源最短路径」问题。如果遇到有「负权图」，应该使用「Bellman-Ford 算法」

运用 Bellman Ford 可以求解**有限制的**最短路问题

##### **基础定理**

- 定理一：在一个有 N 个顶点的「非负权环图」中，**两点之间的最短路径最多经过 N-1 条边。**
- 定理二：「负权环」没有最短路径。

##### **算法思路：**

利用动态规划思路求最多经历 m 条边时的最短路径(m从0到N-1)

1. 求最多经历0条边时最短路径
2. 求最多经历1条边时最短路径（利用最多经历0条边时最短路径去更新）
3. 直到求到最多经历 N-1条边时最短路径，即为答案

##### **优化思路:**

- 求最多经历m条边时最短路径时不再利用m-1条边时最短路径,而是改为利用前面已经求得的相邻点的最短路径
- 这样就可以在求最多经历m条边最短路径时，**不仅仅求得了最多经历m条边时的最短路径**，从而提高了效率，从而**最多** 需要求 N-1 条边的最短路径
- 终止条件：第m-1次和m次所求结果相同时可以跳出循环，因为第m-1次和m次所求结果相同，那么以后再求，结果也不会改变，即已经获得的最终结果

**注意：**优化方法只适用于求不限制最多经历多少条边的情况下的最短路径；**对于限制了最多只能经历 m 条边情况下的最短路径，无法使用优化的方法！**

##### 算法限制

「Bellman-Ford 算法」针对的「图」的类型**必须**满足以下条件：

- 「图」中不能包含「负权环」。

##### Bellman-Ford 算法如何检测「负权环」

「Bellman-Ford 算法」虽然不能检测到「负权环图」的最短路径，但是它能检测到「图」中是否存在「负权环」。

**检测方法：** 当小伙伴对所有边进行 N-1次松弛之后，再进行第 N 次松弛。根据「Bellman-Ford 算法」，所有的边在 N-1 次松弛之后，所有的距离必然是最短距离。如果在进行第 N次松弛后，对于一条边 edge(u, v)，还存在 $distances[u] + weight(u, v) < distances(v)$ 的情况，也就是说，还存在更短的路径。此时就能说明「图」中存在「负权环」。

##### 时间复杂度

O(V*E)

V表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。



#### 基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法

在前面我们介绍了「Bellman-Ford 算法」，也同时引进了优化版的 Bellman-Ford 算法：针对一个无负权环的图来说，对所有边进行 N-1 次的松弛操作之后，我们就可以得出一个起点到所有其他顶点的最短距离。但是，这个算法在选择边遍历的时候会做很多无用功，这无疑会增加我们算法的运行时间。

##### SPFA 算法

SPFA 是 Shortest Path Faster Algorithm 的简写，它是对「Bellman Ford算法」的优化。

「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了。

##### 时间复杂度

O(V*E)

V表示顶点数，E 表示边数。

##### 空间复杂度

O(V)

V 表示顶点数。

### 拓扑排序 - Kahn算法

- 拓扑排序的本质是应用了经典的算法思想：广度优先搜索、贪心算法；
- 拓扑排序 是广度优先搜索和贪心算法应用于有向图的一个专有名词

**应用场景：**Java中类的依赖包的遍历顺序、任务调度计划、课程安排

**适用范围：**要求有向图，且有入度为0的节点，且没有环

无向图没有拓扑排序，拓扑排序只存在于**有向无环图**中

**拓扑排序特点：**

- 「拓扑排序」的结果不唯一；
- 删除结点的操作，通过「入度数组」体现，这个技巧要掌握；
- 「拓扑排序」的一个附加效果是：**能够顺带检测有向图中是否存在环**（这个知识点非常重要，如果在面试的过程中遇到这个问题，要把这一点说出来）
  - 如果存在结点不能被删除，证明存在环（即结果集中的数量不等于结点的数量）（环上的结点由于永远不会入度为0所以入不了队列）
- 无向图 检测是否有环使用的数据结构是**并查集**（比如Kruskal 算法会跳过成环的边：在建立两点之间的边时应查询它们的根节点是否相同，如果相同就是有环的，否则无环）
- Bellman-Ford 算法附加的作用是可以用于检测是否有负权环

##### 算法思路

1. 找到入度为0的点，消去该点的所有发散出去的边
2. 重复上述过程

##### 算法实现

```java
// 拓扑排序
public List<Node> SortedTopology(Graph graph) {
    HashMap<Node, Integer> inMap = new HashMap<>();// 所有的点及它们的入度
    Queue<Node> zeroQueue = new LinkedList<>();// 存放入度为0的点
    for (Node node : graph.nodes.values()) {
        inMap.put(node, node.in);
        if (node.in == 0) {
            zeroQueue.offer(node);
        }
    }
    List<Node> result = new ArrayList<>();// 拓扑排序结果
    while (!zeroQueue.isEmpty()) {
        Node cur = zeroQueue.poll();
        result.add(cur);
        // 消除点cur对next的影响（入度-1）
        for (Node next : cur.nexts) {
            inMap.put(next, inMap.get(next) - 1);
            if (inMap.get(next) == 0) {
                zeroQueue.offer(next);
            }
        }
    }
    return result;
}

class Graph {
    HashMap<Integer, Node> nodes;
    HashSet<Edge> edges;

    public Graph() {
        this.nodes = new HashMap<>();
        this.edges = new HashSet<>();
    }
}

class Node {
    int value;
    int in;
    int out;
    List<Node> nexts;
    List<Edge> edges;

    public Node(int value) {
        this.value = value;
        in = 0;
        out = 0;
        nexts = new ArrayList<>();
        edges = new ArrayList<>();
    }
}

class Edge {
    int weight;
    Node from;
    Node to;

    public Edge(int weight, Node from, Node to) {
        this.weight = weight;
        this.from = from;
        this.to = to;
    }
}
```

# 并查集

并查集是一种用于集合合并的结构，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：**合并**（Union）、**查询**（Find）

经过优化的并查集有线性的[空间复杂度](https://zh.wikipedia.org/wiki/空间复杂度)$（{\displaystyle \mathrm {O} \left(n\right)}$，${\displaystyle n}$为元素数目，下同），以及接近常数的单次操作平均[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)（${\displaystyle \mathrm {O} \left(\alpha \left(n\right)\right)}$，${\displaystyle \alpha }$为[反阿克曼函数](https://zh.wikipedia.org/wiki/反阿克曼函数))，是效率最高的常见数据结构之一。



对于链表和哈希表，无法做到 合并、查询同时O(1):

两个操作：issameset（查）和 union（并）

问题：设计一种结构把（1）两个集合中的元素合并到一个集合（2）查询两个样本是否一个集合

链表：union操作是O(1),但是issameset操作需要遍历两个集合

哈希表：issameset操作是O(1)，但是union操作需要把一个集合中的元素全部导到另一个集合

### 代码实现

```java
package zs;

import java.util.HashMap;
import java.util.List;
import java.util.Stack;

/**
 * 并查集
 *
 * @author miemiehoho
 * @date 2021/11/25 22:17
 */
public class DisjointSet {
    // 把基本元素封装一层
    class Element<V> {
        public V value;

        public Element(V value) {
            this.value = value;
        }
    }

    public class UnionFindSet<V> {
        // a -> a,封装基本元素
        // 把基本元素封装一层：与Java语言特性有关，比如Integer类型，如果不封装的话对map来说 3 3 3 3 这几个3 都是一个3
        public HashMap<V, Element<V>> elementMap;
        public HashMap<Element<V>, Element<V>> fatherMap;
        // sizeMap 中的key是集合的头节点（代表节点）
        public HashMap<Element<V>, Integer> sizeMap;// (rankMap)

        // 初始化
        public UnionFindSet(List<V> list) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();
            for (V value : list) {
                Element<V> element = new Element<>(value);
                elementMap.put(value, element);
                fatherMap.put(element, element);
                sizeMap.put(element, 1);
            }
        }

        // 黑盒：从当前节点出发，往上一直找,找到不能再往上的头节点，返回
        public Element<V> findHead(Element<V> element) {
            // 记录沿途的节点:把往上找的过程中，沿途的点都记录在path中
            Stack<Element<V>> path = new Stack<>();
            // 循环条件：element的父节点不是它自己
            while (element != fatherMap.get(element)) {
                path.push(element);
                element = fatherMap.get(element);
            }
            // 跳出上一个循环后的element就是头节点

            // 将沿途所有节点的头节点改成element节点
            while (!path.isEmpty()) {
                fatherMap.put(path.pop(), element);
            }
            return element;
        }

        public boolean isSameSet(V a, V b) {
            // 检查a、b 是否在初始化时注册进 elementMap
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
            }
            return false;
        }

        // 合并规则：小集合挂到大集合下面
        public void union(V a, V b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                // 取出a、b的头节点
                Element<V> aF = findHead(elementMap.get(a));
                Element<V> bF = findHead(elementMap.get(b));
                // aF、bF不同，则合并
                if (aF != bF) {
                    // aF、bF中较大集合的头节点
     	               Element<V> big = sizeMap.get(aF) >= sizeMap.get(bF) ? aF : bF;
                    // 较小集合的头节点
                    Element<V> small = big == aF ? bF : aF;
                    fatherMap.put(small, big);// 修改小集合的头节点为big
                    sizeMap.put(big, sizeMap.get(aF) + sizeMap.get(bF));// 更新集合的大小
                    sizeMap.remove(small);// small不再作为代表集合的头节点了，删除
                }
            }
        }
    }

}
```

> 拓展知识：MapReduce

**并查集的两个优化：**

1. 小集合挂大集合下面（按秩合并）
2. 往上找的过程中沿途链做扁平化处理（路径压缩）

一般来说并查集的所有元素在初始化时候都有，如果想增加元素，也可以做到，新增一个addElement方法就好。

#### 时间复杂度

样本数量：n

如果 isSameSet() 和 union() 整体发生的次数逼近了 n 或超过了 n,那么单次的 isSameSet() 和 union() 方法时间复杂度为 O(1)

(调用的次数越多，单次的 isSameSet() 和 union()  代价越小)







并查集（Union Find）也叫「不相交集合（Disjoint Set）」，专门用于 动态处理 不相交集合的「查询」与「合并」问题。

可以使用并查集的问题一般都可以使用基于遍历的搜索算法（深度优先搜索、广度优先搜索）完成，但是使用并查集会使得解决问题的过程更加清晰、直观。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251123145.png)



#### 并查集动态处理的两个问题

**查询（Find）**

查询图中的两个顶点是不是在同一个集合中。

> **注意**：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。

**合并（Union）**

将两个不相交集合进行合并。

#### 设计并查集的两种思想

**quick-find：基于 id**

「基于 id」的思想给每一个元素（顶点）分配一个唯一标识，称为 `id`。

- 初始化的时候：所有元素的 `id` 都不一样，表示一个元素单独属于一个集合。
- 如果两个元素的 `id` 一样，标识它们同属于一个集合；
- 合并的时候，需要将其中一个集合中的 **所有元素** 的 `id` 赋值成为另一个集合的 `id`（一个集合中的所有元素的 `id` 均一样）。

类似于：给每个元素（顶点）改名字，名字一样，就表示在同一个集合中。

- 优点：查询两个元素是否在一个集合中很快，时间复杂度为 O(1)；
- 缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

**quick-union：基于 parent（重要）**

「基于 parent」的思想其实也很常见：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫「代表元」法。

我们不再使用 `id` 数组，而使用 `parent` 数组。`parent` 数组的定义是：`parent[i]` 表示标识为 `i` 的结点的父亲结点的标识（可以形象地记为「找爸爸」）。在这个定义下，根结点的父亲结点是自己。

这种方式形成的「并查集」组织成了 **若干个不相交的树形结构**，并且我们在访问结点的时候，总是按照「从下到上」进行访问的。

#### 详解代表元法

**「代表元」的「三个不重要」**

以下「三个不重要」概括了「代表元法」的设计理念，大家需要结合练习体会。

- 谁作为根结点不重要：根结点与非根结点只是位置不同，并没有附加的含义；
- 树怎么形成的不重要：合并的时候任何一个集合的根结点指向另一个结合的根结点就可以；
- 树的形态不重要：理由同「谁作为根结点不重要」。

**代表元法可能造成的问题**

树的高度过高，查询性能降低。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251200945.png)



> 知识扩展：几乎所有的「树」的问题都在和「树的高度」较劲：
>
> - 「快速排序」，使用随机化 `pivot` 的方式避免递归树太深；
> - 「二叉搜索树」为了避免递归树太深，采用不同的旋转方式，得到了 AVL 树和红黑树。

解决方案有「按秩合并」与「路径压缩」，我们先介绍「按秩合并」。

#### 按秩合并

按「秩」合并的意思是：让树的「秩」较小的树的根结点，指向树的「秩」较大的树的根结点。

这里的「秩」有两种含义，分别用于不同的场景：

- 按 `size` 合并，用于需要维护每个连通分量结点个数的时候；
- 按 `rank` 合并，绝大多数时候。

**按 `size` 合并**

按 `size` 合并的意思是让树的「结点总数」较小的树的根结点，指向树的「结点总数」较大的树的根结点。

**按 `rank` 合并**

按 `rank` 合并的意思是让树的「高度」较小的树的根结点，指向树的「高度」较大的树的根结点。

之所以把「高度」称为 `rank` ，是因为同时使用「按秩合并」和「路径压缩」的时候，树的「高度」很难维护其准确的定义，但是依然可以作为合并时候的依据，因此成为「秩」。

#### 路径压缩

**路径压缩方式 1：隔代压缩**

「隔代压缩」的意思是：两步一跳，一直循环执行「把当前结点指向它的父亲结点的父亲结点」这样的操作。下面是一个例子。![image_1637826447](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251550121.gif)

这样的压缩并不彻底，但是多压缩几次，就可以达到压缩彻底的效果。



**路径压缩方式 2：完全压缩**

「完全压缩」的意思是：把从「查询结点」到「根结点」沿途经过的所有结点都指向根结点。「完全压缩」相比较于「隔代压缩」，压缩彻底。

![image_1637827685](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611341.gif)

![image_1637827856](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611270.gif)

#### 时间复杂度分析

**同时使用了「路径压缩」和「按秩合并」的时间复杂度**

并查集的时间复杂度分析，其理论性较强，通常只需要知道结论即可。这里我们给出结论：

同时使用按秩合并与路径压缩时，最坏情况的时间复杂度为 $O(m \alpha(n))$，这里 $\alpha(n)$ 是一个增长非常慢的函数，$\alpha(n) \le 4$

结论的具体介绍请见《算法导论》第 21.4 节《带路径压缩的按秩合并的分析》

可以 **感性** 地这样理解结论：由于路径压缩采用「一边查询，一边修改树结构」的策略，并且 **修改树的结构是不可逆的**，合并之前需要先查询再合并。如果次数非常多的话，最后并查集里所有的树的高度都只有 2，平均到每一次「合并」和「查询」操作，步骤是常数次的



### 岛问题

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

**朴素解法：DFS**

时间复杂度：O(n*m) 

- `m == grid.length`
- `n == grid[i].length`

分析：大遍历时遍历一次，被上下左右调用最多4次，常数次，所以是O(n*m)

**进阶：**

设计一个并行算法解决这个问题



#### 并行算法

创建一个并查集，把大的集合分割成多个小的集合，然后开启多个线程，并行把每个小集合都加入并查集中，最后再解决每个小集合之间的连通性的问题（判断两小集合边界元素是否可以连通）

![image-20220228141428057](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2022/02/202202281414164.png)

### MapReduce基本原理及应用

MapReduce将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数：Map和Reduce。它采用“分而治之”策略，一个存储在分布式文件系统中的大规模数据集，会被切分成许多独立的分片（split），这些分片可以被多个Map任务并行处理

```
public class UnionFindSet<V> {
    private class Element<V> {
        private V v;

        public Element(V v) {
            this.v = v;
        }
    }

    public HashMap<V, Element<V>> elementMap;
    public HashMap<Element<V>, Element<V>> fatherMap;
    public HashMap<Element<V>, Integer> sizeMap;

    // 初始化
    public UnionFindSet(List<V> list) {
        elementMap = new HashMap<>();
        fatherMap = new HashMap<>();
        sizeMap = new HashMap<>();
        for (V v : list) {
            Element<V> element = new Element<>(v);
            elementMap.put(v, element);
            fatherMap.put(element, element);
            sizeMap.put(element, 1);
        }
    }

    // 黑盒，查找头节点，并进行路径压缩(优化一)
    public Element<V> findHead(Element<V> element) {
        // 记录沿途节点
        Stack<Element<V>> path = new Stack<>();
        while (element != fatherMap.get(element)) {
            path.push(element);
            element = fatherMap.get(element);
        }
        // 修改沿途节点的头节点
        while (!path.isEmpty()) {
            fatherMap.put(path.pop(), element);
        }
        return element;
    }


    public boolean isSameSet(V a, V b) {
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
            return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
        }
        return false;
    }

    // 合并，小集合挂大集合（优化二）
    public void union(V a, V b) {
        if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
            // 取出a、b头节点
            Element<V> aF = findHead(elementMap.get(a));
            Element<V> bF = findHead(elementMap.get(b));
            // aF bF不同则合并
            if (aF != bF) {
                Element<V> big = sizeMap.get(aF) > sizeMap.get(bF) ? aF : bF;
                Element<V> small = big == aF ? bF : aF;
                fatherMap.put(small, big);
                sizeMap.put(big, sizeMap.get(big) + sizeMap.get(small));
                sizeMap.remove(small);
            }

        }
    }


}
```