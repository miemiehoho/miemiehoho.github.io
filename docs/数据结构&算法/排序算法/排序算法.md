# 总结

## 按时间复杂度分类

**时间复杂度$O(n^2)$级排序算法：**

- 直接插入排序
- 冒泡排序
- 选择排序

**时间复杂度$O(nlog^n)$级排序算法**

- 希尔排序
- 堆排序
- 快速排序
- 归并排序

**时间复杂度 $O(n)$ 级排序算法**

- 计数排序
- 基数排序
- 桶排序

## 时间复杂度$O(n^2)$级排序算法

### 直接插入排序

```java
/**
 * 直接插入排序 - 交换次数较少的实现
 * <p>
 * 1.从第二个元素开始，记录当前待排序元素为cur
 * 2.在已排序元素中，从后向前扫描，
 * 3.如果 已排序元素 不是第一个元素，且 已排序元素 大于cur，则将该已排序元素后移一位，否则就是找到了cur的位置，插入cur
 *
 * @param nums
 */
public void insertionSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];
        for (int j = i; j >= 0; j--) {
            if (j > 0 && nums[j - 1] > cur) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = cur;
                break;
            }
        }
    }
}
```

```java
/**
 * 直接插入排序-交换次数较多的实现
 *
 * @param nums
 */
public void insertionSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = i; j > 0; j--) {
            if (nums[j] >= nums[j - 1]) {
                break;
            }
            int temp = nums[j];
            nums[j] = nums[j - 1];
            nums[j - 1] = temp;
        }
    }
}
```



# 学习笔记

## 概述

> 参考资料：
>
> 1. https://blog.csdn.net/u010983881/article/details/76383527
> 2. https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97

### 十大排序算法

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/big-o.png)

### 常见的八大排序算法

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/1156494-ab4cecff133d87b3.png" alt="img" style="zoom:50%;" />

- 基于比较的排序算法

  - 选择排序

  - 冒泡排序

  - 插入排序

  - 归并排序

  - 快速排序

  - 堆排序

-  不基于比较的排序算法

  - 计数排序

  - 基数排序

### **稳定与非稳定**:

如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是 **稳定** 的。反之，则是 **非稳定** 的。

**排序算法的稳定性有什么意义呢？**

其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。

当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。

同样地，不稳定排序算法也可以经过修改，达到稳定的效果。思考一下，选择排序算法如何实现稳定排序呢？

实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。

但如果将寻找最小值的比较条件由arr[minIndex] > arr[j]修改为arr[minIndex] >= arr[j]，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。

# 时间复杂度$O(n^2)$级排序算法

## 直接插入排序（Insertion Sort）

插入排序的设计初衷是往有序的数组中快速插入一个新的元素。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.

插入排序由于操作不尽相同, 可分为 直接插入排序 , 折半插入排序(又称二分插入排序), 链表插入排序 , 希尔排序 。我们先来看下直接插入排序。


### 基本思想

直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。

### 算法描述

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

动态效果如下：

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/28749729-ca072084-7503-11e7-881c-92aa915ce369.gif)

算法实现中比较有意思的一点是，在每次比较操作发现取出来的新元素小于等于已排序的元素时，可以将已排序的元素移到下一位置，然后将取出来的新元素插入该位置（即相邻位置对调），接着再与前面的已排序的元素进行比较，如上图所示，这样做缺点是交换操作代价比较大。另一种做法是：将新元素取出（挖坑），从左到右依次与已排序的元素比较，如果已排序的元素大于取出的新元素，那么将该元素移动到下一个位置（填坑），接着再与前面的已排序的元素比较，直到找到已排序的元素小于等于新元素的位置，这时再将新元素插入进去。就像基本思想中的动图演示的那样。

**注意**：
如果 *比较操作* 的代价比 *交换操作* 大的话，可以采用[二分查找法](https://zh.wikipedia.org/wiki/二分查找法)来减少 *比较操作* 的数目。该算法可以认为是 **插入排序** 的一个变种，称为[二分查找插入排序](https://zh.wikipedia.org/w/index.php?title=二分查找插入排序&action=edit&redlink=1)。

### 代码实现

```java
/**
 * 直接插入排序-移动法:
 * 1.从第一个元素开始,该元素可以认为已经被排序
 * 2.取出下一个元素,在已经排序的元素序列中从后向前扫描
 * 3.如果该已排序元素大于新元素,将该已排序元素移到后一位置
 * 4.重复步骤3,直到找到已排序元素小于等于新元素的位置
 * 5.将新元素插入到该位置后一个位置
 * 6.重复步骤2~5
 */
public void insertionSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        int cur = nums[i];
        for (int j = i; j >= 0; j--) {
            if (j > 0 && nums[j - 1] > cur) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = cur;
                break;
            }
        }
    }
}
```

```java
// 交换次数较多的实现-交换法
public void insertionSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        for (int j = i; j > 0; j--) {
            if (nums[j] >= nums[j - 1]) {
                break;
            }
            int temp = nums[j];
            nums[j] = nums[j - 1];
            nums[j - 1] = temp;
        }
    }
}
```

### 时间复杂度 & 空间复杂度

直接插入排序复杂度如下：

- 最好情况下，排序前对象已经按照要求的有序。比较次数(KCN)：n−1；移动次数(RMN)为0。则对应的时间复杂度为O(n)

- 最坏情况下，排序前对象为要求的顺序的反序。第i趟时第i个对象必须与前面i个对象都做排序码比较，并且每做1次比较就要做1次数据移动（从上面给出的代码中看出）。比较次数(KCN)：<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112192028710.png" alt="image-20211111090156306" style="zoom: 80%;" />; 移动次数(RMN)为：<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112192028837.png" alt="image-20211111090156306" style="zoom: 80%;" />，则对应的时间复杂度为**$O(n^2)$**
  如果排序记录是随机的，那么根据概率相同的原则，在平均情况下的排序码比较次数和对象移动次数约为$n^2/2$，**因此，直接插入排序的平均时间复杂度为$O(n^2)$**

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| :------------: | :------: | :------: | :--------: |
|     O(n²)      |   O(n)   |  O(n²)   |    O(1)    |

**稳定性：** 

由于直接插入排序每次只移动一个元素的位置， 并不会改变值相同的元素之间的排序， 因此它**是一种稳定排序**。



## 冒泡排序（Bubble Sort）

### 基本思想

**冒泡排序**（英语：**Bubble Sort**）又称为**泡式排序**，是一种简单的[排序算法](https://zh.wikipedia.org/wiki/排序算法)。它重复地走访过要排序的[数列](https://zh.wikipedia.org/wiki/数列)，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

![冒泡排序演示](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/bubble-sort.gif)

### 算法描述

冒泡排序算法的运作如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 算法实现

冒泡排序需要两层循环,外循环移动游标,内循环遍历游标之前的所有元素,通过两两交换的方式,每次只确保该内循环结束位置排序正确,然后内循环周期结束,外层循环往前移动游标,随机开始下一次内循环,以此类推,直至循环结束

#### 冒泡排序的第一种写法

- 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；

```java
    /**
     * 冒泡排序
     *
     * @param nums
     */
    public void bubbleSort(int[] nums) {
        for (int i = nums.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[j + 1]) {
                    swap(nums, j, j + 1);
                }
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

#### 冒泡排序第二种写法

- 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；

```java
    /**
     * 冒泡排序
     *
     * @param nums
     */
    public void bubbleSort(int[] nums) {
        for (int i = nums.length - 1; i >= 0; i--) {
            boolean isSorted = false;
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[j + 1]) {
                    swap(nums, j, j + 1);
                    isSorted = true;
                }
            }
            if (!isSorted) {// 如果没有发生过交换，说明所有元素已经有序，排序完成
                break;
            }
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

#### 冒泡排序第三种写法

- 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。

```java
    /**
     * 冒泡排序
     *
     * @param nums
     */
    public void bubbleSort(int[] nums) {
        int swappedIndex = -1;//上一次发生交换的位置
        int lastUnsortedIndex = nums.length - 1;// 最后一个没有经过排序的位置
        boolean swapped = true;// 是否发生过交换
        while (swapped) {
            swapped = false;
            for (int i = 0; i < lastUnsortedIndex; i++) {
                if (nums[i] > nums[i + 1]) {
                    swap(nums, i, i + 1);// 交换
                    swappedIndex = i;// 更新交换的位置
                    swapped = true;// 表示发生了交换
                }
            }
            // 最后一个没有经过排序的位置就是上一次发生交换的位置
            lastUnsortedIndex = swappedIndex;
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

#### *附：交换的技巧

一般来说，交换数组中两个数字的函数如下：

```java
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
```

但在大厂面试中，有一道非常经典的数字交换题目：如何在不引入第三个中间变量的情况下，完成两个数字的交换。

这里可以用到一个数学上的技巧：

```java
arr[j + 1] = arr[j + 1] + arr[j];
arr[j] = arr[j + 1] - arr[j];
arr[j + 1] = arr[j + 1] - arr[j];
```

除了这种先加后减的写法，还有一种先减后加的写法：

```java
arr[j + 1] = arr[j] - arr[j + 1];
arr[j] = arr[j] - arr[j + 1];
arr[j + 1] = arr[j + 1] + arr[j];
```

但这两种方式都可能导致数字越界。

更好的方案是通过位运算完成数字交换：

**注意：**两数异或运算交换，两个数字不能相同，相同结果会变成零

```java
if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
    nums[j] = nums[j] ^ nums[i];
    nums[i] = nums[j] ^ nums[i];
    nums[j] = nums[j] ^ nums[i];
}
```

#### 时间复杂度 & 空间复杂度

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| :------------: | :------: | :------: | :--------: |
|     O(n²)      |   O(n)   |  O(n²)   |    O(1)    |

冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 

**注意:** 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是**稳定的排序算法**.

## 选择排序（Selection Sort）

### 基本思想

**选择排序**（Selection sort）是一种简单直观的[排序算法](https://zh.wikipedia.org/wiki/排序算法)。选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对${\displaystyle n}$个元素的表进行排序总共进行至多${\displaystyle (n-1)}$次交换。**在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。**

### 算法描述

具体算法描述如下：

1. 从待排序序列中找到最小的元素，交换到排序序列的起始位置
2. 从剩余待排序元素中找到最小的元素，放到已排序序列的末尾
3. 重复步骤2，直到所有元素均排序完成

### 算法实现

选择排序就好比第一个数字站在擂台上，大吼一声：“还有谁比我小？”。剩余数字来挨个打擂，如果出现比第一个数字小的数，则新的擂主产生。每轮打擂结束都会找出一个最小的数，将其交换至首位。经过 n-1 轮打擂，所有的数字就按照从小到大排序完成了。

```java
    /**
     * 选择排序
     *
     * @param nums
     */
    public void selectionSort(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            int minIdx = i;
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[j] < nums[minIdx]) {
                    minIdx = j;
                }
            }
            swap(nums, i, minIdx);
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

#### 二元选择排序

我们使用 minIndex 记录最小值的下标，maxIndex 记录最大值的下标。每次遍历后，将最小值交换到首位，最大值交换到末尾，就完成了排序。

由于每一轮遍历可以排好两个数字，所以最外层的遍历只需遍历一半即可。

二元选择排序中有一句很重要的代码，它位于交换最小值和交换最大值的代码中间：

```java
if (maxIndex == i) maxIndex = minIndex;
```

这行代码的作用处理了一种特殊情况：如果最大值的下标等于 i，也就是说 arr[i] 就是最大值，由于 arr[i] 是当前遍历轮次的首位，它已经和 arr[minIndex] 交换了，所以最大值的下标需要跟踪到 arr[i] 最新的下标 minIndex。

```java
    /**
     * 二元选择排序
     *
     * @param nums
     */
    public void selectionSort(int[] nums) {
        for (int i = 0; i < nums.length / 2; i++) {
            int minIdx = i;
            int maxIdx = i;
            for (int j = i + 1; j < nums.length - i; j++) {
                if (nums[j] < nums[minIdx]) {
                    minIdx = j;
                }
                if (nums[j] > nums[maxIdx]) {
                    maxIdx = j;
                }
            }
            if (maxIdx == minIdx) {// 最大值等于最小值，说明完成了排序
                break;
            }
            swap(nums, i, minIdx);
            if (maxIdx == i) {// 如果maxIdx恰好是i，此时maxIdx已经交换到了minIdx的位置
                maxIdx = minIdx;
            }
            swap(nums, nums.length - i - 1, maxIdx);
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

### 时间复杂度 & 空间复杂度

选择排序的交换操作介于${\displaystyle 0}$和${\displaystyle (n-1)}$次之间。选择排序的比较操作为${\displaystyle n(n-1)/2}$次。选择排序的赋值操作介于${\displaystyle 0}$和${\displaystyle 2(n-1)}$次之间。

**Tips:**选择排序的赋值操作**WiKi**上说是0到3(n-1)之间，我认为是0到2(n-1)

比较次数${\displaystyle O(n^{2})}$，比较次数与关键字的初始状态无关，总的比较次数${\displaystyle N=(n-1)+(n-2)+...+1=n\times (n-1)/2}$0)。交换次数${\displaystyle O(n)}$，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换${\displaystyle n-1}$次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，${\displaystyle n}$值较小时，选择排序比冒泡排序快。

原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见

|              | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| ------------ | -------------- | -------- | -------- | ---------- |
| 选择排序     | $O(n^2)$       | $O(n^2)$ | $O(n^2)$ | $O(1)$     |
| 二元选择排序 | $O(n^2)$       | $O(n^2)$ | $O(n^2)$ | $O(1)$     |

**稳定性：**

选择排序法是不稳定的，二元选择排序也是不稳定的。



# 时间复杂度$O(nlog^n)$级排序算法

## 希尔排序（Shell Sort）

> 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。

**希尔排序**（Shellsort），也称**递减增量排序算法**，是[插入排序](https://zh.wikipedia.org/wiki/插入排序)的一种更高效的改进版本。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到[线性排序](https://zh.wikipedia.org/w/index.php?title=線性排序&action=edit&redlink=1)的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

### 基本思想

将数组列在一个表中并对列排序（用[插入排序](https://zh.wikipedia.org/wiki/插入排序)）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用`i += step_size`而不是`i++ `）

**有一条非常重要的性质保证了希尔排序的效率：**

- 「$D_{k+1}$ 间隔」 有序的序列，在经过 「$D_k$间隔」 排序后，仍然是 「$D_{k+1}$间隔」 有序的

**注意：**

增量序列的选择会极大地影响希尔排序的效率

一般来说最简单的步长取值是**初次取数组长度的一半**，之后每次再减半，直到步长为1。更好的步长序列取值可以参考[维基百科](https://zh.wikipedia.org/wiki/希尔排序#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97)。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/3FECzUNTxcilqPg.png)

在这个例子中，我们发现，原数组 8 间隔、4 间隔、2 间隔都已经有序了，使用希尔排序时，真正起作用的只有最后一轮 1 间隔排序，也就是直接插入排序。希尔排序反而比直接使用插入排序多执行了许多无用的逻辑。

于是人们发现：**增量元素不互质，则小增量可能根本不起作用。**

### 算法描述

具体算法描述：

1. 初始化步长step
2. 对当前步长下的所有列应用直接插入排序
3. 缩减步长
4. 重复步骤2~3

### 算法实现

**逐列排序法**

```java
/**
 * 希尔排序
 * 将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了
 *
 * @param nums 待排序数组
 */
public static void shellSort(int[] nums) {
    for (int step = nums.length / 2; step > 0; step /= 2) {// 步长,不断缩小步长，直到1为止
        // 对当前步长下所有列进行逐列排序
        for (int i = 0; i < step; i++) {// 当前步长下的所有列的第一个元素下标
            // 对当前列进行直接插入排序
            for (int j = i + step; j < nums.length; j += step) {//取出当前需要排序的元素
                int temp = nums[j];//当前需要排序的元素
                for (int k = j; k >= i; k -= step) {// 在已经排序的序列中从后向前扫描
                    if (k > i && nums[k - step] > temp) {// 该已排序元素大于新元素,将该已排序元素移动到后一位置
                        nums[k] = nums[k - step];
                    } else {
                        nums[k] = temp;// 找到已排序元素小于等于新元素的位置,将新元素插入到后一个位置
                        break;
                    }
                }
            }
        }
    }
}
```

**逐行排序法**

```java
/**
 * WiKi百科实现方式
 *
 * @param arr
 */i
public static void shellSort(int[] arr) {
    int length = arr.length;
    int temp;
    for (int step = length / 2; step >= 1; step /= 2) {// 步长，不断缩减步长，直到1为止
        // 对所有列进行直接插入排序，逐行排序法
        for (int i = step; i < length; i++) {// 当前步长下，当前排序次数下，所有列的待排序元素下标
            temp = arr[i];// 当前需要排序的元素
            int j = i - step;// 当前排序次数下，当前列的第一个元素下标
            while (j >= 0 && arr[j] > temp) {
                arr[j + step] = arr[j];
                j -= step;
            }
            arr[j + step] = temp;
        }
    }
}
```

```java
// 希尔排序，增量：kunth
public int[] sortArray(int[] nums) {
    int len = nums.length;
    int kunth = 1;
    while (kunth <= len / 3) {
        kunth = 3 * kunth + 1;
    }
    for (int step = kunth; step >= 1; step = (step - 1) / 3) {
        for (int i = step; i < len; i++) {
            int cur = nums[i];
            int preIdx = i - step;
            while (preIdx >= 0 && nums[preIdx] > cur) {
                nums[preIdx + step] = nums[preIdx];
                preIdx -= step;
            }
            nums[preIdx + step] = cur;
        }
    }
    return nums;
}
```

### 时间复杂度 & 空间复杂度

事实上，希尔排序时间复杂度非常难以分析，它的平均复杂度界于 $O(n) 到 O(n^2)$ 之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$。

希尔排序的空间复杂度为 $O(1)$，只需要常数级的临时变量。

| 增量序列             | 步长序列                                                     | 平均时间复杂度 |    最好情况    |   最坏情况   | 空间复杂度 |
| -------------------- | ------------------------------------------------------------ | :------------: | :------------: | :----------: | :--------: |
| `Sedgewick` 增量序列 | $2^i3^j$<br />也就是1,5,19,41,109,...，                      |  $O(n^{7/6})$  | $O(n(logn)^2)$ | $O(n^{4/3})$ |   $O(1)$   |
| `Hibbard` 增量序列   | $2^k-1$<br />也就是1、3、7、15，……                           |  $O(n^{5/4})$  |                | $O(n^{3/2})$ |   $O(1)$   |
| `Knuth` 增量序列     | $D_1=1;D_{k+1}=3*D_k+1，$也就是 {1, 4, 13, 40, ...}1,4,13,40,...， |  $O(n^{3/2})$  |                |              |            |
|                      | $n/2^i$                                                      |                |                |   $O(n^2)$   |   $O(1)$   |

**注意：**由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以**shell排序是不稳定的**。

### 希尔排序与 $O(n^2)$ 级排序算法的本质区别

这个问题我们可以用逆序对来理解。

> 当我们从小到大排序时，在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。

排序算法本质上就是一个消除逆序对的过程。

对于随机数组，逆序对的数量是 $O(n^2)$级的，如果采用「交换相邻元素」的办法来消除逆序对，每次最多只能消除一组逆序对，因此必须执行 $O(n^2)$ 级的交换次数，这就是为什么冒泡、插入、选择算法只能到 $O(n^2)$级的原因。反过来说，基于交换元素的排序算法要想突破 $O(n^2)$级，必须通过一些比较，交换间隔比较远的元素，使得一次交换能消除一个以上的逆序对。

希尔排序算法就是通过这种方式，打破了在空间复杂度为 $O(1)$的情况下，时间复杂度为 $O(n^2)$的魔咒，此后的快排、堆排等等算法也都是基于这样的思路实现的。

> 注：
>
> 1.虽然约翰·冯·诺伊曼在 1945 年提出的归并排序已经达到了 $O(n\log n)$ 的时间复杂度，但归并排序的空间复杂度为 $O(n)$，采用的是空间换时间的方式突破 $O(n^2)$
>
> 2.希尔排序在面试或是实际应用中都很少遇到，读者仅需了解即可。

## 堆排序（Heap Sort）

### 基本思想

**堆排序**（英语：Heapsort）是指利用[堆](https://zh.wikipedia.org/wiki/堆_(数据结构))这种数据结构所设计的一种[排序算法](https://zh.wikipedia.org/wiki/排序算法)。堆是一个近似[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)的结构，并同时满足**堆的性质**：即子节点的键值或索引总是小于（或者大于）它的父节点。

### 算法描述

#### 堆节点的访问

通常堆是通过一维[数组](https://zh.wikipedia.org/wiki/数组)来实现的。在数组起始位置为0的情形中：

- 父节点i的左子节点在位置${\displaystyle (2i+1)}$
- 父节点i的右子节点在位置${\displaystyle (2i+2)}$
- 子节点i的父节点在位置${\displaystyle \lfloor (i-1)/2\rfloor }$

#### 堆的操作

在堆的[数据结构](https://zh.wikipedia.org/wiki/資料結構)中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：

- 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
- 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序
- 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的[递归](https://zh.wikipedia.org/wiki/遞迴)运算

**堆排序**过程如下：

- 用数列构建出一个大顶堆，取出堆顶的数字；
- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；
- 循环往复，完成整个排序。

### 算法实现

```java
    /**
     * 堆排序
     *
     * @param nums
     */
    public void heapSort(int[] nums) {
        // 构建初始大顶堆，从最后一个非叶子节点开始,叶子节点可以看作符合堆要求的节点
        for (int i = nums.length / 2 - 1; i >= 0; i--) {
            maxHeapify(nums, i, nums.length);
        }
        // 对堆数据排序，每次将堆顶节点与堆尾节点交换，同时堆长度-1，直到堆长度为1
        for (int i = nums.length - 1; i >= 0; i--) {
            swap(nums, 0, i);            // 交换堆顶和堆尾元素位置
            maxHeapify(nums, 0, i);
        }
    }

    /**
     * 调整大顶堆
     *
     * @param nums     完全二叉树数组
     * @param i        需要调整的堆元素节点
     * @param heapSize 需要调整的堆的长度
     */
    private void maxHeapify(int[] nums, int i, int heapSize) {
        // 当需要调整的节点不是叶子节点时
        while (i < heapSize / 2) {
            // 左子节点下标
            int left = i * 2 + 1;
            // 右子节点下标
            int right = left + 1;
            // 当需要调整的节点小于其孩子节点，将其与孩子节点交换
            int maxIdx = left;// 默认左子节点为最大节点
            if (right < heapSize && nums[right] > nums[maxIdx]) {
                maxIdx = right;
            }
            if (nums[maxIdx] < nums[i]) {// 父节点大于子节点，直接跳出
                break;
            }
            swap(nums, i, maxIdx);
            i = maxIdx;
        }
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

### 时间复杂度 & 空间复杂度

堆排序分为两个阶段：初始化建堆（`buildMaxHeap`）和重建堆（`maxHeapify`，直译为大顶堆化），所以时间复杂度要从这两个方面分析

- 初始化建堆的时间复杂度为 $O(n)$ 这里是指**渐进时间复杂度**，有严格的数学证明过程，重建堆的时间复杂度为 $O(n\log^n)$，所以堆排序总的时间复杂度为 $O(n\log^n)$
- 堆排序的空间复杂度为 O(1)，只需要常数级的临时变量

| 平均时间复杂度 |  最好情况   |  最坏情况   | 空间复杂度 |
| :------------: | :---------: | :---------: | :--------: |
|  $O(nlog^n)$   | $O(nlog^n)$ | $O(nlog^n)$ |   $O(1)$   |

**稳定性：**

**由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.** 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.

#### Java PriorityQueue 时间复杂度

- Binary heap （二叉树堆）, Java默认使用, 也就是第一行。
- [Fibonacci heap](https://www.cnblogs.com/junyuhuang/p/4463758.html) （斐波那契堆），[Strict Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_heap)（严格斐波那契堆）**理论性能最好 --> 记住大体概念，结论即可**。
- [Binomial heap](https://www.cnblogs.com/xuqiang/archive/2011/06/01/2065549.html)（二项堆）

*PriorityQueue*的

- peek()和element操作是常数时间，
- add(),offer(), 无参数的remove()以及poll()方法的时间复杂度都是$O(log^n)$
- contains(Object o) 和 remove(Object o) 会调用 indexOf() 方法，遍历一遍数组，时间复杂度为 $O(n)$

**indexOf() 方法源码：**

```java
private int indexOf(Object o) {
    if (o != null) {
        for (int i = 0; i < size; i++)
            if (o.equals(queue[i]))
                return i;
    }
    return -1;
}
```

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112221452885.png)





### 荷兰国旗问题

#### 问题一(不是荷兰国旗问题)

给定一个数组arr，和一个数num，请把小于等于num的数放在数 组的左边，大于num的 数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N) 

#### 问题二(荷兰国旗问题，分三块) 

给定一个数组arr，和一个数num，请把小于num的数放在数组的 左边，等于num的数放 在数组的中间，大于num的数放在数组的 右边。要求额外空间复杂度O(1)，时间复杂度 O(N)

#### 算法描述

**情况划分：**

1. 当前数 < 划分值
   - 当前数和 小于区域的下一个数做交换，小于区域向右扩一个位置，当前数跳下一个
2. 当前数 = 划分值
   - 当前数直接跳下一个
3. 当前数 > 划分值
   - 当前数与大于区域前一个数做交换，大于区域向左扩一个位置，当前数停在原地不动

#### 算法实现

```java
// 荷兰国旗问题，分三块
// 在 arr[L...R] 范围上，根据 p 分块
// 返回值含义：长度为2的数组，记录等于区域的左边界和右边界
// 如果无等于区域，返回值 左边界 > 右边界
public int[] partition(int[] arr, int L, int R, int p) {
    int less = L - 1;// 小于区域的右边界
    int more = R + 1;// 大于区域的左边界
    int idx = L;// 当前数
    while (idx < more) {
        if (arr[idx] < p) {
            swap(arr, ++less, idx++);
        } else if (arr[idx] > p) {
            swap(arr, --more, idx);
        } else {
            idx++;
        }
    }
    return new int[]{less + 1, more - 1};
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### 时间复杂度

时间复杂度：$O(n)$



## 快速排序（Quick Sort）

快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。

### 基本思想

快速排序使用[分治法](https://zh.wikipedia.org/wiki/分治法)（Divide and conquer）策略来把一个[序列](https://zh.wikipedia.org/wiki/序列)（list）分为较小和较大的2个子序列，然后递归地排序两个子序列

#### 快排 1.0

拿数组最后一个数(p)做划分值，使小于等于 p 的在左侧，大于p的在右侧，最后一个数是 p,然后交换 小于等于 p 的最后一个数 和 p，然后分别递归 左右两侧区间



快排 1.0 每次只搞定了一个数

![image-20211228095447147](C:\Users\13686\AppData\Roaming\Typora\typora-user-images\image-20211228095447147.png)



#### 快排 2.0

每次 partition 使 小于 p 的在左边，等于 p 的在中间 ，大于 p 的在右边，然后分别递归小于 p 和大于p 的区间



快排 2.0 每次搞定了 等于 p 的一坨数

**平均情况**

时间复杂度:

$T(n) = T(n/2)+ O(n) = ... =O(n*log^n)$

**最差情况**

时间复杂度:$O(n^2)$

每次选择最后一个数做划分值，且数组中只有 小于 划分值 p 的数，使得左右两侧区域过于悬殊，则时间复杂度：

$T(n) = T(n-1)+ O(n) = ... = O(n^2)$

例： [1,2,3,4,5,6,7,8,9]

##### 时间复杂度

时间复杂度按照最差情况估算，所以不管是快排1.0还是2.0,时间复杂度都是$O(n^2)$

#### 快排 3.0

选择区间内一个随机元素作为基数

##### 时间复杂度

$O(n*log^n)$

每种情况（包括坏情况和好情况）都是概率事件，且每种情况的权重都占 $1/n$, 最终在 数学上证明时间复杂度收敛于$O(n*log^n)$

##### 空间复杂度

$O(log^n)到O(n),平均为O(log^n)$

### 算法描述

快速排序算法的基本步骤：

1. 从数组中取出一个数，称之为基数（pivot）
2. 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域
3. 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成

### 算法实现

#### 快排第一种写法

```java
public void quickSort(int[] nums) {
    quickSort(nums, 0, nums.length - 1);
}

private void quickSort(int[] nums, int l, int r) {
    if (l < r) {
        swap(nums, (int) (l + Math.random() * (r - l + 1)), r);// 随机选取基准值
        int[] p = partition(nums, l, r);// 基准值区域左右边界
        // 递归左右两侧区域
        quickSort(nums, l, p[0] - 1);
        quickSort(nums, p[1] + 1, r);
    }
}

// nums[r] 做划分值
private int[] partition(int[] nums, int l, int r) {
    int less = l - 1;// 小于区域右边界
    int more = r;// 大于区域左边界
    int idx = l;
    while (idx < more) {
        if (nums[idx] < nums[r]) {
            swap(nums, ++less, idx++);// 交换到小于区域,小于区域右边界+1
        } else if (nums[idx] > nums[r]) {
            swap(nums, --more, idx);// 交换到大于区域，大于区域左边界-1
        } else {
            idx++;// nums[l] 处于等于区域，l+1
        }
    }
    swap(nums, more, r);
    return new int[]{less + 1, more};// 返回等于区域左右边界
}

private void swap(int[] nums, int a, int b) {
    if (nums[a] != nums[b]) {
        nums[b] ^= nums[a];
        nums[a] ^= nums[b];
        nums[b] ^= nums[a];
    }
}
```

#### 快排第二种写法

```java
    // 快速排序
    public void quickSort(int[] nums) {
        partition(nums, 0, nums.length - 1);
    }

    /**
     * 取数组第一个数为基数（pivot）
     * 遍历数组，比基数小的放到它的左边，比基数大的放到右边
     * 递归这一过程，直到排序完成
     *
     * @param nums
     * @param start
     * @param end
     */
    private void partition(int[] nums, int start, int end) {
        if (start >= end) {
            return;
        }
        int pivot = nums[start];//基准值
        int l = start, r = end;
        while (l < r) {
            while (l < r && nums[r] >= pivot) {//从右边往左找到第一个小于基准值的数
                r--;
            }
            while (l < r && nums[l] <= pivot) {//从左往右找到第一个大于基准值的数
                l++;
            }
            if (l < r) {//交换
                swap(nums, l, r);
            }
        }
        swap(nums, start, l);
        partition(nums, start, l - 1);// 递归调用左半部分
        partition(nums, l + 1, end);// 递归调用右半部分
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```



### 基数的选择

#### **基数的选择方式**

基数的选择没有固定标准，随意选择区间内任何一个数字做基数都可以。通常来讲有三种选择方式：

1. 选择第一个元素作为基数

2. 选择最后一个元素作为基数
3. 选择区间内一个随机元素作为基数

选择的基数不同，算法的实现也不同。实际上**第三种选择方式的平均时间复杂度是最优的**

#### **当数组原本有序时，快排的时间复杂度将会达到$O(n^2)$：**

当数组原本为正序或逆序时，我们将第一个数作为基数的话，每轮分区后，都有一个区域是空的，也就是说数组中剩下的数字都被分到了同一个区域！这就导致了每一轮遍历只能排好一个基数。所以总的比较次数为 $(n - 1) + (n - 2) + (n - 3) + ... + 1$ 次，由等差数列求和公式可以计算出总的比较次数为 $n(n - 1)/2$ 次，此时快速排序的时间复杂度达到了 $O(n^2)$ 级。

#### 快速排序的优化思路

**优化方式一**

每轮选择基数时，从剩余的数组中随机选择一个数字作为基数，用这种方式选择基数，其平均时间复杂度是最优的

**优化方式二**

在排序之前，先用**洗牌算法**将数组的原有顺序打乱，以防止原数组正序或逆序

Java 已经将洗牌算法封装到了集合类中，即 `Collections.shuffle()` 函数,洗牌算法由 Ronald A.Fisher 和 Frank Yates 于 1938 年发明，思路是每次从未处理的数据中随机取出一个数字，然后把该数字放在数组中所有未处理数据的尾部。 Collections.shuffle() 函数源码如下：

```java
private static final int SHUFFLE_THRESHOLD        =    5;
/**
 * Randomly permute the specified list using the specified source of
 * randomness.  All permutations occur with equal likelihood
 * assuming that the source of randomness is fair.<p>
 *
 * This implementation traverses the list backwards, from the last element
 * up to the second, repeatedly swapping a randomly selected element into
 * the "current position".  Elements are randomly selected from the
 * portion of the list that runs from the first element to the current
 * position, inclusive.<p>
 *
 * This method runs in linear time.  If the specified list does not
 * implement the {@link RandomAccess} interface and is large, this
 * implementation dumps the specified list into an array before shuffling
 * it, and dumps the shuffled array back into the list.  This avoids the
 * quadratic behavior that would result from shuffling a "sequential
 * access" list in place.
 *
 * @param  list the list to be shuffled.
 * @param  rnd the source of randomness to use to shuffle the list.
 * @throws UnsupportedOperationException if the specified list or its
 *         list-iterator does not support the <tt>set</tt> operation.
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public static void shuffle(List<?> list, Random rnd) {
    int size = list.size();
    if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {
        for (int i=size; i>1; i--)
            swap(list, i-1, rnd.nextInt(i));
    } else {
        Object[] arr = list.toArray();

        // Shuffle array
        for (int i=size; i>1; i--)
            swap(arr, i-1, rnd.nextInt(i));

        // Dump array back into list
        // instead of using a raw type here, it's possible to capture
        // the wildcard but it will require a call to a supplementary
        // private method
        ListIterator it = list.listIterator();
        for (int i=0; i<arr.length; i++) {
            it.next();
            it.set(arr[i]);
        }
    }
}

/**
 * Swaps the elements at the specified positions in the specified list.
 * (If the specified positions are equal, invoking this method leaves
 * the list unchanged.)
 *
 * @param list The list in which to swap elements.
 * @param i the index of one element to be swapped.
 * @param j the index of the other element to be swapped.
 * @throws IndexOutOfBoundsException if either <tt>i</tt> or <tt>j</tt>
 *         is out of range (i &lt; 0 || i &gt;= list.size()
 *         || j &lt; 0 || j &gt;= list.size()).
 * @since 1.4
 */
@SuppressWarnings({"rawtypes", "unchecked"})
public static void swap(List<?> list, int i, int j) {
    // instead of using a raw type here, it's possible to capture
    // the wildcard but it will require a call to a supplementary
    // private method
    final List l = list;
    l.set(i, l.set(j, l.get(i)));
}

/**
 * Swaps the two specified elements in the specified array.
 */
private static void swap(Object[] arr, int i, int j) {
    Object tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

从源码中可以看出，对于数据量较小的列表（少于 5 个值），shuffle 函数直接通过列表的 set 方法进行洗牌，否则先将 list 转换为 array，再进行洗牌，以提高交换效率，洗牌完成后再将 array 转成 list 返回。

**优化方式三**

既然数组重复排序的情况如此常见，那么我们可以在快速排序之前先对数组做个判断，如果已经有序则直接返回，如果是逆序则直接倒序即可。在 Java 内部封装的 `Arrays.sort()` 的源码中就采用了此解决方案。

### 快排变形

```java
    /**
     * 快排变形，求第K大的数
     *
     * @param nums
     * @param start
     * @param end
     * @param k
     * @return
     */
    public int quickSearch(int[] nums, int start, int end, int k) {
        int j = partition(nums, start, end);
        if (j == k) {
            return nums[j];
        }
        return j > k ? quickSearch(nums, start, j - 1, k) : quickSearch(nums, j + 1, end, k);
    }

    /**
     * 取数组第一个数为基数（pivot）
     * 遍历数组，比基数小的放到它的左边，比基数大的放到右边
     * 递归这一过程，直到排序完成
     *
     * @param nums
     * @param start
     * @param end
     */
    private int partition(int[] nums, int start, int end) {
        int p = new Random().nextInt(end - start + 1) + start;
        swap(nums, start, p);
        int pivot = nums[start];
        int l = start, r = end + 1;
        while (l < r) {
            while (++l <= end && nums[l] < pivot) ;
            while (--r >= start && nums[r] > pivot) ;
            if (l < r) {
                swap(nums, l, r);
            }
        }
        swap(nums, start, r);
        return r;
    }

    private void swap(int[] nums, int i, int j) {
        // 引入第三个变量写法
//        int temp = nums[i];
//        nums[i] = nums[j];
//        nums[j] = temp;
        // 如何在不引入第三个中间变量的情况下完成两个数字的交换
        // 先加后减写法-可能导致数字越界
//        nums[j] = nums[i] + nums[j];
//        nums[i] = nums[j] - nums[i];
//        nums[j] = nums[j] - nums[i];
        // 先减后加写法-可能导致数字越界
//        nums[j] = nums[j] - nums[i];
//        nums[i] = nums[j] + nums[i];
//        nums[j] = nums[i] - nums[j];
        // 位运算写法
        if (nums[i] != nums[j]) {//两数异或运算交换，两个数字不能相同，相同结果会变成零
            nums[j] = nums[j] ^ nums[i];
            nums[i] = nums[j] ^ nums[i];
            nums[j] = nums[j] ^ nums[i];
        }
    }
```

### 时间复杂度 & 空间复杂度

快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为$O(nlog^n)$, 比同样为$O(nlog^n)$时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高.

时间复杂度：概率累加

空间复杂度：概率累加

快排1.0 和 快排 2.0版本，其**最差**时间复杂度是 $O(n^2)$

快排 3.0版本，每次partion的坏情况和好情况都是概率事件，而且每种情况的权重都占 n/1，最终在数学上可以证明其实际复杂度收敛于 $O(nlog^n)$

| 平均时间复杂度 |  最好情况   | 最坏情况 |                          空间复杂度                          |
| :------------: | :---------: | :------: | :----------------------------------------------------------: |
|  $O(nlog^n)$   | $O(nlog^n)$ | $O(n^2)$ | $O(log^n)到O(n)$,空间复杂度与递归的层数有关<br />$O(1)$（原地分区递归版） |

**稳定性：**

同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.

## 归并排序（Merge Sort）

**归并排序**（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的[排序算法](https://zh.wikipedia.org/wiki/排序算法)，[效率](https://zh.wikipedia.org/wiki/时间复杂度)为${\displaystyle O(n\log n)}$,1945年由[约翰·冯·诺伊曼](https://zh.wikipedia.org/wiki/约翰·冯·诺伊曼)首次提出。该算法是采用[分治法](https://zh.wikipedia.org/wiki/分治法)（Divide and Conquer)的一个非常典型的应用，且各层分治递归可以同时进行。

采用分治法:

- 分割：递归地把当前序列平均分割成两半。
- 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。

### 基本思想

归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。

![Merge-sort-example-300px](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111152307440.gif)

### 算法描述

**递归法（Top-down）**

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

**迭代法（Bottom-up）**

原理如下（假设序列共有${\displaystyle n}$个元素)：

1. 将序列每相邻两个数字进行归并操作，形成${\displaystyle ceil(n/2)}$个序列，排序后每个序列包含两/一个元素
2. 若此时序列数不是1个则将上述序列再次归并，形成${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素
3. 重复步骤2，直到所有元素排序完毕，即序列数为1

### 算法实现

**递归实现**

```java
public void mergeSort(int[] nums) {
    if (nums.length <= 1) {
        return;
    }
    mergeSort(nums, 0, nums.length - 1, new int[nums.length]);
}

/**
 * 拆分-归并排序
 *
 * @param nums
 * @param start
 * @param end
 * @param result
 */
public void mergeSort(int[] nums, int start, int end, int[] result) {
    if (start >= end) {// 只剩下一个数字，停止拆分，返回这个数字
        return;
    }
    int middle = (start + end) >> 1;
    //  拆分左右区域,并将归并排序的结果保存到result的start到middle区间，middle+1到end区间
    mergeSort(nums, start, middle, result);
    mergeSort(nums, middle + 1, end, result);
    merge(nums, start, end, result);
}

/**
 * 将两个有序数组合并为一个有序数组
 *
 * @param nums
 * @param start
 * @param end
 * @param result
 * @return
 */
private void merge(int[] nums, int start, int end, int[] result) {
    // 数组1、2的首尾下标
    int start1 = start;
    int end1 = (start + end) >> 1;
    int start2 = end1 + 1;
    int idx = start;// 结果数组指针
    while (start1 <= end1 && start2 <= end) {
        if (nums[start1] <= nums[start2]) {
            result[idx++] = nums[start1++];
        } else {
            result[idx++] = nums[start2++];
        }
    }
    // 将剩余数添加到result数组
    while (start1 <= end1) {
        result[idx++] = nums[start1++];
    }
    while (start2 <= end) {
        result[idx++] = nums[start2++];
    }
    // 将result操作区间的数组拷贝到原数组，方便下次比较
    while (start <= end) {
        nums[start] = result[start++];
    }
}
```

**维基百科实现-递归版**

```java
static void merge_sort_recursive(int[] arr, int[] result, int start, int end) {
	if (start >= end)
		return;
	int len = end - start, mid = (len >> 1) + start;
	int start1 = start, end1 = mid;
	int start2 = mid + 1, end2 = end;
	merge_sort_recursive(arr, result, start1, end1);
	merge_sort_recursive(arr, result, start2, end2);
	int k = start;
	while (start1 <= end1 && start2 <= end2)
		result[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
	while (start1 <= end1)
		result[k++] = arr[start1++];
	while (start2 <= end2)
		result[k++] = arr[start2++];
	for (k = start; k <= end; k++)
		arr[k] = result[k];
}
public static void merge_sort(int[] arr) {
	int len = arr.length;
	int[] result = new int[len];
	merge_sort_recursive(arr, result, 0, len - 1);
}
```

**维基百科实现-迭代版**

```java
public static void merge_sort(int[] arr) {
	int[] orderedArr = new int[arr.length];
	for (int i = 2; i < arr.length * 2; i *= 2) {
		for (int j = 0; j < (arr.length + i - 1) / i; j++) {
			int left = i * j;
			int mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);
			int right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);
			int start = left, l = left, m = mid;
			while (l < mid && m <= right) {
				if (arr[l] < arr[m]) {
					orderedArr[start++] = arr[l++];
				} else {
					orderedArr[start++] = arr[m++];
				}
			}
			while (l < mid)
				orderedArr[start++] = arr[l++];
			while (m <= right)
				orderedArr[start++] = arr[m++];
			System.arraycopy(orderedArr, left, arr, left, right - left + 1);
		}
	}
}
```

### 时间复杂度 & 空间复杂度

归并排序的复杂度比较容易分析，拆分数组的过程中，会将数组拆分 $logn$ 次，每层执行的比较次数都约等于 $n$ 次，所以时间复杂度是 $O(nlogn)$

空间复杂度是 $O(n)$，主要占用空间的就是我们在排序前创建的长度为 n 的 result 数组。


| 平均时间复杂度 |  最好情况   |  最坏情况   | 空间复杂度 |
| :------------: | :---------: | :---------: | :--------: |
|  $O(nlog^n)$   | $O(nlog^n)$ | $O(nlog^n)$ |   $O(n)$   |

**稳定性：**

```java
if (nums[start1] <= nums[start2]) {
    result[idx++] = nums[start1++];
}
```

归并排序是一种稳定的排序算法，通过代码 `nums[start1] <= nums[start2]`来合并两个有序数组，保证了原数组中，相同的元素相对顺序不会变化

**小结：**

总结起来，归并排序分成两步，一是拆分数组，二是合并数组，它是分治思想的典型应用。

由于性能较好，且排序稳定，归并排序应用非常广泛，`Arrays.sort()` 源码中的 `TimSort`就是归并排序的优化版。



## 排序算法总结

### 时间复杂度$O(n^2)$级排序算法

三种基础排序算法：冒泡排序、选择排序、插入排序。

#### 冒泡排序

冒泡排序有两种优化方式：

- 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序；

- 记录上次发生交换的位置，下一轮排序时只比较到此位置。

#### 选择排序

选择排序可以演变为二元选择排序：

- 二元选择排序：一次遍历选出两个值——最大值和最小值；

- 二元选择排序剪枝优化：当某一轮遍历出现最大值和最小值相等，表示数组中剩余元素已经全部相等。

#### 插入排序

插入排序有两种写法：

- 交换法：新数字通过不断交换找到自己合适的位置；
- 移动法：旧数字不断向后移动，直到新数字找到合适的位置。

#### 相同点

- 时间复杂度都是 $O(n^2)$ ，空间复杂度都是 $O(1)$。
- 都需要采用两重循环

#### 不同点

- 选择排序是不稳定的，冒泡排序、插入排序是稳定的；
- 在这三个排序算法中，选择排序交换的次数是最少的；
- 在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。

### 时间复杂度$O(nlog^n)$级排序算法

四种优秀的排序算法：希尔排序、堆排序、快速排序、归并排序

#### 希尔排序

- 希尔排序是一个承上启下的算法，通过交换间隔较远的元素，使得一次交换能消除一个以上的逆序对，打破了在空间复杂度为 $O(1)$ 的情况下，时间复杂度 $O(n^2)$ 的魔咒。它启发出了后续一系列时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$ 的排序算法。
- 希尔排序本质上是插入排序的优化，先对间隔较大的元素进行插入排序，完成宏观调控，然后逐步缩小间隔，最后一轮一定是间隔为 1 的排序，也就是插入排序。间隔在希尔排序中被称为「增量」，增量序列不同，希尔排序的效率也不同。

#### 堆排序

堆排序分为两步：初始化建堆、重建堆。排序过程是：

- 用数列构建出一个大顶堆，取出堆顶的数字；

- 调整剩余的数字，构建出新的大顶堆，再次取出堆顶的数字；
- 循环往复，完成整个排序。

#### 快速排序

快速排序算法是面试中考察的重点，也是应用最广泛的排序算法。排序过程是：

- 从数组中取出一个数，称之为基数（pivot）；

- 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域；
- 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。

快速排序中最重要的是分区算法，最常用的分区算法是双指针分区算法，优点是一次交换可以完成两个数的分区。

#### 归并排序

- 归并排序分为两步：二分拆数组、不断合并两个有序列表。
- 归并的优化主要在于减少临时空间的开辟。
- 不存在空间复杂度为 $O(1)$ 的归并排序。

#### 相同点

- 平均时间复杂度都在 $O(n) 到 O(n^2)$ 之间。

#### 不同点

- 希尔排序、堆排序、快速排序是不稳定的，归并排序是稳定的。
- 希尔排序的平均复杂度界于 $O(n)到 O(n^2)$之间，普遍认为它最好的时间复杂度为 $O(n^{1.3})$，希尔排序的空间复杂度为 $O(1)$；堆排序的时间复杂度为 $O(n\log n)$，空间复杂度为 $O(1)$，快速排序的平均时间复杂度为 $O(n\log n)$，平均空间复杂度为 $O(log n)$；归并排序的时间复杂度是 $O(n\log n)$，空间复杂度是 $O(n)$。

# 时间复杂度 $O(n)$ 级排序算法

## 计数排序

计数排序就是一种时间复杂度为 O(n) 的排序算法，该算法于 1954年由 Harold H. Seward 提出。在对一定范围内的整数排序时，它的复杂度为 $Ο(n+k)$（其中 k 是整数的范围大小）

### 基本思想

当输入的元素是${\displaystyle n}$个${\displaystyle  0 }$到${\displaystyle k}$ 之间的整数时，它的运行时间是${\displaystyle \Theta (n+k)}$，**计数排序不是比较排序**，因此不被 ${\displaystyle \Omega (n\log n)}$的下界限制

由于用来计数的数组${\displaystyle C}$的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序$0到100$之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在[基数排序](https://zh.wikipedia.org/wiki/基数排序)算法中，能够更有效的排序数据范围很大的数组

通俗地理解，例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去1。

### 算法描述

算法的步骤如下：

1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为${\displaystyle i}$的元素出现的次数，存入数组${\displaystyle C}$的第${\displaystyle i}$项
3. 对所有的计数累加（从${\displaystyle C}$中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素${\displaystyle i}$放在新数组的第${\displaystyle C[i]}$项，每放一个元素就将${\displaystyle C[i]}$减去1

### 算法实现

**完整的未经优化的计数排序**

```java
/**
 * 计数排序-正序遍历
 *
 * @param nums
 */
public void countingSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    int min = nums[0], max = nums[0];
    // 找到待排序数组中的最大、最小值
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] < min) {
            min = nums[i];
        } else if (nums[i] > max) {
            max = nums[i];
        }
    }
    int length = max - min + 1;// 计数数组的计数范围
    int[] counting = new int[length];// 计数数组
    // 统计每个数字出现的次数到计数数组对应下标的位置
    for (int i = 0; i < nums.length; i++) {
        counting[nums[i] - min]++;
    }
    // 记录每个数字比自己小的数字的总数
    int preCount = 0;
    for (int i = 0; i < length; i++) {
        int temp = counting[i];
        counting[i] = preCount;
        preCount += temp;
    }
    int[] result = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        int idx = counting[nums[i] - min];// 数字nums[i] 前面有 idx个数字，所有数字nums[i]排序后的位置是idx
        result[idx] = nums[i];
        counting[nums[i] - min]++;
    }
    // 将结果赋回给数组nums
    for (int i = 0; i < nums.length; i++) {
        nums[i] = result[i];
    }
}
```

**减少了临时变量的计数排序**

```java
/**
 * 计数排序-正序遍历
 *
 * @param nums
 */
public void countingSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    int min = nums[0], max = nums[0];
    // 找到待排序数组中的最大、最小值
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] < min) {
            min = nums[i];
        } else if (nums[i] > max) {
            max = nums[i];
        }
    }
    int length = max - min + 1;// 计数数组的计数范围
    int[] counting = new int[length];// 计数数组
    // 统计每个数字出现的次数到计数数组对应下标的位置
    for (int i = 0; i < nums.length; i++) {
        counting[nums[i] - min]++;
    }
    // 记录每个数字比自己小的数字的总数
    int preCount = 0;
    for (int i = 0; i < length; i++) {
        preCount += counting[i];
        counting[i] = preCount - counting[i];
    }
    int[] result = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        // 数字nums[i] 前面有 idx个数字，所有数字nums[i]排序后的位置是idx
        result[counting[nums[i] - min]] = nums[i];
        counting[nums[i] - min]++;
    }
    // 将结果赋回给数组nums
    for (int i = 0; i < nums.length; i++) {
        nums[i] = result[i];
    }
}
```

**优化后的计数排序-倒序遍历**

```java
/**
 * 计数排序-倒序遍历
 *
 * @param nums
 */
public void countingSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    // 统计最大、最小值
    int max = nums[0], min = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    // 确定计数数组的计数范围
    int range = max - min + 1;
    int[] counting = new int[range];
    // 统计每个数字出现的次数到对应的计数数组下标
    for (int i = 0; i < nums.length; i++) {
        counting[nums[i] - min]++;
    }
    // 计算每个数字在最终结果数组中的最后一个下标位置
    counting[0]--;
    for (int i = 1; i < range; i++) {
        counting[i] += counting[i - 1];
    }
    // 倒序遍历，将每个数字排序到对应位置，以保证排序的稳定性
    int[] result = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        result[counting[nums[i] - min]--] = nums[i];
    }
    // 将结果赋给原数组
    for (int i = 0; i < nums.length; i++) {
        nums[i] = result[i];
    }
}
```

两种算法的核心思想是一致的，并且都是稳定的。第一种写法理解起来简单一些，第二种写法在性能上更好一些。

在计算下标位置时，不仅计算量更少，还省去了 `preCounts` 这个变量。在《算法导论》一书中，便是采用的此种写法。

实际上，计数排序-倒序遍历算法最后不通过倒序遍历也能得到正确的排序结果，但这里**只有通过倒序遍历的方式，才能保证计数排序的稳定性。**



### 时间复杂度 & 空间复杂度

每次遍历都是进行 n 次或者 k 次，所以计数排序的时间复杂度为 O(n + k)，k 表示数据的范围大小

用到的空间主要是长度为 k 的计数数组和长度为 n 的结果数组，所以空间复杂度也是 O(n + k)

| 平均时间复杂度 | 最好情况   | 最坏情况   | 空间复杂度 |
| -------------- | ---------- | ---------- | ---------- |
| $O(n + k)$     | $O(n + k)$ | $O(n + k)$ | $O(n + k)$ |

**稳定性：**稳定

**计数排序的缺点：**

一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略：

例如：{1,Integer.MAX_VALUE}

对这个数组进行排序，尽管它只包含两个元素，但数据范围是 $[1, 2^{31}]$，我们知道 java 中 int 占 4 个字节，一个长度为 $2^{31}$次方的 int 数组大约会占 8G 的空间，如果使用计数排序，仅仅排序这两个元素，声明计数数组就会占用超大的内存，甚至导致 `OutOfMemory` 异常

**注意：**

计数排序只适用于数据范围不大的场景。例如对考试成绩排序就非常适合计数排序，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。



## 计数排序与$O(nlog^n)$级排序算法的本质区别

这个问题我们可以从决策树的角度和概率的角度来理解

**决策树**
决策树是一棵完全二叉树，它可以反映比较排序算法中对所有元素的比较操作。

以包含三个整数的数组 $[a, b, c]$ 为例，基于比较的排序算法的排序过程可以抽象为这样一棵 **决策树**：
![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111191851897.png)

这棵决策树上的每一个叶结点都对应了一种可能的排列，从根结点到任意一个叶结点之间的最短路径（也称为「简单路径」）的长度，表示的是完成对应排列的比较次数。所以从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。

设决策树的高度为 `h`，叶结点的数量为 `l`，排序元素总数为 `n` 。

![image-20211119190113093](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111191901079.png)

于是我们可以得出以下定理：

>《算法导论》定理 8.1：在最坏情况下，任何比较排序算法都需要做 $O(n \log n)$ 次比较。

由此我们还可以得到以下推论：

> 《算法导论》推论 8.2：堆排序和归并排序都是渐进最优的比较排序算法。

**结论：**

如果基于比较来进行排序，无论怎么优化都无法突破 $O(n \log n)$的下界。计数排序和基于比较的排序算法相比，**根本区别就在于：它不是基于比较的排序算法**，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。

![image-20211119190853978](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111191908889.png)
**计数排序算法比基于比较的排序算法更快的根本原因:**

计数排序时申请了长度为 k 的计数数组，在遍历每一个数字时，这个数字落在计数数组中的可能性共有 k 种，但通过数字本身的大小属性，我们可以「一次」把它放到正确的位置上。相当于一次排除了 $(k - 1)/k$种可能性。



## 基数排序

基数排序的发明可以追溯到1887年[赫尔曼·何乐礼](https://zh.wikipedia.org/wiki/赫爾曼·何樂禮)在[打孔卡片制表机](https://zh.wikipedia.org/w/index.php?title=打孔卡片制表机&action=edit&redlink=1)（Tabulation Machine）上的贡献[[1\]](https://zh.wikipedia.org/wiki/基数排序#cite_note-1)。

### 基本思想

**基数排序**（英语：Radix sort）是一种非比较型[整数](https://zh.wikipedia.org/wiki/整数)[排序算法](https://zh.wikipedia.org/wiki/排序算法)，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

![基数排序LSD动图演示](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111192025128.gif)

### 算法描述

**LSD**

①. 取得数组中的最大数，并取得位数；
②. num为原始数组，从最低位开始取每个位组成radix数组；
③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### 算法实现

**LSD - 对非负整数排序**

```java
// LSD
public void radixSort(int[] nums) {
    // 找到最大数字
    int max = 0;
    for (int num : nums) {
        if (num > max) {
            max = num;
        }
    }
    // 获取最大数字的位数（即数组中数字的最长位数）
    int maxDigitlength = 0;
    while (max != 0) {
        max /= 10;
        maxDigitlength++;
    }
    int[] counting = new int[10];// 基数取值范围0~9
    int[] result = new int[nums.length];
    int div = 1;
    for (int i = 0; i < maxDigitlength; i++) {
        // 统计在当前位数下，不同基数的元素个数
        for (int num : nums) {
            int radix = num / div % 10;
            counting[radix]++;
        }
        // 计算不同基数最后一个元素下标
        for (int j = 1; j < 10; j++) {
            counting[j] += counting[j - 1];
        }
        // 倒序遍历，将每个数字排序到对应的位置，以保证排序的稳定性
        for (int j = nums.length - 1; j >= 0; j--) {
            int radix = nums[j] / div % 10;
            result[--counting[radix]] = nums[j];
        }
        // 结果赋给原数组
        for (int j = 0; j < nums.length; j++) {
            nums[j] = result[j];
        }
        // 将计数数组重置为0
        Arrays.fill(counting, 0);
        div *= 10;
    }
}
```

**LSD - 对包含负数的数组进行基数排序**

思路：

在对基数进行计数排序时，申请长度为 19 的计数数组，用来存储 $[-9, 9]$ 这个区间内的所有整数。在把每一位基数计算出来后，加上 9，就能对应上 counting 数组的下标了。也就是说，counting 数组的下标 $[0, 18]$ 对应基数 $[-9, 9]$



代码中主要做了两处修改：

- 当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中绝对值最大的数，也就是数组中最长的数
- 在获取基数的步骤，将计算出的基数加上 9，使其与 counting 数组下标一一对应

```java
// LSD - 对包含负数的数组进行基数排序
public void radixSort(int[] nums) {
    // 找到绝对值最大数字
    int max = 0;
    for (int num : nums) {
        if (Math.abs(num) > max) {
            max = Math.abs(num);
        }
    }
    // 获取最大数字的位数（即数组中数字的最长位数）
    int maxDigitlength = 0;
    while (max != 0) {
        max /= 10;
        maxDigitlength++;
    }
    int[] counting = new int[19];// 基数取值范围-9~9
    int[] result = new int[nums.length];
    int div = 1;
    for (int i = 0; i < maxDigitlength; i++) {
        // 统计在当前位数下，不同基数的元素个数
        for (int num : nums) {
            int radix = num / div % 10 + 9;
            counting[radix]++;
        }
        // 计算不同基数最后一个元素下标
        for (int j = 1; j < 19; j++) {
            counting[j] += counting[j - 1];
        }
        // 倒序遍历，将每个数字排序到对应的位置，以保证排序的稳定性
        for (int j = nums.length - 1; j >= 0; j--) {
            int radix = nums[j] / div % 10 + 9;
            result[--counting[radix]] = nums[j];
        }
        // 结果赋给原数组
        for (int j = 0; j < nums.length; j++) {
            nums[j] = result[j];
        }
        // 将计数数组重置为0
        Arrays.fill(counting, 0);
        div *= 10;
    }
}
```

### 时间复杂度 & 空间复杂度

无论 LSD 还是 MSD，基数排序时都需要经历 maxDigitLength 轮遍历，每轮遍历的时间复杂度为 $O(n + k)$ ，其中 k 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 $k = 10$，如果是对包含负数的数组排序，则 $k = 19$。

所以基数排序的时间复杂度为 $O(d(n + k))$       (d 表示最长数字的位数，k 表示每个基数可能的取值范围大小)

使用的空间和计数排序是一样的，空间复杂度为 $O(n + k)$       （k 表示每个基数可能的取值范围大小）

| 平均时间复杂度 | 最好情况      | 最坏情况      | 空间复杂度 |
| -------------- | ------------- | ------------- | ---------- |
| $O(d(n + k))$  | $O(d(n + k))$ | $O(d(n + k))$ | $O(n + k)$ |

**稳定性：**

基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法

基数排序更适合用于对时间, 字符串等这些**整体权值未知的数据**进行排序

## 桶排序

**桶排序（Bucket sort）**或所谓的**箱排序**，工作的原理是将[数组](https://zh.wikipedia.org/wiki/陣列)分到有限数量的桶里。每个桶再个别排序（有可能再使用别的[排序算法](https://zh.wikipedia.org/wiki/排序算法)或是以递归方式继续使用桶排序进行排序）。桶排序是[鸽巢排序](https://zh.wikipedia.org/wiki/鴿巢排序)的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间${\displaystyle \Theta (n)}$。但桶排序并不是[比较排序](https://zh.wikipedia.org/wiki/比较排序)，他不受到${\displaystyle O(n\log n)}$下限的影响。

### 基本思想 

桶排序的思想是：

1. 将区间划分为 n 个相同大小的子区间，每个子区间称为一个桶

2. 遍历数组，将每个数字装入桶中
3. 对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等
4. 最后按照顺序将所有桶内的数字合并起来

桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。

在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。

### 算法描述

使用桶排序算法时，我们需要考虑两个因素：

- 设置多少个桶比较合适
- 桶采用哪种数据结构

算法描述：

1. 找到最小值和最大值，确定取值范围 range
2. 根据实际情况设定桶数量和桶间距
3. 装桶
4. 对每个桶内数字进行单独排序

### 算法实现

```java
/**
 * 桶排序
 *
 * @param nums
 */
public void bucketSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    // 找到最大最小值
    int min = nums[0], max = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    // 确定取值范围
    int range = max - min;
    // 根据实际情况设定桶数量
    int bucketAmount = 100;
    // 确定桶间距
    double gap = range * 1.0 / (bucketAmount - 1);
    // 桶
    Map<Integer, List<Integer>> buckets = new HashMap<>();
    // 装桶
    for (int num : nums) {
        // 确定所在桶的下标
        int idx = (int) ((num - min) / gap);
        if (!buckets.containsKey(idx)) {
            buckets.put(idx, new LinkedList<>());
        }
        buckets.get(idx).add(num);
    }
    // 最终结果数组元素下标
    int index = 0;
    // 对桶内元素排序
    for (int i = 0; i < bucketAmount; i++) {
        List<Integer> bucket = buckets.get(i);
        if (bucket != null) {
            // 将链表转换为数组
            int[] array = bucket.stream().mapToInt(Integer::intValue).toArray();
            insertionSort(array);
            for (int element : array) {
                nums[index++] = element;
            }
        }
    }
}

// 插入排序
private void insertionSort(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int num = array[i];
        for (int j = i; j >= 0; j--) {
            if (j > 0 && array[j - 1] > num) {
                array[j] = array[j - 1];
            } else {
                array[j] = num;
                break;
            }
        }
    }
}
```

总结一下桶排序算法中，采用各个数据结构作为桶的特点：

- 以数组作为桶，初始化每个桶的长度为 `n`：时间上做到了最好，但空间占用很高。
- 以数组作为桶，初始化每个桶的长度为 0：空间上做到了最好，但装桶时对数组扩容比较耗时。
- 以 `LinkedList` 作为桶：空间上做到了最好，并且装桶时无需扩容，但对 `LinkedList` 排序比较耗时。
- 装桶时采用 `LinkedList`，排序时采用数组：时间和空间上都是一种折中的方案，但 `LinkedList` 转换`int[]` 的过程需要遍历一次数组，增加了 O(n)的时间，转换后会占用 O(n)的空间。

### 时间复杂度 & 空间复杂度

第一步：找到最大值和最小值的过程需要一轮遍历，时间复杂度 O(n)，空间复杂度 O(1)

第二步：装桶的过程需要遍历一轮数组，时间复杂度 O(n)，空间复杂度与桶的数量以及数据结构有关，设桶的数量为 k，如果使用 k 个长度为 n 的数组作为桶，则空间复杂度为 O(kn)，如果采用 ArrayList 或 LinkedList 来装桶，或者采用初始长度为 0 ，装桶时不断扩容的数组，则空间复杂度为 O(n)

第三步：桶内排序的过程与具体的排序算法有关，由于桶排序假设数据服从均匀分布，所以每个桶内的数字数量为*n*/*k*，如果采用 $O(n^2)$ 级排序算法，则每个桶内排序的时间复杂度为 $O((n/k)^2)$，所有桶完成排序的时间复杂度为$O(k(n/k)2)$，即 $O(n^2 / k)$

如果采用 $O(n\log n)$级排序算法，每个桶内排序的时间复杂度 $O((n/k) \log (n/k))$，所有桶完成排序的时间复杂度为 $O(k(n/k) \log (n/k))$，即 $O(n \log (n/k))$

在桶的数量合适的情况下，时间复杂度 $O(n^2 / k)$和 $O(n \log (n/k))$ 都约等于 $O(n)$

桶内排序的空间复杂度也和具体的排序算法有关，O(1) 或者 O(n)

如果采用 LinkedList 转 int[] 再排序这种方式，由于转换过程需要一轮遍历，所以会增加 O(n) 的时间复杂度和 O(n) 的空间复杂度

桶内排序完成后，需要将所有桶的排序结果收集起来，虽然这一轮是遍历 k 个桶，但把所有桶的结果收集起来的总计算次数是 n。时间复杂度 O(n)，空间复杂度 O(1)

综上可知，桶排序的时间复杂度为 O(n)，需要注意的是，这里 n 的常数项是比较大的，意味着桶排序不一定比 $O(n \log n)$ 级的排序算法快,空间复杂度为 O(n)

| 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 |
| :------------: | :------: | :------: | :--------: |
|     $O(n)$     |  $O(n)$  |  $O(n)$  |   $O(n)$   |

**稳定性：**

稳定的，与具体的排序算法有关

## 桶排序 VS (计数排序 || 基数排序)

桶排序也是一种线性时间复杂度的排序算法。许多文章中说计数排序和基数排序都是桶排序的一种特殊情况，但笔者认为这种说法不太准确。

桶排序 VS 计数排序：虽然计数排序也有划分子区间的操作，但是计数排序在统计了每个数字出现的次数后，主要是通过计算每个数字在排序完成后的数组中的最终位置来完成排序，并没有真正把数字装到桶中。而桶排序则是将所有数字装入了桶里，最后从桶里取出每个数字。桶排序的过程比较像我们在计数排序的文章中介绍的「伪计数排序 2.0 版本」。

桶排序 VS 基数排序：如果把基数排序看作桶排序，那么基数排序的过程就是不断地装桶，基数排序并没有桶内排序这一步（基数排序在装桶的过程就已经完成了排序）。而桶排序主要分为两步：装桶和桶内排序，桶内排序时需要借助其他排序算法。

并且桶排序基于输入数据均匀分布的假设，计数排序和基数排序则没有这样的限制。

所以笔者认为桶排序和这两种算法还是有明显区别的，在《算法导论》一书中也没有说计数排序和基数排序是桶排序的特例

# 总结

<img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111201535220.png" alt="image-20211120153511085" style="zoom: 200%;" />

![202111141528825](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141528825.png)

# Java 源码中的 Arrays.sort() 原理解析

## Arrays.sort() 源码分析（一）——  脉络

> 注：本章使用的 JDK 版本是 11.0.8，建议读者对照着源码阅读本章。

Java 源码中的 Arrays.sort() 函数是由 Java 语言的几位设计者所编写的，它并没有采用某种单一的排序算法，而是通过分析所输入数据的规模、特点，对不同的输入数据采用不同的排序算法。

`Arrays` 类中有很多个 `sort` 函数：

```java
void sort (int[])
void sort (int[], int, int)
void sort (long[])
void sort (long[], int, int)
void sort (short)
void sort (short[], int, int)
void sort (char[])
void sort (char[], int, int)
void sort (byte[])
void sort (byte[], int, int)
void sort (float[])
void sort (float[], int, int)
void sort (double[])
void sort (double[], int, int)
void sort (Object[])
void sort (Object[], int, int)
void sort (T[], Comparator)
void sort (T[], int, int, Comparator)
```

这些 `sort` 函数可以分为两类：

- 对基本类型的排序（`int`、`long`、`short`、`char`、`byte`、`float`、`double`）
- 对非基本类型的排序（`Object`、`T`）

对基本类型的排序是通过调用对应的 `DualPivotQuicksort.sort()` 函数完成的。

对非基本类型的排序采用的是 `TimSort` 或者归并排序，在 `JDK 1.7` 之前，默认采用归并排序，`JDK 1.7` 及之后，默认采用 `TimSort`，但可以通过设置 `JVM` 参数`-Djava.util.Arrays.useLegacyMergeSort=true` 继续使用归并排序。

简单起见，本章只分析 `Array.sort(int[] a)` 函数，对其他基本类型的排序思路都是类似的，对非基本类型的排序暂不讲解。

### 入口

查看 `Arrays.sort(int[] a)` 函数，代码如下：

```java
public static void sort(long[] a) {
    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}
```

`DualPivotQuicksort` 译为「双轴快排」，之前我们介绍的快速排序算法属于「单轴快排」。顾名思义，双轴快排每轮选取两个轴，将数组分为三个区域，这样就能每轮排好两个基数，通常效率比单轴快排更高。但`DualPivotQuicksort` 类中并不是只使用了双轴快排算法，它会根据输入数据的规模、结构化程度来采用不同的排序算法。

### DualPivotQuicksort

跟进 `DualPivotQuicksort.sort(int[] a, int left, int right, int[] work,int workBase, int workLen)` 函数，整个函数如下：

```java
static void sort(int[] a, int left, int right,
                 int[] work, int workBase, int workLen) {
    // Use Quicksort on small arrays
    if (right - left < QUICKSORT_THRESHOLD) {
        sort(a, left, right, true);
        return;
    }

    /*
     * Index run[i] is the start of i-th run
     * (ascending or descending sequence).
     */
    int[] run = new int[MAX_RUN_COUNT + 1];
    int count = 0; run[0] = left;

    // Check if the array is nearly sorted
    for (int k = left; k < right; run[count] = k) {
        if (a[k] < a[k + 1]) { // ascending
            while (++k <= right && a[k - 1] <= a[k]);
        } else if (a[k] > a[k + 1]) { // descending
            while (++k <= right && a[k - 1] >= a[k]);
            for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
                int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
            }
        } else { // equal
            for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
                if (--m == 0) {
                    sort(a, left, right, true);
                    return;
                }
            }
        }

        /*
         * The array is not highly structured,
         * use Quicksort instead of merge sort.
         */
        if (++count == MAX_RUN_COUNT) {
            sort(a, left, right, true);
            return;
        }
    }

    // Check special cases
    // Implementation note: variable "right" is increased by 1.
    if (run[count] == right++) { // The last run contains one element
        run[++count] = right;
    } else if (count == 1) { // The array is already sorted
        return;
    }

    // Determine alternation base for merge
    byte odd = 0;
    for (int n = 1; (n <<= 1) < count; odd ^= 1);

    // Use or create temporary array b for merging
    int[] b;                 // temp array; alternates with a
    int ao, bo;              // array offsets from 'left'
    int blen = right - left; // space needed for b
    if (work == null || workLen < blen || workBase + blen > work.length) {
        work = new int[blen];
        workBase = 0;
    }
    if (odd == 0) {
        System.arraycopy(a, left, work, workBase, blen);
        b = a;
        bo = 0;
        a = work;
        ao = workBase - left;
    } else {
        b = work;
        ao = 0;
        bo = workBase - left;
    }

    // Merging
    for (int last; count > 1; count = last) {
        for (int k = (last = 0) + 2; k <= count; k += 2) {
            int hi = run[k], mi = run[k - 1];
            for (int i = run[k - 2], p = i, q = mi; i < hi; ++i) {
                if (q >= hi || p < mi && a[p + ao] <= a[q + ao]) {
                    b[i + bo] = a[p++ + ao];
                } else {
                    b[i + bo] = a[q++ + ao];
                }
            }
            run[++last] = hi;
        }
        if ((count & 1) != 0) {
            for (int i = right, lo = run[count - 1]; --i >= lo;
                b[i + bo] = a[i + ao]
            );
            run[++last] = right;
        }
        int[] t = a; a = b; b = t;
        int o = ao; ao = bo; bo = o;
    }
}
```

这段函数就是本章讲解的全部内容，其中涉及的排序算法有：`TimSort`、插入排序、双插入排序、双轴快排、荷兰国旗问题。



#### 第一部分：数据的规模小于 286 时

```java
// 如果要排序的数组长度小于该常量，则优先使用快速排序而不是归并排序。
private static final int QUICKSORT_THRESHOLD = 286;
```

```java
static void sort(long[] a, int left, int right,
                 long[] work, int workBase, int workLen) {
    // Use Quicksort on small arrays
    if (right - left < QUICKSORT_THRESHOLD) {
        sort(a, left, right, true);
        return;
    }
```

这里判断了数据的规模，`QUICKSORT_THRESHOLD` 是一个常数，它的值是 286。这个值可能是通过大量的测试用例得出的，当数据的规模小于 286 时，通过调用`sort(int[] a, int left, int right, boolean leftmost)` 函数完成排序。在 `sort(int[] a, int left, int right, boolean leftmost)` 函数中就包含了双轴快排的具体实现。

#### 第二部分：数据规模大于或等于 286 时

```java
// 合并排序中的最大运行次数。
private static final int MAX_RUN_COUNT = 67;
```

```java
/*
 * Index run[i] is the start of i-th run
 * (ascending or descending sequence).
 */
int[] run = new int[MAX_RUN_COUNT + 1];
```

这里声明了一个长度为 `MAX_RUN_COUNT + 1` 的 `int` 数组，命名为 `run`，`MAX_RUN_COUNT` 是常数 67。`run` 是 `TimSort` 中的一个概念。当数据量达到 286 时，就会尝试采用类似 `TimSort` 的一个算法来进行排序。

##### **TimSort**

`TimSort` 是 `Tim Peters` 在2002 年提出的一种算法，它是归并算法的一种改进算法。

`TimSort` 优化了归并排序拆分出子数组的过程。`TimSort` 的主要思想是：通过遍历数组，将数组拆分成若干个单调递增的子数组。每一块称为一个 `run`。拆分完成后，再将 `run` 两两合并起来。在遍历数组时，如果遇到单调递减的小块，`TimSort` 会将其翻转使其单调递增。

举几个例子：

- 对于数组 [1, 4, 2, 3]，`TimSort` 会将其拆分为两个 `run`: [1, 4]、[2,3]
- 对于数组 [3, 4, 5, 1]，`TimSort` 会将其拆分为两个 `run`: [3, 4, 5]、[1]
- 对于数组 [3, 2, 1, 4, 5]，`TimSort` 会将其拆分为两个 run: [1, 2, 3]、[4,5]，其中第一个 run 是由 [3, 2, 1]翻转而来。

这样的拆分方式一定比归并排序的拆分方式更优秀吗？

答案是**不一定**。我们很容易找到反例，比如数组 [5, 2, 6, 3, 7, 1]，`TimSort` 会将其拆分成 [2, 5]、[3, 6]、[1,7]，而且每次拆分都会经过一次翻转，这个拆分过程比归并排序的拆分过程要耗时不少。

那么为什么说 `TimSort` 是归并排序的优化呢？优化的点在哪里？

答案是 `TimSort` 在对**部分有序**的数组进行排序时，速度很快。而现实世界中的数据往往总是部分有序的。比如：

- 一个年级的多个班统计成绩，每个班的成绩已经排好序，最后需要将每个班的成绩表综合起来排出全年级排名。
- 商场统计产品销量时，每家商店的产品销量已经排好序，需要将所有商店的产品销量综合起来找出畅销商品总排行。

`TimSort` 非常适合处理这类场景，因为整个数组可以拆分成少量的 `run` 小块，将其合并即可完成排序。我们称这一类只能被拆分成少量 `run` 小块的数组是「高度结构化」的 (`highly structured`)。

在 `sort(int[] a, int left, int right, int[] work, int workBase, int workLen)` 函数中，如果数组是高度结构化的（即数组只能被拆分成少量 `run` 小块），则采用类似 `TimSort` 的算法进行排序，否则调用`sort(int[] a, int left, int right, boolean leftmost)` 函数进行排序。

为什么说是**类似** `TimSort` 的算法呢？

因为在完整的 `TimSort` 算法中，为了提升合并 `run` 小块时的效率，在拆分时，并不是简单的将数组划分为单调递增的小块，而是设定了一些拆分规则，使得每一个 `run` 小块的长度都比较接近，不至于相差太大导致合并时需要拷贝大量的「尾巴」。但这里的 `TimSort` 只是将数组划分为单调递增的小块就开始合并了，相当于 `TimSort` 的简化版。

在拆分 `run` 小块的过程中，有两个条件会停止调用 `TimSort`，改为调用 `sort(int[] a, int left, int right, boolean leftmost)` 函数进行排序，我们看一下这两个跳出 `TimSort` 的地方：

```java
// 归并排序的最大运行长度。
private static final int MAX_RUN_LENGTH = 33;
```

```java
/*
 * Index run[i] is the start of i-th run
 * (ascending or descending sequence).
 */
int[] run = new int[MAX_RUN_COUNT + 1];
int count = 0; run[0] = left;

// Check if the array is nearly sorted
for (int k = left; k < right; run[count] = k) {
    if (a[k] < a[k + 1]) { // ascending
        while (++k <= right && a[k - 1] <= a[k]);
    } else if (a[k] > a[k + 1]) { // descending
        while (++k <= right && a[k - 1] >= a[k]);
        for (int lo = run[count] - 1, hi = k; ++lo < --hi; ) {
            int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
        }
    } else { // equal
        for (int m = MAX_RUN_LENGTH; ++k <= right && a[k - 1] == a[k]; ) {
            if (--m == 0) {
                sort(a, left, right, true);
                return;
            }
        }
    }

    /*
     * The array is not highly structured,
     * use Quicksort instead of merge sort.
     */
    if (++count == MAX_RUN_COUNT) {
        sort(a, left, right, true);
        return;
    }
}
```

这段代码的逻辑是：以 `k` 为索引遍历整个数组，比较相邻数字的大小关系：

- 如果数字在递增，记录下此 `run` 小块
- 如果数字在递减，记录下此 `run` 小块，并翻转这部分子数组
- 如果数字相等，记录下此 `run` 小块，并判断连续相等的数字是否达到了 `MAX_RUN_LENGTH` 个，如果达到了`MAX_RUN_LENGTH`，则不再使用 `TimSort`，改为调用 `sort(int[] a, int left, int right, boolean leftmost)` 函数进行排序。

`MAX_RUN_LENGTH` 是常数 33，为什么连续相等的数字达到了 33 个就要改为调用 `sort(int[] a, int left, int right, boolean leftmost)` 函数呢？

这是因为 `sort(int[] a, int left, int right, boolean leftmost)` 函数中，对于数组中存在较多相等元素的场景做了单独的优化。所以如果连续相等的数字过多，使用 `sort(int[] a, int left, int right, boolean leftmost)` 函数排序的速度会比 `TimSort` 快一些。

第二个跳出位置与 `count` 数量有关。每记录一个 `run` 小块，`count` 的数量就加 1，当 `count` 数量达到了 `MAX_RUN_COUNT` 后，则不再使用 `TimSort`，改为调用 `sort(int[] a, int left, int right, boolean leftmost)` 函数进行排序。

上文说到，`TimSort` 仅适用于「高度结构化」的数组，`MAX_RUN_COUNT` 的值是 67，如果 `run` 小块数量达到这个值，我们就认为该数组不是「高度结构化」的，不适合采用 `TimSort` 排序。



到这里，我们就完成了第一步的阅读，总结一下：当数组长度达到 286，并且不存在较多连续相等元素，并且「高度结构化」时，采用类似 `TimSort` 的算法进行排序，这是一种归并排序的优化算法，在数组「高度结构化」时，排序效率优于归并排序。否则调用`sort(int[] a, int left, int right, boolean leftmost)` 函数进行排序。



#### 插入排序 & 双插入排序

接下来看一下 `sort(int[] a, int left, int right, boolean leftmost)` 函数的部分实现：

```java
// 如果要排序的数组长度小于该常量，则优先使用插入排序而不是快速排序
private static final int INSERTION_SORT_THRESHOLD = 47;
```

```java
private static void sort(int[] a, int left, int right, boolean leftmost) {
    int length = right - left + 1;

    // Use insertion sort on tiny arrays
    if (length < INSERTION_SORT_THRESHOLD) {
        if (leftmost) {
            /*
             * Traditional (without sentinel) insertion sort,
             * optimized for server VM, is used in case of
             * the leftmost part.
             */
            for (int i = left, j = i; i < right; j = ++i) {
                int ai = a[i + 1];
                while (ai < a[j]) {
                    a[j + 1] = a[j];
                    if (j-- == left) {
                        break;
                    }
                }
                a[j + 1] = ai;
            }
        } else {
            /*
             * Skip the longest ascending sequence.
             */
            do {
                if (left >= right) {
                    return;
                }
            } while (a[++left] >= a[left - 1]);

            /*
             * Every element from adjoining part plays the role
             * of sentinel, therefore this allows us to avoid the
             * left range check on each iteration. Moreover, we use
             * the more optimized algorithm, so called pair insertion
             * sort, which is faster (in the context of Quicksort)
             * than traditional implementation of insertion sort.
             */
            for (int k = left; ++left <= right; k = ++left) {
                int a1 = a[k], a2 = a[left];

                if (a1 < a2) {
                    a2 = a1; a1 = a[left];
                }
                while (a1 < a[--k]) {
                    a[k + 2] = a[k];
                }
                a[++k + 1] = a1;

                while (a2 < a[--k]) {
                    a[k + 1] = a[k];
                }
                a[k + 1] = a2;
            }
            int last = a[right];

            while (last < a[--right]) {
                a[right + 1] = a[right];
            }
            a[right + 1] = last;
        }
        return;
    }

    // ……
}
```

首先仍然是判断数组长度，如果小于 `INSERTION_SORT_THRESHOLD`（它的值是 47），则采用插入排序算法或双插入排序算法进行排序。这是因为插入排序在数据量小的时候，排序性能比较好。

双插入排序算法每轮从待处理的数字中取两个数字插入前方已有序的数组中，它比普通的插入排序算法更快一些。

如果数据量达到了47，则采用双轴快排算法进行排序。

到此，我们就将 Arrays.sort() 函数梳理得差不多了。

### 总结

- 在对基本数据类型的数组排序时，`Arrays.sort()` 函数通过调用调用 `DualPivotQuicksort.sort()` 完成排序；
- 当数组长度达到 286 ，并且不存在较多连续相等元素，并且「高度结构化」时，采用类似 `TimSort` 的算法进行排序；
- 当数组长度小于 `INSERTION_SORT_THRESHOLD`（即 47）时，采用插入排序或双插入排序；
- 否则采用双轴快排进行排序。



