# 有序表

# 总结归纳

#### 搜索二叉树

经典的搜索二叉树key是不重复的，因为即便有重复的key，也可以在一个节点上用list来组织

**性质：**每个节点中的值必须大于其左侧子树中的任何值，但小于其右侧子树中的任何值。也就是中序遍历是**单调递增序列**

#### AVL树

AVL树利用高度信息来维持平衡性

AVL树的平衡定义：
任意一个节点的左右子树的高度差不能超过1

因此，AVL树的不平衡状态，包括四种情况：
LL型
RR型
LR型
RL型

#### SB树

Size Balanced Tree（SBT）是一种通过大小（Size）域来保持平衡的[二叉搜索树](https://baike.baidu.com/item/二叉搜索树)，它也因此得名

AVL树的平衡定义：每棵叔叔树的大小，不小于任何侄子树的大小，也就是说，其左右子树的最大差距也就是一倍多一个

（例如：一个叔叔节点大小为10，那么，他的两个侄子最大不能超过叔叔，也就是最大为10，加上他们父节点，最大为21）

#### 红黑树

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。（黑色平衡）

最短路径就是全黑节点，红黑交替情况下的长度，顶多也就是全黑路径长度多一倍

#### 跳表

跳表全称叫做跳跃表，简称跳表。是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。可以被看做二叉树的一个变种，它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，目前在Redis和LeveIDB中都有用到。

### 搜索二叉树与平衡搜索二叉树的比较

搜索二叉树很可能因为增删节点变得不平衡，性能无法保证，执行的数据增删的顺序很可能影响搜索二叉树的效率

红黑树、AVL树、SB树 关于 搜索二叉树的改进内容：高度的调整

### 红黑树、AVL树、SB树 、跳表的比较

在时间复杂度层面，这四种结构是一样的
其中，红黑树、AVL树、SB树属于 同一个系列，那就是平衡搜索[二叉树](https://so.csdn.net/so/search?from=pc_blog_highlight&q=二叉树)系列

红黑树、AVL树、SB树的区别：平衡性标准不同，AVL树、SB树、红黑树，本质都是二叉搜索树，只不过，在搜索树的前提下，提供了左旋和右旋调整平衡的操作

### 红黑树与AVL树的比较

红黑树相比于AVL树，牺牲了部分平衡性，以换取删除/插入操作时少量的旋转次数，整体来说，理论上性能优于AVL树

#### 查询

红黑树的平衡要求不如AVL树严格，AVL树在查询频繁的系统里比红黑树更高效，原因是AVL树的平均高度比红黑树更小

#### 插入

AVL树：

从新增的节点开始，往上检查，直到根节点，判断四种不平衡类型，进行平衡性调整所以加一个节点的调整代价：$O(log^n)$

红黑树：

如果父节点是黑色，则不需要调整，否则需要调整，调整代价：$O(log^n)$

#### 删除

AVL树：

从**波及到的节点**开始逐步往上检查，直到根节点，逐步进行平衡性调整，调整代价：$O(logn)$

红黑树：

红黑树的平衡是黑色平衡，只有删除的节点是黑色，才需要调整平衡

在最坏情况下红黑树和AVL树删除插入节点的时间复杂度均为$O(logn)$

# 学习笔记

### 有序表

在Java中 有序表（TreeMap）是用红黑树实现的，它的key是按照自然顺序进行排序组织的

#### 有序表和哈希表的区别

哈希表增删改查都是 $O(1)$

有序表增删改查都是 $O(log^n)$

#### 有序表和红黑树的关系

##### 什么是有序表

1. 有序表是能够实现key有序组织，并且能够根据有序组织的key工作的一系列接口规范
2. 而且这些接口的性能都是$O(log^n)$
3. 能够实现 1、2 上述两点的结构都叫有序表的实现

##### 如何实现有序表

红黑树、AVL树、SB树、跳表等等，它们实现有序表性能都是 $O(log^n)$级别,区别只有常数级别的区别而已~

SB树、跳表实现有序表最简单，红黑树最难（新出现的语言包括经典语言中用有序表的地方逐渐的不用红黑树了，因为只有常数级别的区别）

> ZS大佬语录：红黑树到底相比于其他树有什么好处？我觉得没好处，常数级别的算法是可以被精巧的设计、精巧的coding所优化的

红黑树、AVL树、SB树 是有序表的一大套的设计系列，都属于搜索二叉树系列，跳表和它们的设计模式、设计思想 是完全不一样的，但它们都能做到一样的指标

红黑树、AVL树、SB树 与 搜索二叉树的增删查方法是一样的，区别在于增删后的平衡性调整

#### 搜索二叉树

经典的搜索二叉树key是不重复的，因为即便有重复的key，也可以在一个节点上用list来组织

**性质：**每个节点中的值必须大于其左侧子树中的任何值，但小于其右侧子树中的任何值。也就是中序遍历是**单调递增序列**



##### 搜索二叉树的查、增、删

在二叉搜索树中**搜索**特定的值，根据BST的特性，对于每个节点：

1. 如果目标值等于节点的值，则返回节点
2. 如果目标值小于节点的值，则继续在左子树中搜索
3. 如果目标值大于节点的值，则继续在右子树中搜索

二叉搜索树**插入**节点：

1. 根据节点值与目标节点值的关系，搜索左子树或右子树
2. 重复步骤 1 直到到达null节点
3. 将新节点插入此null位置，然后返回

二叉搜索树**删除**节点：

1. （无左无右）如果目标节点没有子节点，我们可以直接移除该目标节点

2. （有左无右）如果目标节只有一个左子节点，让指向目标节点的指针指向其左子节点，然后释放目标节点

3. （无左有右）如果目标节只有一个右子节点，让指向目标节点的指针指向其右子节点，然后释放目标节点

4. （有左有右）如果目标节点有两个子节点：

   方案一：找到其左子树的最右节点，把这个把指向左子树最右节点的指针 指向其左子树，然后用这个左子树最右节点去取代目标节点

   方案二：找到其右子树的最左节点，把这个把指向右子树最左节点的指针 指向其右子树，然后用这个右子树最左节点去取代目标节点

##### 搜索二叉树代码实现

**[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)**

```java
// 搜索
public TreeNode searchBST(TreeNode root, int val) {
    while (root != null && root.val != val) {
        if (root.val > val) {
            root = root.left;
        } else if (root.val < val) {
            root = root.right;
        }
    }
    return root;
}
```

**[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)**

```java
// 插入
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    TreeNode pre = root, cur = root;
    while (cur != null) {
        pre = cur;
        if (cur.val > val) {
            cur = cur.left;
        } else if (cur.val < val) {
            cur = cur.right;
        }
    }
    if (pre.val > val) {
        pre.left = new TreeNode(val);
    } else {
        pre.right = new TreeNode(val);
    }
    return root;
}
```

**[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)**

###### 非递归实现

```java
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) {
        return null;
    }
    return delete(root, key);
}

/**
 * 删除，三种情况
 * 1. 目标节点没有左右子树，直接删除
 * 2. 目标节点只有左子树或只有右子树，原来指向目标节点的指针指向其左子树或右子树
 * 3. 目标节点有左右子树:
 * 方案一：找到左子树的最右节点，让原来指向这个左子树最右节点的指针指向其左子树，然后用这个左子树最右节点替换掉目标节点
 * 方案二：找到右子树的最左节点，让原来指向这个右子树最左节点的指向指向其右子树，然后用这个右子树最左节点替换掉目标节点
 *
 * @param root 根节点
 * @param key  待删除节点值
 * @return 新的根节点
 */
private TreeNode delete(TreeNode root, int key) {
    // 找到要删除的节点
    TreeNode pre = null, deletedNode = root;
    while (deletedNode != null && deletedNode.val != key) {
        pre = deletedNode;
        if (deletedNode.val > key) {
            deletedNode = deletedNode.left;
        } else {
            deletedNode = deletedNode.right;
        }
    }
    // 找不到
    if (deletedNode == null) {
        return root;
    }
    TreeNode newNode = null;
    // 第一、第二种情况
    if (deletedNode.left == null || deletedNode.right == null) {
        if (deletedNode.left == null) {
            newNode = transplant(pre, deletedNode, deletedNode.right);
        }
        if (deletedNode.right == null) {
            newNode = transplant(pre, deletedNode, deletedNode.left);
        }
        if (pre == null) {
            return newNode;
        }
        return root;
    }
    // 第三种情况
    TreeNode minNodePre = deletedNode, minNode = deletedNode.right;
    while (minNode.left != null) {
        minNodePre = minNode;
        minNode = minNode.left;
    }
    if (minNode == deletedNode.right) {
        newNode = transplant(pre, deletedNode, minNode);
    } else {
        transplant(minNodePre, minNode, minNode.right);
        newNode = transplant(pre, deletedNode, minNode);
        newNode.right = deletedNode.right;
    }
    newNode.left = deletedNode.left;
    return pre == null ? newNode : root;
}

/**
 * 用 newNode 节点取代待删除节点
 *
 * @param parentNode  待删除节点的父节点
 * @param deletedNode 待删除节点
 * @param newNode     newNode
 * @return newNode
 */
private TreeNode transplant(TreeNode parentNode, TreeNode deletedNode, TreeNode newNode) {
    if (parentNode == null) {
        return newNode;
    }
    if (parentNode.left == deletedNode) {
        parentNode.left = newNode;
    } else if (parentNode.right == deletedNode) {
        parentNode.right = newNode;
    }
    return newNode;
}
```

###### 优雅的非递归实现

```java
/**
 * 删除，三种情况
 * 1. 目标节点没有左右子树，直接删除
 * 2. 目标节点只有左子树或只有右子树，原来指向目标节点的指针指向其左子树或右子树
 * 3. 目标节点有左右子树:
 * 方案一：找到左子树的最右节点，让原来指向这个左子树最右节点的指针指向其左子树，然后用这个左子树最右节点替换掉目标节点
 * 方案二：找到右子树的最左节点，让原来指向这个右子树最左节点的指向指向其右子树，然后用这个右子树最左节点替换掉目标节点
 */
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) {
        return null;
    }
    TreeNode pre = null, cur = root;
    while (cur != null && cur.val != key) {
        pre = cur;
        if (cur.val > key) {
            cur = cur.left;
        } else {
            cur = cur.right;
        }
    }
    if (cur != null) {
        if (pre != null) {
            if (pre.left == cur) {
                pre.left = delete(cur);
            } else {
                pre.right = delete(cur);
            }
        } else {
            root = delete(cur);
        }
    }
    return root;
}

private TreeNode delete(TreeNode cur) {
    if (cur.left == null && cur.right == null) {
        cur = null;
    } else if (cur.left == null) {
        cur = cur.right;
    } else if (cur.right == null) {
        cur = cur.left;
    } else {
        TreeNode newNode = cur.right, newNodePre = null;
        while (newNode.left != null) {
            newNodePre = newNode;
            newNode = newNode.left;
        }
        if (cur.right != newNode) {
            newNodePre.left = newNode.right;
            newNode.right = cur.right;
        }
        newNode.left = cur.left;
        cur = newNode;
    }
    return cur;
}
```

###### 优雅的递归实现

```java
/**
 * 删除，三种情况
 * 1. 目标节点没有左右子树，直接删除
 * 2. 目标节点只有左子树或只有右子树，原来指向目标节点的指针指向其左子树或右子树
 * 3. 目标节点有左右子树:
 * 方案一：找到左子树的最右节点，让原来指向这个左子树最右节点的指针指向其左子树，然后用这个左子树最右节点替换掉目标节点
 * 方案二：找到右子树的最左节点，让原来指向这个右子树最左节点的指向指向其右子树，然后用这个右子树最左节点替换掉目标节点
 *
 * @param root 根节点
 * @param key  待删除节点值
 * @return 新的根节点
 */
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) {
        return root;
    }
    if (root.val == key) {
        return newTree(root);
    }
    if (root.val > key) {
        TreeNode newTree = deleteNode(root.left, key);
        root.left = newTree;
    }
    if (root.val < key) {
        TreeNode newTree = deleteNode(root.right, key);
        root.right = newTree;
    }
    return root;
}

private TreeNode newTree(TreeNode root) {
    if (root.left == null && root.right == null) {
        return null;
    }
    if (root.left == null) {
        return root.right;
    }
    if (root.right == null) {
        return root.left;
    }
    TreeNode pre = root, cur = root.right;
    while (cur.left != null) {
        pre = cur;
        cur = cur.left;
    }
    if (cur != root.right) {
        pre.left = cur.right;
        cur.left = root.left;
        cur.right = root.right;
    } else {
        cur.left = root.left;
    }
    return cur;
}
```

#### 时间复杂度&空间复杂度

| 算法 |      | **平均** | **最差** |
| ---- | ---- | -------- | -------- |
| 空间 |      | $O(n)$   | $O(n)$   |
| 搜索 |      | $O(h)$   | $O(n)$   |
| 插入 |      | $O(h)$   | $O(n)$   |
| 删除 |      | $O(h)$   | $O(n)$   |

#### 二叉搜索树的优点

二叉搜索树的有优点是，即便在最坏的情况下，也允许你在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。

##### 搜索二叉树可以很轻易的改出各种api

例：

- 在给定的搜索二叉树中找到 大于等于 给定值 m 中最小的；

- 在给定的搜索二叉树中找到 小等于 给定值 m 中最大的；

- 在给定的搜索二叉树中找到最小的第100个key：每个节点维持一个size属性，记录所拥有的节点个数；
- 在给定的搜索二叉树中找到第92个数：树的组织不重复，但树节点可以接受多个相同的数，每个节点维持一个size属性

这些api的平均时间复杂度都是 $O(h)$



#### 搜索二叉树存在的问题

搜索二叉树很可能因为增删节点变得不平衡，性能无法保证，执行的数据增删的顺序很可能影响搜索二叉树的效率

![image-20211201083502205](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202112010835669.png)

### 红黑树、AVL树、SB树

红黑树、AVL树、SB树的区别：平衡性不同

红黑树、AVL树、SB树 关于 搜索二叉树的改进内容：高度的调整



#### 左旋和右旋

左旋和右旋作用：调整搜索二叉树的高度差

##### 左旋

节点node发生左旋指 节点node向左边“倒下去”，node节点的右子节点成为新的头节点

![左旋](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202112011522928.png)



##### 右旋



### AVL树

AVL树利用高度信息来维持平衡性。



**AVL树**（Adelson-Velsky and Landis Tree）是[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中最早被发明的[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为**高度平衡树**。查找、插入和删除在平均和最坏情况下的[时间复杂度](https://zh.wikipedia.org/wiki/时间复杂度)都是${\displaystyle O(\log {n})}$。增加和删除元素的操作则可能需要借由一次或多次[树旋转](https://zh.wikipedia.org/wiki/树旋转)，以实现树的重新平衡。



节点的**平衡因子**是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。



**AVL树高度和节点个数的关系**

有 N 个节点的AVL树，它的高度是 logN

**AVL的平衡性衡量标准**：高度



#### AVL树新增节点

##### 如何检查平衡性？

从新增的节点开始，往上检查，直到根节点，判断四种不平衡类型，进行平衡性调整

##### 导致AVL树不平衡的四种类型

- LL型

  - **调整策略：**该点右旋

    ![image-20211201195836340](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112011958320.png)

- RR型

  - **调整策略：**同理，该点左旋

- LR型：左子树的右链过长导致违规

  - **调整策略：**

    1. 目标节点的左节点左旋（让目标节点的左节点的右子节点先上一层）
    2. 目标节点右旋（让目标节点的左节点的右子节点再上一层，来到目标节点原理的位置）

    ![image-20211201200415282](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012004238.png)

- RL型：右子树的左链过长导致违规

  - **调整策略：**右旋+左旋

**调整代价：**

判断属于哪种类型所花费的时间：$O(1)$,因为节点保存了高度信息

调整的时间代价：$O(1)$，因为最多两次旋转

需要调整的节点个数：$O(log^n)$，因为新增节点经历了高度 h

所以加一个节点的调整代价：$O(log^n)$

#### AVL树删除节点

- 如果目标节点没有左右子树，删除目标节点后，从目标节点的父节点开始逐步往上检查，直到根节点，逐步进行平衡性调整

- 有左无右
- 有右无左
  - 右子树无左子树
    - 用目标节点的右子树取代目标节点后，从目标节点的右子树开始逐步往上检查，直到根节点，逐步进行平衡性调整
  - 右子树有左子树
    - 用右子树的最左节点取代目标节点后，**从最左节点当时的父节点的位置**逐步往上检查，直到根节点，逐步进行平衡性调整

**也就是说：**从**波及到的节点**开始逐步往上检查，直到根节点，逐步进行平衡性调整

#### 代码实现

> ZS语录：AVL树就是在包含左旋和右旋的搜索二叉树的基础上，兼顾平衡性的调整

```java
package zs.order_list;

/**
 * 抽象搜索二叉树实现，它基本完全实现了搜索二叉树，
 * 只提供了基本的查、增、删的方法模板，
 * 这样一来，来自标准搜索二叉树的代码可以重用于其他类型的搜索二叉树
 *
 * @author miemiehoho
 * @date 2021/12/1 10:59
 */
public class AbstractBinarySearchTree {

    /**
     * 整个树开始的根节点
     */
    public Node root;

    /**
     * 树的大小
     */
    protected int size;

    /**
     * 因为这是抽象类，
     * 并且各种树在不同的子节点子类上有不同的附加信息，
     * 所以使用这个抽象方法来创建节点
     *
     * @param value
     * @param parent
     * @param left
     * @param right
     * @return
     */
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new Node(value, parent, left, right);
    }

    /**
     * 查找值为element的节点，找不到就返回null
     *
     * @param element
     * @return
     */
    public Node search(int element) {
        Node cur = root;
        while (cur != null && cur.value != null && cur.value != element) {
            if (cur.value > element) {
                cur = cur.left;
            } else {
                cur = cur.right;
            }
        }
        return cur;
    }

    /**
     * 将新元素插入到树中
     *
     * @param element
     * @return
     */
    public Node insert(int element) {
        if (root == null) {
            root = createNode(element, null, null, null);
            size++;
            return root;
        }
        Node pre = root;
        Node cur = root;
        while (cur != null && cur.value != null) {
            pre = cur;
            if (cur.value > element) {
                cur = cur.right;
            } else {
                cur = cur.left;
            }
        }
        Node newNode = createNode(element, pre, null, null);
        if (pre.value > element) {
            pre.left = newNode;
        } else {
            pre.right = newNode;
        }
        size++;
        return newNode;
    }

    /**
     * 如果存在值为element的节点就删除它
     *
     * @param element
     * @return
     */
    public Node delete(int element) {
        Node deleteNode = search(element);
        if (deleteNode != null) {
            return delete(deleteNode);
        }
        return null;
    }

    /**
     * deleteNode节点的删除逻辑
     *
     * @param deleteNode
     * @return 替代了deletedNode的新节点，如果找不到要删除的节点就返回null
     */
    protected Node delete(Node deleteNode) {
        if (deleteNode == null) {
            return null;
        }
        Node nodeToReturn = null;
        if (deleteNode.left == null) {// 左子树为null或左右子树都为null
            nodeToReturn = transplant(deleteNode, deleteNode.right);
        } else if (deleteNode.right == null) {// 右子树为null
            nodeToReturn = transplant(deleteNode, deleteNode.left);
        } else {// 左右子树都不为null
            Node successorNode = getMinNode(deleteNode.right);
            if (successorNode.parent != deleteNode) {
                transplant(successorNode, successorNode.right);
                successorNode.right = deleteNode.right;
                successorNode.right.parent = successorNode;
            }
            transplant(deleteNode, successorNode);
            successorNode.left = deleteNode.left;
            successorNode.left.parent = successorNode;
            nodeToReturn = successorNode;
        }
        size--;
        return nodeToReturn;
    }

    /**
     * 用newNode替换nodeToReplace
     *
     * @param nodeToReplace
     * @param newNode
     * @return newNode
     */
    private Node transplant(Node nodeToReplace, Node newNode) {
        Node parent = nodeToReplace.parent;
        if (parent == null) {// 待删除节点是根节点
            this.root = newNode;
        }
        if (parent.left == nodeToReplace) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }
        if (newNode != null) {
            newNode.parent = parent;
        }
        return newNode;
    }

    /**
     * 获取以node为根的树的最大节点
     *
     * @param node
     * @return
     */
    private Node getMaxNode(Node node) {
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }

    /**
     * 获取以node为根的树的最小节点
     *
     * @param node
     * @return
     */
    protected Node getMinNode(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }

    /**
     * 搜索二叉树节点类
     */
    public static class Node {
        public Integer value;
        public Node parent;
        public Node left;
        public Node right;

        public Node(Integer value, Node parent, Node left, Node right) {
            this.value = value;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }

        public boolean isLeaf() {
            return this.left == null && this.right == null;
        }
    }
}
```

```java
package zs.order_list;

/**
 * 自平衡搜索二叉树抽象类，包含了用于自平衡的左旋和右旋方法
 *
 * @author miemiehoho
 * @date 2021/12/1 14:45
 */
public abstract class AbstractSelfBalancingBinarySearchTree extends AbstractBinarySearchTree {

    /**
     * 左旋
     *
     * @param node 需要旋转的节点
     * @return node节点 旋转后提供的替代节点
     */
    protected Node rotateLeft(Node node) {
        Node parent = node.parent;
        Node newRoot = node.right;

        // 新的头节点的父节点应该指向 node的父节点
        newRoot.parent = parent;
        // 新的头节点的左子树变成原头结点的右子树
        node.right = newRoot.left;
        if (node.right != null) {
            node.right.parent = node;
        }
        // 原头节点变成新头节点的左子树
        newRoot.left = node;
        node.parent = newRoot;

        // 判断 原头节点是否根节点
        if (parent != null) {
            if (parent.left == node) {
                parent.left = newRoot;
            } else {
                parent.right = newRoot;
            }
        } else {
            this.root = newRoot;
        }

        return newRoot;
    }

    /**
     * 右旋
     *
     * @param node
     * @return
     */
    protected Node rotateRight(Node node) {
        Node parent = node.parent;
        Node newNode = node.left;

        newNode.parent = parent;
        // 把newNode 的右子树挂在node的左子树下
        node.left = newNode.right;
        if (node.left != null) {
            node.left.parent = node;
        }

        // 把node挂在newNode的右子树下
        newNode.right = node;
        node.parent = newNode;

        // 判断node是否根节点
        if (parent != null) {
            if (parent.left == node) {
                parent.left = newNode;
            } else {
                parent.right = newNode;
            }
        } else {
            this.root = newNode;
        }

        return newNode;
    }
}
```

```java
package zs.order_list;

/**
 * @author miemiehoho
 * @date 2021/12/1 14:44
 */
public class AVLTree extends AbstractSelfBalancingBinarySearchTree {

    /**
     * AVL树新增节点，进行平衡性调整、更新高度信息
     *
     * @param element
     * @return
     */
    @Override
    public Node insert(int element) {
        Node newNode = super.insert(element);
        rebalance((AVLNode) newNode);
        return newNode;
    }

    /**
     * AVL树删除节点
     *
     * @param element
     * @return
     */
    @Override
    public Node delete(int element) {
        Node deleteNode = super.search(element);
        if (deleteNode == null) {
            return null;
        }
        Node successorNode = super.delete(element);
        if (successorNode != null) {
            AVLNode minNode = successorNode.right != null ? (AVLNode) getMinNode(successorNode.right) : (AVLNode) successorNode;
            recomputeHeight(minNode);
            rebalance(minNode);
        } else {
            recomputeHeight((AVLNode) successorNode);
            rebalance((AVLNode) deleteNode.parent);
        }
        return successorNode;
    }

    @Override
    protected Node createNode(int value, Node parent, Node left, Node right) {
        return new AVLNode(value, parent, left, right);
    }

    /**
     * 从插入的节点开始向上，更新高度并且检查平衡信息，
     * 如果某节点左右子树高度差达到 2 或 -2，则需要重新平衡以该节点为头节点的子树
     * (从目标节点开始往上窜，并检查平衡信息，进行平衡性调整)
     *
     * @param node
     */
    private void rebalance(AVLNode node) {
        while (node != null) {
            Node parent = node.parent;

            int leftHeight = ((AVLNode) node.left).height;
            int rightHeight = ((AVLNode) node.right).height;
            int nodeBalance = rightHeight - leftHeight;
            if (nodeBalance == 2) {// 右树不平衡
                if (node.right.right != null) {
                    avlRotateLeft(node);
                } else {
                    avlRotateLeftRight(node);
                }
            } else if (nodeBalance == -2) {// 左树不平衡
                if (node.left.left != null) {
                    avlRotateRight(node);
                } else {
                    avlRotateRightLeft(node);
                }
            } else {
                updateHeight(node);
            }
            node = (AVLNode) parent;
        }
    }

    /**
     * RR型
     * 左旋并调整高度
     *
     * @param node
     * @return
     */
    private Node avlRotateLeft(Node node) {
        Node temp = super.rotateLeft(node);

        updateHeight((AVLNode) temp.left);
        updateHeight((AVLNode) temp);
        return temp;
    }

    /**
     * LL型
     * 右旋并调整高度
     *
     * @param node
     * @return
     */
    private Node avlRotateRight(Node node) {
        Node temp = super.rotateRight(node);

        updateHeight((AVLNode) temp.right);
        updateHeight((AVLNode) temp);
        return temp;
    }


    /**
     * RL型
     * 目标节点的右节点右旋，使得目标节点的右节点的左子节点上一层；
     * 然后目标节点左旋，使得目标节点的右节点的左子节点再上一层，来到目标节点曾经的位置
     *
     * @param node
     * @return
     */
    private Node avlRotateRightLeft(Node node) {
        avlRotateRight(node.right);
        return avlRotateLeft(node);
    }

    /**
     * LR型
     * 目标节点的左节点左旋，使得目标节点左节点的右子节点上一层，
     * 然后目标节点右旋，使得目标节点的左节点的右子节点再上一层，来到目标节点曾经的位置
     *
     * @param node
     * @return
     */
    private Node avlRotateLeftRight(Node node) {
        avlRotateLeft(node.left);
        return avlRotateRight(node);
    }

    /**
     * 重新计算目标节点和目标节点的所有父节点的高度信息
     *
     * @param node
     */
    private void recomputeHeight(AVLNode node) {
        while (node != null) {
            node.height = maxHeight((AVLNode) node.left, (AVLNode) node.right);
            node = (AVLNode) node.parent;
        }
    }

    private int maxHeight(AVLNode node1, AVLNode node2) {
        if (node1 != null && node2 != null) {
            return node1.height > node2.height ? node1.height : node2.height;
        } else if (node1 == null) {
            return node2 != null ? node2.height : -1;
        } else {
            return node1.height;
        }
    }

    /**
     * 更新高度
     *
     * @param node 需要更新高度的节点
     */
    private static final void updateHeight(AVLNode node) {
        int leftHeight = node.left == null ? -1 : ((AVLNode) node.left).height;
        int rightHeight = node.right == null ? -1 : ((AVLNode) node.right).height;
        node.height = 1 + Math.max(leftHeight, rightHeight);
    }

    /**
     * AVL树节点类，具有高度和平衡调整策略
     * 如果balance 等于 2 或 -2，则该节点需要重新平衡
     * （高度是从这个节点开始的子树的高度，平衡是左右节点高度的差）
     */
    protected static class AVLNode extends Node {
        public int height;

        public AVLNode(Integer value, Node parent, Node left, Node right) {
            super(value, parent, left, right);
        }
    }

}
```

#### 时间复杂度&空间复杂度

| 算法 |      | **平均** | **最差** |
| ---- | ---- | -------- | -------- |
| 空间 |      | O(n)     | O(n)     |
| 搜索 |      | O(log n) | O(log n) |
| 插入 |      | O(log n) | O(log n) |
| 删除 |      | O(log n) | O(log n) |

### SB树

Size balanced tree，一种非常容易二次修改的树。

Size Balanced Tree（SBT）是一种通过大小（Size）域来保持平衡的[二叉搜索树](https://baike.baidu.com/item/二叉搜索树)，它也因此得名。

**注意：**Size 指的是**不同**的key的数量，如果想要统计相同key的数量需要新增 times 字段

#### SB树的平衡性定义

在SB树中，任何一个叔叔节点的size不能小于任何一个侄子节点的size:

![SB树](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012223111.png)



L节点（叔叔节点）拥有的节点个数（size）不能小于它的任何一个侄子节点（c、d）拥有的节点个数（size）



#### 为什么SB树可以通过size调整平衡性？

如果任何一个叔叔节点的size都不小于任何一个侄子节点的size，那么这颗树的左右子树的规模相差不会超过一倍，那么就可以认为左右子树的节点数是差不多的。



#### SB树的四种违规类型

- **LL型违规**

  - 目标节点的左孩子的左孩子的size大于目标节点的右孩子的size

    - 例：R节点的size要小于a节点的size，那么R节点违规

    ![SB树 (1)](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012248588.png)

- **LR型违规**

  - 目标节点的左孩子的右孩子的size大于目标节点的右孩子的size

    - 例：R节点的size要小于b节点的size，那么R节点违规

    ![SB树 (2)](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012250442.png)

- **RR型违规**

  - 目标节点的右孩子的右孩子的size大于目标节点的左孩子的size

- **RL型违规**

  - 目标节点的右孩子的左孩子的size大于目标节点的左孩子的size

#### 为什么不会同时出现几种违规？

检查是否违规是在删除或插入一个节点后，那么在删除或插入节点前SB树是平衡的，增删节点是一个一个进行的

#### SB树的调整过程

##### LL型违规

![SB树 (1)](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012248588.png)

1. 调用平衡性调整函数maintain()，检查 T 树的平衡性
2. 发现了LL型违规，即R节点的size要小于a节点的size
3. 对目标节点 T 右旋
4. 递归调用函数maintain()，处理 T 节点
5. 再递归调用函数maintain()，处理 L 节点

- 总而言之，谁的子树发生变化了就对谁调用函数maintain()检查平衡性

- 递归调用次数：有限几次（论文里证明了，不需要自己分析）

##### RR型违规

同理。

##### LR型违规

![LR](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112012326134.png)

1. 调用平衡性调整函数maintain()，检查 T 树的平衡性
2. 发现了LR型违规，即R节点的size要小于b节点的size
3. 对 L 节点左旋，让 b 节点上来
4. 对 T 节点右旋，让 b 节点再上来
5. 递归调用函数maintain()检查**子树发生了变化的节点的平衡性**，注意顺序，要先检查子节点的平衡性（子节点间顺序无所谓）再检查父节点的平衡性：
   1. 先递归调用函数maintain()检查 L节点，T节点的平衡性
   2. 再递归调用函数maintain()检查 b 节点的平衡性

- 总而言之，谁的子树发生变化了就对谁调用函数maintain()检查平衡性

- 递归调用次数：有限几次（论文里证明了，不需要自己分析）

##### RL型



##### 新增节点的过程

从新增的节点开始，执行函数maintain()进行平衡性调整，执行完后，其父节点再次执行相同过程，一直执行到根节点，完成平衡性的调整

**时间复杂度分析：**每个节点执行maintain()函数都会递归调用，但都是有限几次（因为在新增节点之前这棵树本身就是平衡的SB树），可以认为是**O(1)**,所以新增节点的调整代价就是$O(log^n)$

 

#### SB树与AVL树相比的好处

SB树和AVL树 增删一个节点的调整代价都是$O(log^n)$

AVL树的调整过程是非递归，SB树的调整过程是递归的

- SB树可以在删除一个节点后不立即进行调整，在下一次新增节点时再进行调整，而且调整代价并不会因此而上升,(常规做法，只在add时候进行调整，并不是说不能在delete时候调整,可以但没必要)，还是$O(log^n)$

  - 证明：

    假设 SB树的某一最大size为 m，在经历一系列删除操作后，设现在的剩余节点数是 n，然后执行add操作新增某一个节点，SB树会有一系列的调整操作，但这个调整代价不会大于 $log^m$,调整完成后size变成 n，调整操作从$O(log^m)$ 变成$O(log^n)$

  - SB树 删除成棒状情况下 add 操作为 $O(n)$

#### 代码实现

```java
package zs.order_list;

/**
 * SB树
 *
 * @author miemiehoho
 * @date 2021/12/2 8:43
 */
public class SizeBalancedTreeMap {

    public static class SBTNode<K extends Comparable<K>, V> {
        public K key;
        public V value;
        public SBTNode<K, V> left;
        public SBTNode<K, V> right;
        public int size;

        public SBTNode(K key, V value) {
            this.key = key;
            this.value = value;
            size = 1;
        }
    }

    public static class SizeBalancedTree<K extends Comparable<K>, V> {
        // SBT根节点
        private SBTNode<K, V> root;

        /**
         * 目标节点左旋
         *
         * @param node
         * @return 新的头节点
         */
        private SBTNode<K, V> rotateLeft(SBTNode<K, V> node) {
            SBTNode<K, V> nodeR = node.right;
            node.right = nodeR.left;
            nodeR.left = node;
            nodeR.size = node.size;
            node.size = (node.left != null ? node.left.size : 0) + (node.right != null ? node.right.size : 0) + 1;
            return nodeR;
        }

        /**
         * 目标节点右旋
         *
         * @param node
         * @return 新的头节点
         */
        private SBTNode<K, V> rotateRight(SBTNode<K, V> node) {
            SBTNode<K, V> nodeL = node.left;
            node.left = nodeL.right;
            nodeL.right = node;

            nodeL.size = node.size;
            node.size = (node.left != null ? node.left.size : 0) + (node.right != null ? node.right.size : 0) + 1;
            return nodeL;
        }

        /**
         * 检查目标节点所处子树的平衡性，进行平衡性调整
         *
         * @param node
         * @return 新的头节点
         */
        private SBTNode<K, V> maintain(SBTNode<K, V> node) {
            if (node == null) {
                return null;
            }
            // LL
            if (node.left != null && node.left.left != null && node.right != null && node.left.left.size > node.right.size) {
                node = rotateRight(node);
                node.right = maintain(node.right);
                node = maintain(node);
            } else if (node.left != null && node.left.right != null && node.right != null && node.left.right.size > node.right.size) {
                // LR
                node.left = rotateLeft(node.left);
                node = rotateRight(node);
                node.left = maintain(node.left);
                node.right = maintain(node.right);
                node = maintain(node);
            } else if (node.right != null && node.right.right != null && node.left != null && node.right.right.size > node.left.size) {
                // RR
                node = rotateLeft(node);
                node.left = maintain(node.left);
                node = maintain(node);
            } else if (node.right != null && node.right.left != null && node.left != null && node.right.left.size > node.left.size) {
                // RL
                node.right = rotateRight(node.right);
                node = rotateLeft(node);
                node.left = maintain(node.left);
                node.right = maintain(node.right);
                node = maintain(node);
            }
            return node;
        }


        /**
         * 在SBT中查找key，找不到返回null
         *
         * @param key
         * @return
         */
        private SBTNode<K, V> findKey(K key) {
            SBTNode<K, V> pre = null, cur = root;
            while (cur != null) {
                pre = cur;
                if (key.compareTo(cur.key) == 0) {
                    break;
                }
                if (key.compareTo(cur.key) > 0) {
                    cur = cur.right;
                } else {
                    cur = cur.left;
                }
            }
            return cur;
        }

        /**
         * 在目标节点所在的子树中新增节点,并完成平衡性调整
         *
         * @param node
         * @param key
         * @param value
         * @return 新的头节点
         */
        private SBTNode<K, V> add(SBTNode<K, V> node, K key, V value) {
            if (node == null) {
                return new SBTNode<>(key, value);
            }
            node.size++;
            if (key.compareTo(node.key) > 0) {
                node.right = add(node.right, key, value);
            } else {
                node.left = add(node.left, key, value);
            }
            return maintain(node);
        }


        /**
         * 在目标节点所在的子树中删除key所在节点,并完成平衡性调整
         *
         * @param node
         * @param key
         * @return
         */
        private SBTNode<K, V> delete(SBTNode<K, V> node, K key) {
            node.size--;
            if (key.compareTo(node.key) > 0) {
                node.right = delete(node.right, key);
            } else if (key.compareTo(node.key) < 0) {
                node.left = delete(node.left, key);
            } else {
                if (node.left == null && node.right == null) {
                    node = null;
                } else if (node.left == null) {
                    node = node.right;
                } else if (node.right == null) {
                    node = node.left;
                } else {
                    SBTNode<K, V> newNode = node.right;
                    SBTNode<K, V> newNodePre = null;
                    while (newNode.left != null) {
                        newNodePre = newNode;
                        newNode = newNode.left;
                        newNodePre.size--;
                    }
                    if (node.right != newNode) {
                        newNodePre.left = newNode.right;
                        newNode.right = node.right;
                    }
                    newNode.left = node.left;
                    newNode.size = newNode.left.size + (newNode.right != null ? newNode.right.size : 0) + 1;
                    node = newNode;
                }
            }
//            maintain(node);// 可以，但没必要，add 时检查就行了。
            return node;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            return findKey(key) == null ? false : true;
        }

        /**
         * SBT 新增节点或修改节点value
         *
         * @param key
         * @param value
         */
        public void put(K key, V value) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            SBTNode<K, V> node = findKey(key);
            if (node != null) {
                node.value = value;
                return;
            }
            this.root = add(root, key, value);
        }

        /**
         * SBT 删除节点
         *
         * @param key
         */
        public void remove(K key) {
            if (key == null) {
                throw new RuntimeException("invalid parameter.");
            }
            if (containsKey(key)) {
                root = delete(root, key);
            }
        }

        /**
         * 获取key对应的value
         *
         * @param key
         * @return
         */
        public V get(K key) {
            if (key == null) {
                throw new RuntimeException("invaild parameter.");
            }
            SBTNode<K, V> node = findKey(key);
            return node == null ? null : node.value;
        }
    }

}
```

#### 时间复杂度&空间复杂度

| 算法     |      | **平均**   | **最差**   |
| -------- | ---- | ---------- | ---------- |
| 空间     |      | $O(n)$     | $O(n)$     |
| 搜索     |      | $O(log^n)$ | $O(log^n)$ |
| 插入     |      | $O(log^n)$ | $O(log^n)$ |
| 删除     |      | $O(log^n)$ | $O(log^n)$ |
| maintain |      | $O(1)$     | $O(1)$     |



### AVL树和红黑树的比对

面试题：有了AVL树为什么还要红黑树呢？？（10-1的序列演示） AVL树由于实现比较复杂，而且插入和删除性能差（为什么？），在实际环境下的应用不如红黑树。
红黑树的实际应用非常广泛，如Java中的HashMap和TreeSet，Java 8中HashMap的实现因为用 RBTree代替链表（链表长度>8时），性能有所提升。



### B 树

**B树**（英语：B-tree）是一种自平衡的[树](https://zh.wikipedia.org/wiki/树_(数据结构))，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在[对数时间](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)内完成。B树，概括来说是一个一般化的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)（binary search tree）一个节点可以拥有2个以上的子节点。与[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在[数据库](https://zh.wikipedia.org/wiki/数据库)和[文件系统](https://zh.wikipedia.org/wiki/文件系统)的实现上。

B树，是为磁盘存储而专门设计的一类**平衡搜索树**。由于磁盘操作比随机存储取存器慢得多，因此衡量B树的性能，不仅要考虑动态集合操作消耗了多少计算时间，而且还要考虑这些操作执行了多少次磁盘存取。对每个B树操作，磁盘存取的次数随着B树的高度而增加。

B树与红黑树的不同之处在于B树的结点可以有很多孩子，也就是说一个B树的“分支因子”可以相当大

#### 定义

B树也称多路平衡查找树，是一种组织和维护外存文件系统的非常有效的数据结构。



一个 *m* 阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 *k* − 1 个键
5. 所有的叶子节点都在同一层。B树是所有结点的平衡因子均等于0的多路查找树。

- 在计算B树的高度时，需要计入最底层的外部结点

#### 操作

##### 搜索

B树的搜索和二叉搜索树类似，从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

##### 插入

将关键字K插入B树的过程分两步完成：

1. 查找该关键字的插入节点（B树的插入节点一定是叶子节点层的节点）

2. 插入关键字

   1. 如果插入节点有空位置，即关键字个数 n<m-1:直接把关键字k有序插入到该节点的合适位置上

   2. 插入节点没有空位置，即原插入节点关键字个数 n = m-1 =》分裂

      - 分裂过程：

        - 如果没有双亲节点，新建一个双亲节点，树的高度增加一层
        - 如果有双亲节点，将k插入到双亲节点中

        ![image-20211202215511715](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022155437.png)

**插入实例：**

![image-20211202215759546](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022158935.png)



![image-20211202215911844](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022159842.png)

![image-20211202220039714](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022200528.png)



![image-20211202220214743](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022202444.png)



![image-20211202220245063](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204816.png)



![image-20211202220325109](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204557.png)



![image-20211202220404989](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204896.png)



**思考题：**

1. 在B树中每插入一个关键字，都要新建一个节点吗？
   1. 不一定，如果找到的叶子节点的关键字的个数小于 m-1，就可以直接有序插入
2. 在B树中插入一个关键字，若引起分裂，树高一定会升高一层吗
   1. 不一定，如果父节点的关键字的个数小于 m-1，就不会升高
   2. 如果没有父节点，就需要升高
   3. 如果父节点的关键字的个数超过了 m-1，就需要升高

##### 删除

在B树上删除关键字K的过程分两步完成：

1. 查找关键字K所在的节点
2. 删除关键字K

删除关键字K分两种情况：

- 在叶子节点层删除关键字K
- 在非叶子节点层删除关键字K

**注意：**非根、非叶子节点的关键字个数最少为 (m/2)-1



###### 删除叶子节点中的元素

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

###### 删除内部节点中的元素

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

###### 删除后的重新平衡

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点

**删除实例**

![image-20211202222451739](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227992.png)



![image-20211202222513166](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227159.png)



![image-20211202222528308](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227454.png)



![image-20211202222553712](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227728.png)



![image-20211202222617747](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227715.png)

![image-20211202222731909](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227569.png)



**思考题：**

1. 在B树中每删除一个关键字，都要删除一个节点吗?
   1. 不一定，删除后如果节点个数仍大于等于最小个数就不需要删除
2. 在B树中删除一个关键字若引起合并，树高度一定会降低吗？
   1. 不一定

#### 时间复杂度&空间复杂度

| 算法 |      | **平均**   | **最差**   |
| ---- | ---- | ---------- | ---------- |
| 空间 |      | O(*n*)     | O(*n*)     |
| 搜索 |      | O(log *n*) | O(log *n*) |
| 插入 |      | O(log *n*) | O(log *n*) |
| 删除 |      | O(log *n*) | O(log *n*) |

#### 为什么要使用B树？

**Disk Structure**

块的定义：轨道和扇区的相交位置；块可以通过轨道号和扇区号对磁盘进行寻址

块地址的形式（轨道号，扇区号）

块大小通常为 512字节，以达到稳定的目的

在块中每个字节可以有自己的地址，成为偏移量，因此读取磁盘上特定点的文件需要轨道号、扇区号、偏移量

**数据库表在硬盘中的组织存储形式**

假设现在有一个张 员工信息表 ，这张表有5个字段，共占用128个字节，每个块可以存储4条数据，那么存储100条数据就需要25个块



设想一下，如果我们现在需要获取某条记录，那么我们必须访问所有的25个块，以查找我们需要的数据，因为我们不知道数据存储在什么位置



那么如何可以减少我们的访问时间？

答案是索引，索引将存储表中对应记录的key和指向记录的指针



索引也存储在硬盘中



**多级指数**

在拥有更多条记录比如上千条记录时，索引的规模也就更大了，那么访问索引也将需要更多的时间，那么如何解决这个问题呢？

为索引表添加索引（稀疏索引），这就是B和B+ 树的基本思想。



### B+ 树

**B+ 树**是一种[树数据结构](https://zh.wikipedia.org/wiki/树_(数据结构))，通常用于[数据库](https://zh.wikipedia.org/wiki/数据库)和[操作系统](https://zh.wikipedia.org/wiki/操作系统)的[文件系统](https://zh.wikipedia.org/wiki/文件系统)中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素**自底向上插入**，这与[二叉树](https://zh.wikipedia.org/wiki/二叉树)恰好相反。

#### 定义

![image-20211202222932829](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022229854.png)

一颗m阶B+树需要满足下列要求：

1. 每个分支节点至多有m颗子树（这里m=4）
2. 根节点或者没有子树，或者至少有两颗子树
3. 除根节点外，其他每个分支节点至少有 m/2 颗子树
4. 有 n 颗子树的节点恰好有n个关键字
5. 所有的叶子节点包含了全部关键字及指向相应记录的指针，而且叶子节点按照关键字大小顺序链接。并且将所有叶子节点链接起来。
6. 所有分支节点（可以看成时索引的索引）中仅包含它的各个子节点（即下级索引的索引块）中最大关键字及指向子节点的指针。



### 2-3-4树

#### 定义 

2-3-4树是四阶的 B树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制： 

- 所有叶子节点都拥有相同的深度。 
- 节点只能是 2-节点、3-节点、4-节点之一。
  - 2-节点：包含 1 个元素的节点，有 2 个子节点； 
  - 3-节点：包含 2 个元素的节点，有 3 个子节点；
  - 4-节点：包含 3 个元素的节点，有 4 个子节点； 
  - 所有节点必须至少包含1个元素
- 2-3-4 树的生长（分裂）是**自底向上**生长的
- 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点； 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。
- 2-3-4树是一颗完全数
- 下图是一个典型的 2-3-4树（来自维基百科）：

![2-3-4_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022252449.png)



2-3-4 树在多数编程语言中实现起来相对困难，因为在树上的操作涉及大量特殊情况。[红黑树](https://zh.wikipedia.org/wiki/红黑树)实现起来更简单一些，所以可以用它来替代。

一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树

### 红黑树

它能保证高度是对数阶的，所以它的所有操作都能在 $O(log^n)$ 时间内完成，是 二叉搜索树的一种

每个节点附带一些信息-色域

满足红黑性的有色域的树成为红黑树。

#### Height of red black tree

有 n 个 key 的 red black tree的高度 最多为 $2log^{n+1}$,也就是 $log^n$

**红黑树**（英语：Red–black tree）是一种[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)，是在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中用到的一种[数据结构](https://zh.wikipedia.org/wiki/数据结构)，典型用途是实现[关联数组](https://zh.wikipedia.org/wiki/关联数组)。

红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/算法分析)，并且在实践中高效：它可以在$[{\displaystyle {\text{O}}(\log n)}]$时间内完成查找、插入和删除，这里的${\displaystyle n}$是树中元素的数目。

#### 性质

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。（黑色平衡）

下面是一个具体的红黑树的图例：

![Red-black_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022255662.svg)



#### 红黑树与 2-3-4树的关系

- 一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树
- 红黑树起源于2-3-4树，它的本质就是2-3-4树
- 红黑树的叶子节点及其父节点构成了2-3-4树的叶子节点

#### 2-3-4树与红黑树的等价关系

- 2 节点

  - 只有一种对应关系，只对应红黑树中的黑色节点

    ![image-20211202232427551](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022324203.png)

- 3节点

  - 有两种对应关系，但位于上层的节点一定要是黑色节点

    ![image-20211202232537390](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022325245.png)

- 4节点

  - 只有一种对应关系，处于中间位置的节点位于上层，（中间黑，两边红）

    ![image-20211202232646005](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022326105.png)

- 裂变状态

  - （中间红，两边黑，新加入的节点为红色，但如果是根节点，仍需转变为黑色）

    ![image-20211202233104555](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022331461.png)

#### 推理红黑树5大性质

1. **节点是红色或黑色**
   - 无需推理


2. **根是黑色**

   1. 第一种情况：2-3-4 树的根是2节点

      ![image-20211203081359030](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030814021.png)


   2. 第二种情况：2-3-4 树的根是3节点

      ![image-20211203081724578](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030817972.png)

   3. 第三种情况：2-3-4 树的根是4节点

      ![image-20211203081936381](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030819784.png)

4. **所有叶子节点都是黑色**（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）

所有叶子节点都是null，所以无需推理

4. **每个红色节点都必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）**

   根据2-3-4树和红黑树的等价关系，可知，每个红色节点都必须有两个黑色的子节点

5. **从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点**

- 已知2-3-4树的性质：所有叶子节点都拥有相同的深度，2-3-4 树转换为红黑树后，任何一个节点都包含一个黑色节点

  ![image-20211203083529809](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030835150.png)



#### 红黑树的操作

##### 左旋和右旋

同二叉树

##### 新增操作

红黑树的新增都可以转换为2-3-4树的新增，2-3-4树的新增操作全部在叶子节点完成。

**创建头节点**

此时，不需要合并，新增的节点作为头节点，成为2节点，颜色由红色变成黑色。

![image-20211203101414301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031014724.png)

**新增一个节点与 2 节点合并**

新增节点与2节点合并，直接合并，变为3节点

有两种情况

![image-20211203102543660](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031358886.png)



**新增一个节点 与 3 节点合并**

新增节点与3节点合并，直接合并，变为4节点

分六种情况

![image-20211203103555957](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031035015.png)



新增一个节点与 4 节点合并，此时需要分裂

新增一个节点与 4 节点合并，此时需要分裂；原来的4节点由 上黑下红 变成 上红下黑（如果是根节点还要变回黑色）

分四种情况

![image-20211203104754388](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031047585.png)

##### 新增节点后的调整操作

 2-3-4树新增元素的四种情况：

 1. 新增根节点

    对应红黑树：调整根节点为黑色

 2. 新增一个节点与2节点合并，成为一个3节点
    对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整

 3. 新增一个节点与3节点合并，成为一个4节点
    分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
       对应红黑树：调整后上黑下红

      1. 左左左
         - 目标节点的爷爷节点右旋，目标节点的父亲节点染色为黑色，爷爷节点染色为红色
       2. 左左右
          - 对目标节点的父节点左旋，使之变为左左左的情况，同时指向目标节点的指针也应指向父节点
       3. 右右右
       4. 右右左
       5. 左中右
          - 无需调整
       6. 左中右
          - 无需调整

 4. 新增一个节点与4节点合并，此时需要裂变

    - 新增节点的插入位置有四种
    - 目标节点的爷爷节点不是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点变红
    - 目标节点的爷爷节点是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点不变（还是黑色）

##### 删除操作

- 红黑树的平衡是黑色平衡，只有删除的节点是黑色，才需要调整平衡
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作（当然，这个“叶子节点”可能会有左或右孩子）
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作，也就是2-3-4树的叶子节点

##### 寻找继任结点

如果被删除节点的右子树不为空，返回右子树的最小节点，否则返回第一个大于被删除节点的父类节点

##### 删除操作

1. 被删除的节点是叶子节点，则直接删除
2. 被删除的节点有一个子节点，用子节点来替代
3. 被删除的节点有两个子节点，找到被删除节点的后驱节点（也可以是前驱节点）来替代
   1. 后驱节点没有右子节点的情况
   2. 后驱节点有右子节点的情况清除链接，以便 fixAfterDeletion 可以使用它们

##### 删除后的调整

- 红黑树的删除操作最终都会转换为对 2-3-4树 的叶子节点的删除操作
- 2-3-4数 是一颗满树

对于 3节点和4节点，删除一个叶子节点元素后，仍然满足2-3-4树定义；

对于2节点，删除一个叶子节点元素后无法满足2-3-4树定义

![image-20211204100244379](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041012800.png)



对应 红黑树：

1. 对于 3节点和4节点，删除一个叶子节点元素后，可以通过自我调整满足红黑树定义
2. 对于2节点，删除一个叶子节点元素后，需要进行平衡性调整

##### 调整思路

![image-20211204103528763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041035015.png)

- ”自己搞不定“

  - 对于2节点的删除：需要调整平衡性，以被删除的节点是左孩子节点为例：

    - 如果被删除节点的父节点的右节点是红色，则这个右节点不是被删除节点的兄弟节点（证明它是2-3-4树中的父节点）

      ​	![image-20211204174339812](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041743436.png)

    - 对于被删除节点的父节点的右节点是红色的情况，将父节点左旋一次，根据2-3-4树性质，父节点的右节点必有左右孩子节点，所以左旋后右节点的左节点成为父节点的右节点（也就是真正的兄弟节点）；将父节点染红，父节点的原右节点染黑

      ![image-20211204174623434](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041746163.png)

    - 此时有两种情况：①兄弟节点有的借（是2节点 ）

      ​								②兄弟节点没的借（是3节点或4节点）

    - 对于兄弟节点有的借的情况：被删除节点找父亲节点借，父亲节点空缺用兄弟节点补上

      1. 如果兄弟节点是3节点，也分两种情况：

         - 第一种情况：兄弟节点左子树为空
         - 第二种情况：兄弟节点右子树为空

         对于第二种情况先转换成第一种情况，然后按照第一种情况统一处理

         ![image-20211204180205763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041802581.png)

         ![image-20211204180257855](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041803311.png)

      2. 如果兄弟节点是4节点：

         - 此时有两种处理办法：

           第一种办法：把父亲节点和兄弟节点的左孩子都借给被删除节点（需要旋转两次）

           第二种办法：只借父亲节点给被删除节点（需要旋转一次）

           ![image-20211204200655011](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112042006697.png)

    - 对于兄弟节点没得借的情况：

      - (有难同当)兄弟节点染红，递归处理

- ”自己能搞定“

  - 对于3节点的删除：可以自我调整的删除（比如删除 7.5，则无需调整；删除7，则会用 7.5 代替，即把 7.5 染黑）
  - 对于4节点的删除：不存在删除 4节点中 黑色节点的情况（其实对4节点的删除就是对3节点的删除，个人理解）

#### 代码实现

```java
package zs.order_list;


/**
 * @author miemiehoho
 * @date 2021/12/3 9:09
 */
public class RedBlackTree<K extends Comparable<K>, V> {


    public RedBlackNode<K, V> root;

    /**
     * 左旋
     *
     * @param node
     */
    private void rotateLeft(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.right;
            node.right = newNode.left;
            if (newNode.left != null) {
                newNode.left.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.left = node;
            node.parent = newNode;
        }
    }


    /**
     * 右旋
     *
     * @param node
     * @return
     */
    private void rotateRight(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.left;
            node.left = newNode.right;
            if (newNode.right != null) {
                newNode.right.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.right = node;
            node.parent = newNode;
        }
    }


    /**
     * 对外提供的新增节点操作
     *
     * @param key
     * @param value
     */
    public void put(K key, V value) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> t = root;
        if (t == null) {
            root = new RedBlackNode<>(key, value, null);
            return;
        }
        RedBlackNode<K, V> parent;
        int cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) {
                t = t.left;
            } else if (cmp > 0) {
                t = t.right;
            } else {
                t.setValue(value);
                return;
            }
        } while (t != null);

        RedBlackNode<K, V> newNode = new RedBlackNode<>(key, value, parent);
        if (cmp < 0) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }
        fixAfterInsertion(newNode);
    }

    public V remove(K key) {
        RedBlackNode<K, V> node = getNode(key);
        if (node == null) {
            return null;
        }
        V oldValue = node.value;
        deleteNode(node);
        return oldValue;
    }

    // 删除节点node，然后重新平衡树
    private void deleteNode(RedBlackNode<K, V> node) {
        if (node.left != null && node.right != null) {
            RedBlackNode<K, V> successor = preSuccessor(node);
            node.key = successor.key;
            node.value = successor.value;
            node = successor;// 指向新的被删除节点（后继结点）
        }

        // 我的理解：
        // 1. 对于有左右子节点的情况：这样写是为了拿到后继结点的右子节点
        // 2. 对于只有左子树或右子树的情况，可以兼容
        RedBlackNode<K, V> replacement = node.left != null ? node.left : node.right;

        if (replacement != null) {
            replacement.parent = node.parent;
            if (node.parent == null) {// 被删除节点只有左子树或右子树，且被删除节点是根节点
                root = replacement;
            } else if (node == node.parent.left) {// 被删除节点有左右子树或者只有左或右子树三种情况下，repalcement的归属
                node.parent.left = replacement;
            } else {
                node.parent.right = replacement;
            }
            // 释放链接-源码注释为：清除链接，以便 fixAfterDeletion 可以使用它们
            node.left = node.right = node.parent = null;
            // 从 replacement 节点开始进行平衡性调整
            if (node.color == BLACK) {
                //replacement节点一定是红色
                fixAfterDeletion(replacement);
            }
        } else if (node.parent == null) {// 删除的是根节点
            root = null;
        } else {// 被删除节点是叶子节点，没有孩子节点，使用自己代替自己，并删除
            if (node.color == BLACK) {
                fixAfterDeletion(node);
            }

            if (node.parent != null) {// 存疑
                if (node == node.parent.left) {
                    node.parent.left = null;
                } else {
                    node.parent.right = null;
                }
                node.parent = null;
            }
        }
    }


    /**
     * 从替代节点位置开始调整
     *
     * @param node
     */
    private void fixAfterDeletion(RedBlackNode<K, V> node) {
        while (node != root && colorOf(node) == BLACK) {// 被删除的是2节点
            if (node == leftOf(parentOf(node))) {// 被删除的是左节点

                RedBlackNode<K, V> right = rightOf(parentOf(node));// 兄弟节点
                if (colorOf(right) == RED) {// 如果兄弟节点是红色，说明它不是真正的兄弟节点，而是兄弟节点的父节点
                    // 把兄弟节点染黑，父节点染红，然后父节点左旋
                    setColor(right, BLACK);
                    setColor(parentOf(right), RED);
                    rotateLeft(parentOf(node));
                    right = rightOf(parentOf(node));// 指向真的兄弟节点
                }

                // 找兄弟借，兄弟没得借
                if (colorOf(leftOf(right)) == BLACK && colorOf(rightOf(right)) == BLACK) {
                    setColor(right, RED);
                    node = parentOf(node);// 递归处理
                } else {// 找兄弟借，兄弟有的借
                    // 两种小情况：1.兄弟节点是三节点或四节点
                    if (colorOf(rightOf(right)) == BLACK) {// 兄弟节点的右孩子为空
                        setColor(leftOf(right), BLACK);
                        setColor(right, RED);
                        rotateRight(right);
                        right = rightOf(parentOf(node));
                    }
                    // 对于兄弟节点是四节点的情况，这里用了只旋转一次的方法（还有一种旋转两次的方法）
                    // 还兼顾了三节点的情况：对于三节点，右孩子为空的转化为左孩子为空的情况（也就是上面的if方法）
                    // 实在是妙！
                    setColor(right, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(rightOf(right), BLACK);
                    rotateLeft(parentOf(node));
                    node = root;
                }
            } else {// 被删除的是右节点
                RedBlackNode<K, V> left = leftOf(parentOf(node));
                if (colorOf(left) == RED) {// 父节点右旋，找到真正的兄弟节点
                    setColor(left, BLACK);
                    setColor(parentOf(node), RED);
                    rotateRight(parentOf(node));
                    left = leftOf(parentOf(node));
                }

                if (colorOf(left.left) == BLACK && colorOf(left.right) == BLACK) {// 兄弟节点没得借
                    setColor(left, RED);
                    node = parentOf(node);
                } else {
                    if (colorOf(leftOf(left)) == BLACK) {
                        setColor(rightOf(left), BLACK);
                        setColor(left, RED);
                        rotateLeft(left);
                        left = leftOf(parentOf(node));
                    }
                    setColor(left, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(leftOf(left), BLACK);
                    rotateRight(parentOf(node));
                    node = root;
                }
            }
        }
        // 对于2节点，兄弟没得借的情况，递归到根节点，把根节点染黑
        // 对于3、4节点直接染黑，补偿被删除的黑色节点
        setColor(node, BLACK);
    }

    private RedBlackNode<K, V> getNode(K key) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> cur = root;
        while (cur != null) {
            int cmp = key.compareTo(cur.key);
            if (cmp < 0) {
                cur = cur.left;
            } else if (cmp > 0) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return null;
    }

    /**
     * 返回目标节点的后继节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> successor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {
            RedBlackNode<K, V> p = node.right;
            while (p.left != null) {
                p = p.left;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 返回目标节点的前驱节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> preSuccessor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.left != null) {
            RedBlackNode<K, V> p = node.left;
            while (p.right != null) {
                p = p.right;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.left) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 2-3-4树新增元素的四种情况：
     * 1. 新增根节点
     * 2. 新增一个节点与2节点合并，成为一个3节点
     * 对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整
     * 3. 新增一个节点与3节点合并，成为一个4节点
     * 分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
     * 对应红黑树：调整后上黑下红
     *
     * @param node
     */
    private void fixAfterInsertion(RedBlackNode<K, V> node) {
        node.color = RED;
        // 父节点是黑色的不需要调整
        while (node != null && node != root && node.parent.color == RED) {
            // n爹 = n爹的爹的左孩子：左左左/左左右
            if (parentOf(node) == leftOf(parentOf(parentOf(node)))) {
                RedBlackNode<K, V> y = rightOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在4节点上新增节点的情况
                    setColor(parentOf(node), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == rightOf(parentOf(node))) {// 左左右转换为左左左
                        node = parentOf(node);// 注意这里，node指针指向也要变
                        rotateLeft(parentOf(node));
                    }
                    // 左左左
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateRight(parentOf(parentOf(node)));
                }
            } else {//右右右/右右左
                RedBlackNode<K, V> y = leftOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在四节点上新增节点的情况
                    setColor(y, BLACK);
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == leftOf(parentOf(node))) {
                        node = parentOf(node);
                        rotateRight(node);
                    }
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateLeft(parentOf(parentOf(node)));
                }
            }
        }
        root.color = BLACK;
    }

    private void setColor(RedBlackNode<K, V> node, boolean c) {
        if (node != null) {
            node.color = c;
        }
    }

    private boolean colorOf(RedBlackNode<K, V> node) {
        return node == null ? BLACK : node.color;// node为null则返回nil节点
    }

    private RedBlackNode<K, V> parentOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.parent;
    }

    private RedBlackNode<K, V> leftOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.left;
    }

    private RedBlackNode<K, V> rightOf(RedBlackNode node) {
        return node == null ? null : node.right;
    }

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    // 静态内部类
    static final class RedBlackNode<K extends Comparable<K>, V> {
        K key;
        V value;
        RedBlackNode<K, V> parent;
        RedBlackNode<K, V> left;

        public RedBlackNode<K, V> getLeft() {
            return left;
        }

        public RedBlackNode<K, V> getRight() {
            return right;
        }

        public boolean isColor() {
            return color;
        }

        RedBlackNode<K, V> right;
        boolean color = BLACK;


        public RedBlackNode(K key, V value, RedBlackNode<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }

    }


}
```

#### 时间复杂度&空间复杂度

| 算法 |      | **平均**   | **最差**   |
| ---- | ---- | ---------- | ---------- |
| 空间 |      | $O(n)$     | $O(n)$     |
| 搜索 |      | $O(log^n)$ | $O(log^n)$ |
| 插入 |      | $O(log^n)$ | $O(log^n)$ |
| 删除 |      | $O(log^n)$ | $O(log^n)$ |

#### 优势和用途

 我们知道二叉查找树在不停地添加或删除结点后，可能会退化成链表，这种情况下，二叉查找树的查找效率最坏会降低为 O(n)。
而红黑树由于在插入和删除结点时都会进行变色旋转等操作，在符合红黑树条件的情况下，即使一边子 树全是黑色结点，另一边子树全是红黑相间，两子树的高度差也不会超过一半。

**一棵有 n 个结点的红黑 树高度至多为 2log(n+1)，查找效率最坏为 O(log(n))。**

所以红黑树常被用于需求查找效率稳定的场景，如 Linux 中内核使用它管理内存区域对象、Java8 中 HashMap ，TreeMap的实现等，所以了解红黑树也很有意义



### 跳表

思想性上比搜索二叉树更先进的有序表设计，跳表。

跳表具备所有有序表规定的性能指标，可以改出其他跳表可以实现的所有Api，但它不是搜索二叉树

#### 简介

增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。

可以被看做二叉树的一个变种，它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，目前在Redis和LeveIDB中都有用到

跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。

它使得包含n个元素的有序[序列](https://zh.wikipedia.org/wiki/序列)的查找和插入操作的平均时间复杂度都是${\displaystyle O(\log n)}$，优于[数组](https://zh.wikipedia.org/wiki/数组)的${\displaystyle O(n)}$复杂度。

#### 应用

Redis和LeveIDB

Redis中的有序表用跳表实现

#### 操作

**边界条件：**

- 新增元素的层数 m 如果大于头节点最大层数 n，头节点扩充到 m 层，所有新扩充层的头节点指针指向 新增元素，其他层按照正常情况。
- 删除元素时若该层只有被删除元素，则在删除元素时删除该层的头节点索引

##### 查询

快速的查询效果是通过维护一个多层次的[链表](https://zh.wikipedia.org/wiki/链表)实现的，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择[[2\]](https://zh.wikipedia.org/wiki/跳跃列表#cite_note-pugh-2)或确定性选择[[3\]](https://zh.wikipedia.org/wiki/跳跃列表#cite_note-3)，其中前者更为常见。

##### 删除

#### 代码实现

```java
package zs.order_list;

import java.util.ArrayList;

/**
 * @author miemiehoho
 * @date 2021/12/5 9:39
 */
public class SkipList {

    // 跳表节点类
    public static class SkipListNode<K extends Comparable<K>, V> {
        public K key;
        public V value;
        public ArrayList<SkipListNode<K, V>> nextNodes;

        public SkipListNode(K key, V value) {
            this.key = key;
            this.value = value;
            this.nextNodes = new ArrayList<>();
        }

        /**
         * 判断 当前key是否小于 otherKey
         * <p>
         * 遍历时：遍历到最右侧的null，人为规定最大；如果头节点为null，人为规定最小；
         *
         * @param otherKey
         * @return
         */
        public boolean isKeyLess(K otherKey) {
            return otherKey != null && (key == null || key.compareTo(otherKey) < 0);
        }

        /**
         * 判断key是否与otherKey相等
         *
         * @param otherKey
         * @return
         */
        public boolean isKeyEqual(K otherKey) {
            return (key == null && otherKey == null) || (key != null && otherKey != null && key.compareTo(otherKey) == 0);
        }
    }

    public static class SkipListMap<K extends Comparable<K>, V> {
        private static final double PROBABILITY = 0.5;// 小于 0.5 继续加层数，>=0.5 就停
        private SkipListNode<K, V> head;
        private int size;
        private int maxLevel;

        public SkipListMap() {
            head = new SkipListNode<>(null, null);
            head.nextNodes.add(null);
            size = 0;
            maxLevel = 0;
        }

        public V get(K key) {
            if (key == null) {
                return null;
            }
            SkipListNode<K, V> less = mostRightLessNode(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            return next != null && next.isKeyEqual(key) ? next.value : null;
        }

        public boolean containsKey(K key) {
            if (key == null) {
                return false;
            }
            SkipListNode<K, V> less = mostRightLessNode(key);// 比key小的最右的节点
            SkipListNode<K, V> node = less.nextNodes.get(0);// less在0层的下一个节点
            return node != null && node.isKeyEqual(key);
        }

        public void put(K key, V value) {
            if (key == null) {
                return;
            }
            SkipListNode<K, V> less = mostRightLessNode(key);
            SkipListNode<K, V> next = less.nextNodes.get(0);
            if (next != null && next.isKeyEqual(key)) {// 更新元素
                next.value = value;
            } else {// 新增元素
                size++;
                int newNodeLevel = 0;
                while (Math.random() < PROBABILITY) {// 随机选择层数
                    newNodeLevel++;
                }

                while (maxLevel < newNodeLevel) {// 头节点扩充
                    head.nextNodes.add(null);
                    maxLevel++;
                }

                // 创建一个 有newNodeLevel 层的node
                SkipListNode<K, V> newNode = new SkipListNode<>(key, value);
                for (int i = 0; i <= newNodeLevel; i++) {
                    newNode.nextNodes.add(null);
                }

                int level = maxLevel;
                SkipListNode<K, V> pre = head;
                while (level >= 0) {
                    pre = mostRightLessNodeInLevel(key, pre, level);// 当前层中比key小的最右侧节点
                    if (level <= newNodeLevel) {// 如果  newNode 拥有当前层
                        newNode.nextNodes.set(level, pre.nextNodes.get(level));
                        pre.nextNodes.set(level, newNode);
                    }
                    level--;
                }
            }
        }

        public void remove(K key) {
            if (!containsKey(key)) {
                return;
            }
            size--;
            int level = maxLevel;
            SkipListNode<K, V> pre = head;
            SkipListNode<K, V> next = null;
            while (level >= 0) {
                pre = mostRightLessNodeInLevel(key, pre, level);
                next = pre.nextNodes.get(level);
                if (next != null && next.isKeyEqual(key)) {// 当前层含有key
                    pre.nextNodes.set(level, next.nextNodes.get(level));
                }

                if (level != 0 && pre == head && pre.nextNodes.get(level) == null) {// 当前层为空
                    head.nextNodes.remove(level);// 缩层
                    maxLevel--;
                }
                level--;
            }

        }

        /**
         * 从最高层开始，逐层往下找，直到第0层，返回比key小的最大的元素（小于key的最右节点）
         *
         * @param key
         * @return
         */
        private SkipListNode<K, V> mostRightLessNode(K key) {
            if (key == null) {
                return null;
            }
            int level = maxLevel;
            SkipListNode<K, V> cur = head;
            while (level >= 0) {
                cur = mostRightLessNodeInLevel(key, cur, level--);
            }
            return cur;
        }

        /**
         * 在 cur节点的level层寻找比key小的最后一个节点
         *
         * @param key
         * @param cur
         * @param level
         * @return
         */
        private SkipListNode<K, V> mostRightLessNodeInLevel(K key, SkipListNode<K, V> cur, int level) {
            SkipListNode<K, V> next = cur.nextNodes.get(level);
            while (next != null && next.isKeyLess(key)) {
                cur = next;
                next = next.nextNodes.get(level);
            }
            return cur;
        }
    }
}
```

#### 时间复杂度&空间复杂度

| 算法 |      | **平均**   | **最差**                                                     |
| ---- | ---- | ---------- | ------------------------------------------------------------ |
| 空间 |      | O(*n*)     | O(*n* log *n*)[[1\]](https://zh.wikipedia.org/wiki/跳跃列表#cite_note-cs.uwaterloo-1) |
| 搜索 |      | O(log *n*) | O(*n*)[[1\]](https://zh.wikipedia.org/wiki/跳跃列表#cite_note-cs.uwaterloo-1) |
| 插入 |      | O(log *n*) | O(*n*)                                                       |
| 删除 |      | O(log *n*) | O(*n*)                                                       |





