

## B 树

**B树**（英语：B-tree）是一种自平衡的[树](https://zh.wikipedia.org/wiki/树_(数据结构))，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在[对数时间](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)内完成。B树，概括来说是一个一般化的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)（binary search tree）一个节点可以拥有2个以上的子节点。与[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在[数据库](https://zh.wikipedia.org/wiki/数据库)和[文件系统](https://zh.wikipedia.org/wiki/文件系统)的实现上。



B树，是为磁盘存储而专门设计的一类**平衡搜索树**。由于磁盘操作比随机存储取存器慢得多，因此衡量B树的性能，不仅要考虑动态集合操作消耗了多少计算时间，而且还要考虑这些操作执行了多少次磁盘存取。对每个B树操作，磁盘存取的次数随着B树的高度而增加。

B树与红黑树的不同之处在于B树的结点可以有很多孩子，也就是说一个B树的“分支因子”可以相当大

### 定义

B树也称多路平衡查找树，是一种组织和维护外存文件系统的非常有效的数据结构。



一个 *m* 阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 *k* − 1 个键
5. 所有的叶子节点都在同一层。B树是所有结点的平衡因子均等于0的多路查找树。

- 在计算B树的高度时，需要计入最底层的外部结点

### 操作

#### 搜索

B树的搜索和二叉搜索树类似，从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

#### 插入

将关键字K插入B树的过程分两步完成：

1. 查找该关键字的插入节点（B树的插入节点一定是叶子节点层的节点）

2. 插入关键字

   1. 如果插入节点有空位置，即关键字个数 n<m-1:直接把关键字k有序插入到该节点的合适位置上

   2. 插入节点没有空位置，即原插入节点关键字个数 n = m-1 =》分裂

      - 分裂过程：

        - 如果没有双亲节点，新建一个双亲节点，树的高度增加一层
        - 如果有双亲节点，将k插入到双亲节点中

        ![image-20211202215511715](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022155437.png)

**插入实例：**

![image-20211202215759546](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022158935.png)



![image-20211202215911844](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022159842.png)

![image-20211202220039714](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022200528.png)



![image-20211202220214743](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022202444.png)



![image-20211202220245063](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204816.png)



![image-20211202220325109](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204557.png)



![image-20211202220404989](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204896.png)



**思考题：**

1. 在B树中每插入一个关键字，都要新建一个节点吗？
   1. 不一定，如果找到的叶子节点的关键字的个数小于 m-1，就可以直接有序插入
2. 在B树中插入一个关键字，若引起分裂，树高一定会升高一层吗
   1. 不一定，如果父节点的关键字的个数小于 m-1，就不会升高
   2. 如果没有父节点，就需要升高
   3. 如果父节点的关键字的个数超过了 m-1，就需要升高

#### 删除

在B树上删除关键字K的过程分两步完成：

1. 查找关键字K所在的节点
2. 删除关键字K

删除关键字K分两种情况：

- 在叶子节点层删除关键字K
- 在非叶子节点层删除关键字K

**注意：**非根、非叶子节点的关键字个数最少为 (m/2)-1



##### 删除叶子节点中的元素

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

##### 删除内部节点中的元素

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

##### 删除后的重新平衡

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点

**删除实例**

![image-20211202222451739](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227992.png)



![image-20211202222513166](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227159.png)



![image-20211202222528308](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227454.png)



![image-20211202222553712](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227728.png)



![image-20211202222617747](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227715.png)

![image-20211202222731909](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227569.png)



**思考题：**

1. 在B树中每删除一个关键字，都要删除一个节点吗?
   1. 不一定，删除后如果节点个数仍大于等于最小个数就不需要删除
2. 在B树中删除一个关键字若引起合并，树高度一定会降低吗？
   1. 不一定

#### 为什么要使用B树？

**Disk Structure**

块的定义：轨道和扇区的相交位置；块可以通过轨道号和扇区号对磁盘进行寻址

块地址的形式（轨道号，扇区号）

块大小通常为 512字节，以达到稳定的目的

在块中每个字节可以有自己的地址，成为偏移量，因此读取磁盘上特定点的文件需要轨道号、扇区号、偏移量

**数据库表在硬盘中的组织存储形式**

假设现在有一个张 员工信息表 ，这张表有5个字段，共占用128个字节，每个块可以存储4条数据，那么存储100条数据就需要25个块



设想一下，如果我们现在需要获取某条记录，那么我们必须访问所有的25个块，以查找我们需要的数据，因为我们不知道数据存储在什么位置



那么如何可以减少我们的访问时间？

答案是索引，索引将存储表中对应记录的key和指向记录的指针



索引也存储在硬盘中



**多级指数**

在拥有更多条记录比如上千条记录时，索引的规模也就更大了，那么访问索引也将需要更多的时间，那么如何解决这个问题呢？

为索引表添加索引（稀疏索引），这就是B和B+ 树的基本思想。



## B+ 树

**B+ 树**是一种[树数据结构](https://zh.wikipedia.org/wiki/树_(数据结构))，通常用于[数据库](https://zh.wikipedia.org/wiki/数据库)和[操作系统](https://zh.wikipedia.org/wiki/操作系统)的[文件系统](https://zh.wikipedia.org/wiki/文件系统)中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素**自底向上插入**，这与[二叉树](https://zh.wikipedia.org/wiki/二叉树)恰好相反。

### 定义

![image-20211202222932829](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022229854.png)

一颗m阶B+树需要满足下列要求：

1. 每个分支节点至多有m颗子树（这里m=4）
2. 根节点或者没有子树，或者至少有两颗子树
3. 除根节点外，其他每个分支节点至少有 m/2 颗子树
4. 有 n 颗子树的节点恰好有n个关键字
5. 所有的叶子节点包含了全部关键字及指向相应记录的指针，而且叶子节点按照关键字大小顺序链接。并且将所有叶子节点链接起来。
6. 所有分支节点（可以看成时索引的索引）中仅包含它的各个子节点（即下级索引的索引块）中最大关键字及指向子节点的指针。



## 2-3-4树

### 定义 

2-3-4树是四阶的 B树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制： 

- 所有叶子节点都拥有相同的深度。 
- 节点只能是 2-节点、3-节点、4-节点之一。
  - 2-节点：包含 1 个元素的节点，有 2 个子节点； 
  - 3-节点：包含 2 个元素的节点，有 3 个子节点；
  -  4-节点：包含 3 个元素的节点，有 4 个子节点； 
  - 所有节点必须至少包含1个元素
- 2-3-4 树的生长（分裂）是**自底向上**生长的
- 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点； 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。
- 2-3-4树是一颗完全数
- 下图是一个典型的 2-3-4树（来自维基百科）：

![2-3-4_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022252449.png)



2-3-4 树在多数编程语言中实现起来相对困难，因为在树上的操作涉及大量特殊情况。[红黑树](https://zh.wikipedia.org/wiki/红黑树)实现起来更简单一些，所以可以用它来替代。

一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树

## 红黑树

**红黑树**（英语：Red–black tree）是一种[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)，是在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中用到的一种[数据结构](https://zh.wikipedia.org/wiki/数据结构)，典型用途是实现[关联数组](https://zh.wikipedia.org/wiki/关联数组)。

红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/算法分析)，并且在实践中高效：它可以在$[{\displaystyle {\text{O}}(\log n)}]$时间内完成查找、插入和删除，这里的${\displaystyle n}$是树中元素的数目。

### 性质

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。（黑色平衡）

下面是一个具体的红黑树的图例：

![Red-black_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022255662.svg)



### 红黑树与 2-3-4树的关系

- 一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树
- 红黑树起源于2-3-4树，它的本质就是2-3-4树
- 红黑树的叶子节点及其父节点构成了2-3-4树的叶子节点

#### 2-3-4树与红黑树的等价关系

- 2 节点

  - 只有一种对应关系，只对应红黑树中的黑色节点

    ![image-20211202232427551](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022324203.png)

- 3节点

  - 有两种对应关系，但位于上层的节点一定要是黑色节点

    ![image-20211202232537390](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022325245.png)

- 4节点

  - 只有一种对应关系，处于中间位置的节点位于上层，（中间黑，两边红）

    ![image-20211202232646005](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022326105.png)

- 裂变状态

  - （中间红，两边黑，新加入的节点为红色，但如果是根节点，仍需转变为黑色）

    ![image-20211202233104555](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022331461.png)

#### 推理红黑树5大性质

1. **节点是红色或黑色**
   - 无需推理


2. **根是黑色**

   1. 第一种情况：2-3-4 树的根是2节点

      ![image-20211203081359030](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030814021.png)


   2. 第二种情况：2-3-4 树的根是3节点

      ![image-20211203081724578](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030817972.png)

   3. 第三种情况：2-3-4 树的根是4节点

      ![image-20211203081936381](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030819784.png)

3. **所有叶子节点都是黑色**（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）

所有叶子节点都是null，所以无需推理

4. **每个红色节点都必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）**

   根据2-3-4树和红黑树的等价关系，可知，每个红色节点都必须有两个黑色的子节点

5. **从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点**

- 已知2-3-4树的性质：所有叶子节点都拥有相同的深度，2-3-4 树转换为红黑树后，任何一个节点都包含一个黑色节点

  ![image-20211203083529809](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030835150.png)



### 红黑树的操作

#### 左旋和右旋

同二叉树

#### 新增操作

红黑树的新增都可以转换为2-3-4树的新增，2-3-4树的新增操作全部在叶子节点完成。

**创建头节点**

此时，不需要合并，新增的节点作为头节点，成为2节点，颜色由红色变成黑色。

![image-20211203101414301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031014724.png)

**新增一个节点与 2 节点合并**

新增节点与2节点合并，直接合并，变为3节点

有两种情况

![image-20211203102543660](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031358886.png)



**新增一个节点 与 3 节点合并**

新增节点与3节点合并，直接合并，变为4节点

分六种情况

![image-20211203103555957](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031035015.png)



新增一个节点与 4 节点合并，此时需要分裂

新增一个节点与 4 节点合并，此时需要分裂；原来的4节点由 上黑下红 变成 上红下黑（如果是根节点还要变回黑色）

分四种情况

![image-20211203104754388](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031047585.png)

#### 新增节点后的调整操作

 2-3-4树新增元素的四种情况：
 1. 新增根节点

       对应红黑树：调整根节点为黑色

 2. 新增一个节点与2节点合并，成为一个3节点
      对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整

 3. 新增一个节点与3节点合并，成为一个4节点
       分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
          对应红黑树：调整后上黑下红

        1. 左左左
              - 目标节点的爷爷节点右旋，目标节点的父亲节点染色为黑色，爷爷节点染色为红色
         2. 左左右
              - 对目标节点的父节点左旋，使之变为左左左的情况，同时指向目标节点的指针也应指向父节点
         3. 右右右
         4. 右右左
         5. 左中右
              - 无需调整
         6. 左中右
              - 无需调整
       
 4. 新增一个节点与4节点合并，此时需要裂变

       - 新增节点的插入位置有四种
       - 目标节点的爷爷节点不是根节点
         - 目标节点的父亲和叔叔节点变黑，爷爷节点变红
       - 目标节点的爷爷节点是根节点
         - 目标节点的父亲和叔叔节点变黑，爷爷节点不变（还是黑色）

#### 删除操作

- 红黑树的平衡是黑色平衡，只有删除的节点是黑色，才需要调整平衡
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作（当然，这个“叶子节点”可能会有左或右孩子）
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作，也就是2-3-4树的叶子节点

##### 寻找继任结点

如果被删除节点的右子树不为空，返回右子树的最小节点，否则返回第一个大于被删除节点的父类节点

##### 删除操作

1. 被删除的节点是叶子节点，则直接删除
2. 被删除的节点有一个子节点，用子节点来替代
3. 被删除的节点有两个子节点，找到被删除节点的后驱节点（也可以是前驱节点）来替代
   1. 后驱节点没有右子节点的情况
   2. 后驱节点有右子节点的情况清除链接，以便 fixAfterDeletion 可以使用它们

##### 删除后的调整

- 红黑树的删除操作最终都会转换为对 2-3-4树 的叶子节点的删除操作
- 2-3-4数 是一颗满树

对于 3节点和4节点，删除一个叶子节点元素后，仍然满足2-3-4树定义；

对于2节点，删除一个叶子节点元素后无法满足2-3-4树定义

![image-20211204100244379](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041012800.png)



对应 红黑树：

1. 对于 3节点和4节点，删除一个叶子节点元素后，可以通过自我调整满足红黑树定义
2. 对于2节点，删除一个叶子节点元素后，需要进行平衡性调整

##### 调整思路

![image-20211204103528763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041035015.png)

- ”自己搞不定“

  - 对于2节点的删除：需要调整平衡性，以被删除的节点是左孩子节点为例：

    - 如果被删除节点的父节点的右节点是红色，则这个右节点不是被删除节点的兄弟节点（证明它是2-3-4树中的父节点）

      ​	![image-20211204174339812](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041743436.png)

    - 对于被删除节点的父节点的右节点是红色的情况，将父节点左旋一次，根据2-3-4树性质，父节点的右节点必有左右孩子节点，所以左旋后右节点的左节点成为父节点的右节点（也就是真正的兄弟节点）；将父节点染红，父节点的原右节点染黑

      ![image-20211204174623434](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041746163.png)

    - 此时有两种情况：①兄弟节点有的借（是2节点 ）

      ​								②兄弟节点没的借（是3节点或4节点）

    - 对于兄弟节点有的借的情况：被删除节点找父亲节点借，父亲节点空缺用兄弟节点补上

      1. 如果兄弟节点是3节点，也分两种情况：

         - 第一种情况：兄弟节点左子树为空
         - 第二种情况：兄弟节点右子树为空

         对于第二种情况先转换成第一种情况，然后按照第一种情况统一处理

         ![image-20211204180205763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041802581.png)

         ![image-20211204180257855](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041803311.png)

      2. 如果兄弟节点是4节点：

         - 此时有两种处理办法：

           第一种办法：把父亲节点和兄弟节点的左孩子都借给被删除节点（需要旋转两次）

           第二种办法：只借父亲节点给被删除节点（需要旋转一次）

           ![image-20211204200655011](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112042006697.png)

    - 对于兄弟节点没得借的情况：

      - (有难同当)兄弟节点染红，递归处理

- ”自己能搞定“
  - 对于3节点的删除：可以自我调整的删除（比如删除 7.5，则无需调整；删除7，则会用 7.5 代替，即把 7.5 染黑）
  - 对于4节点的删除：不存在删除 4节点中 黑色节点的情况（其实对4节点的删除就是对3节点的删除，个人理解）

#### 代码实现

```java
package zs.order_list;


/**
 * @author miemiehoho
 * @date 2021/12/3 9:09
 */
public class RedBlackTree<K extends Comparable<K>, V> {


    public RedBlackNode<K, V> root;

    /**
     * 左旋
     *
     * @param node
     */
    private void rotateLeft(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.right;
            node.right = newNode.left;
            if (newNode.left != null) {
                newNode.left.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.left = node;
            node.parent = newNode;
        }
    }


    /**
     * 右旋
     *
     * @param node
     * @return
     */
    private void rotateRight(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.left;
            node.left = newNode.right;
            if (newNode.right != null) {
                newNode.right.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.right = node;
            node.parent = newNode;
        }
    }


    /**
     * 对外提供的新增节点操作
     *
     * @param key
     * @param value
     */
    public void put(K key, V value) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> t = root;
        if (t == null) {
            root = new RedBlackNode<>(key, value, null);
            return;
        }
        RedBlackNode<K, V> parent;
        int cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) {
                t = t.left;
            } else if (cmp > 0) {
                t = t.right;
            } else {
                t.setValue(value);
                return;
            }
        } while (t != null);

        RedBlackNode<K, V> newNode = new RedBlackNode<>(key, value, parent);
        if (cmp < 0) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }
        fixAfterInsertion(newNode);
    }

    public V remove(K key) {
        RedBlackNode<K, V> node = getNode(key);
        if (node == null) {
            return null;
        }
        V oldValue = node.value;
        deleteNode(node);
        return oldValue;
    }

    // 删除节点node，然后重新平衡树
    private void deleteNode(RedBlackNode<K, V> node) {
        if (node.left != null && node.right != null) {
            RedBlackNode<K, V> successor = preSuccessor(node);
            node.key = successor.key;
            node.value = successor.value;
            node = successor;// 指向新的被删除节点（后继结点）
        }

        // 我的理解：
        // 1. 对于有左右子节点的情况：这样写是为了拿到后继结点的右子节点
        // 2. 对于只有左子树或右子树的情况，可以兼容
        RedBlackNode<K, V> replacement = node.left != null ? node.left : node.right;

        if (replacement != null) {
            replacement.parent = node.parent;
            if (node.parent == null) {// 被删除节点只有左子树或右子树，且被删除节点是根节点
                root = replacement;
            } else if (node == node.parent.left) {// 被删除节点有左右子树或者只有左或右子树三种情况下，repalcement的归属
                node.parent.left = replacement;
            } else {
                node.parent.right = replacement;
            }
            // 释放链接-源码注释为：清除链接，以便 fixAfterDeletion 可以使用它们
            node.left = node.right = node.parent = null;
            // 从 replacement 节点开始进行平衡性调整
            if (node.color == BLACK) {
                //replacement节点一定是红色
                fixAfterDeletion(replacement);
            }
        } else if (node.parent == null) {// 删除的是根节点
            root = null;
        } else {// 被删除节点是叶子节点，没有孩子节点，使用自己代替自己，并删除
            if (node.color == BLACK) {
                fixAfterDeletion(node);
            }

            if (node.parent != null) {// 存疑
                if (node == node.parent.left) {
                    node.parent.left = null;
                } else {
                    node.parent.right = null;
                }
                node.parent = null;
            }
        }
    }


    /**
     * 从替代节点位置开始调整
     *
     * @param node
     */
    private void fixAfterDeletion(RedBlackNode<K, V> node) {
        while (node != root && colorOf(node) == BLACK) {// 被删除的是2节点
            if (node == leftOf(parentOf(node))) {// 被删除的是左节点

                RedBlackNode<K, V> right = rightOf(parentOf(node));// 兄弟节点
                if (colorOf(right) == RED) {// 如果兄弟节点是红色，说明它不是真正的兄弟节点，而是兄弟节点的父节点
                    // 把兄弟节点染黑，父节点染红，然后父节点左旋
                    setColor(right, BLACK);
                    setColor(parentOf(right), RED);
                    rotateLeft(parentOf(node));
                    right = rightOf(parentOf(node));// 指向真的兄弟节点
                }

                // 找兄弟借，兄弟没得借
                if (colorOf(leftOf(right)) == BLACK && colorOf(rightOf(right)) == BLACK) {
                    setColor(right, RED);
                    node = parentOf(node);// 递归处理
                } else {// 找兄弟借，兄弟有的借
                    // 两种小情况：1.兄弟节点是三节点或四节点
                    if (colorOf(rightOf(right)) == BLACK) {// 兄弟节点的右孩子为空
                        setColor(leftOf(right), BLACK);
                        setColor(right, RED);
                        rotateRight(right);
                        right = rightOf(parentOf(node));
                    }
                    // 对于兄弟节点是四节点的情况，这里用了只旋转一次的方法（还有一种旋转两次的方法）
                    // 还兼顾了三节点的情况：对于三节点，右孩子为空的转化为左孩子为空的情况（也就是上面的if方法）
                    // 实在是妙！
                    setColor(right, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(rightOf(right), BLACK);
                    rotateLeft(parentOf(node));
                    node = root;
                }
            } else {// 被删除的是右节点
                RedBlackNode<K, V> left = leftOf(parentOf(node));
                if (colorOf(left) == RED) {// 父节点右旋，找到真正的兄弟节点
                    setColor(left, BLACK);
                    setColor(parentOf(node), RED);
                    rotateRight(parentOf(node));
                    left = leftOf(parentOf(node));
                }

                if (colorOf(left.left) == BLACK && colorOf(left.right) == BLACK) {// 兄弟节点没得借
                    setColor(left, RED);
                    node = parentOf(node);
                } else {
                    if (colorOf(leftOf(left)) == BLACK) {
                        setColor(rightOf(left), BLACK);
                        setColor(left, RED);
                        rotateLeft(left);
                        left = leftOf(parentOf(node));
                    }
                    setColor(left, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(leftOf(left), BLACK);
                    rotateRight(parentOf(node));
                    node = root;
                }
            }
        }
        // 对于2节点，兄弟没得借的情况，递归到根节点，把根节点染黑
        // 对于3、4节点直接染黑，补偿被删除的黑色节点
        setColor(node, BLACK);
    }

    private RedBlackNode<K, V> getNode(K key) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> cur = root;
        while (cur != null) {
            int cmp = key.compareTo(cur.key);
            if (cmp < 0) {
                cur = cur.left;
            } else if (cmp > 0) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return null;
    }

    /**
     * 返回目标节点的后继节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> successor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {
            RedBlackNode<K, V> p = node.right;
            while (p.left != null) {
                p = p.left;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 返回目标节点的前驱节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> preSuccessor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.left != null) {
            RedBlackNode<K, V> p = node.left;
            while (p.right != null) {
                p = p.right;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.left) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 2-3-4树新增元素的四种情况：
     * 1. 新增根节点
     * 2. 新增一个节点与2节点合并，成为一个3节点
     * 对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整
     * 3. 新增一个节点与3节点合并，成为一个4节点
     * 分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
     * 对应红黑树：调整后上黑下红
     *
     * @param node
     */
    private void fixAfterInsertion(RedBlackNode<K, V> node) {
        node.color = RED;
        // 父节点是黑色的不需要调整
        while (node != null && node != root && node.parent.color == RED) {
            // n爹 = n爹的爹的左孩子：左左左/左左右
            if (parentOf(node) == leftOf(parentOf(parentOf(node)))) {
                RedBlackNode<K, V> y = rightOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在4节点上新增节点的情况
                    setColor(parentOf(node), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == rightOf(parentOf(node))) {// 左左右转换为左左左
                        node = parentOf(node);// 注意这里，node指针指向也要变
                        rotateLeft(parentOf(node));
                    }
                    // 左左左
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateRight(parentOf(parentOf(node)));
                }
            } else {//右右右/右右左
                RedBlackNode<K, V> y = leftOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在四节点上新增节点的情况
                    setColor(y, BLACK);
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == leftOf(parentOf(node))) {
                        node = parentOf(node);
                        rotateRight(node);
                    }
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateLeft(parentOf(parentOf(node)));
                }
            }
        }
        root.color = BLACK;
    }

    private void setColor(RedBlackNode<K, V> node, boolean c) {
        if (node != null) {
            node.color = c;
        }
    }

    private boolean colorOf(RedBlackNode<K, V> node) {
        return node == null ? BLACK : node.color;// node为null则返回nil节点
    }

    private RedBlackNode<K, V> parentOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.parent;
    }

    private RedBlackNode<K, V> leftOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.left;
    }

    private RedBlackNode<K, V> rightOf(RedBlackNode node) {
        return node == null ? null : node.right;
    }

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    // 静态内部类
    static final class RedBlackNode<K extends Comparable<K>, V> {
        K key;
        V value;
        RedBlackNode<K, V> parent;
        RedBlackNode<K, V> left;

        public RedBlackNode<K, V> getLeft() {
            return left;
        }

        public RedBlackNode<K, V> getRight() {
            return right;
        }

        public boolean isColor() {
            return color;
        }

        RedBlackNode<K, V> right;
        boolean color = BLACK;


        public RedBlackNode(K key, V value, RedBlackNode<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }

    }

}
```

## 线段树-区间修改树

### 定义

**线段树**（英语：Segment tree）是一种[二叉树](https://zh.wikipedia.org/wiki/二元樹)形数据结构，用以存储[区间](https://zh.wikipedia.org/wiki/區間)或[线段](https://zh.wikipedia.org/wiki/線段)，并且允许快速查询结构内包含某一点的所有区间。

一个包含${\displaystyle n}$个区间的线段树，空间复杂度为${\displaystyle O(n)}$，查询的时间复杂度则为${\displaystyle O(\log n+k)}$，其中${\displaystyle k}$是符合条件的区间数量。

此数据结构亦可推广到高维度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，[时间复杂度](https://baike.baidu.com/item/时间复杂度)为O(logN）

使用线段树可以快速 修改、查询区间的某些东西



### **完全二叉树与数组的转换**

**数组下标从 1 开始**，这样可以方便的转换，且可以用位运算加速

1. 如何找到节点n的父节点？
   - 父节点下标 = n/2
2. 如何找到节点n的左孩子节点和右孩子节点
   - $左孩子节点下标 = 2*n$
   - $右孩子节点下标 = 2*n +1$
3. 如何确定长度为n的完全二叉树的一个节点是否是叶子节点
   - $长度为n的完全二叉树的叶子节点下标 大于 n/2$

![image-20211114172207301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141722372.png)

### 线段树空间复杂度

对于 n 个节点，建立满二叉树，**最多**需要 4n 空间：

对于最差情况，满二叉树左子树叶子节点有 n - 1 个（逼近 n ），右子树叶子节点有 1 个，为了补成 满二叉树，右子树 也应有 n-1个叶子节点（逼近 n），那么构建满二叉树，最多需要 4n 空间（可能会有些浪费，没关系，）

![image-20211221095525649](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112210955051.png)

最省空间情况：n 正好是 $2^k$

最不省空间情况：n 是 $2^k-1$

**实例：**

- 最省空间情况： 对于 n = 8 的情况，建立满二叉树，需要 8*2 - 1 = 15 的空间

- 最不省空间情况：对于 n = 5 的情况，建立满二叉树，需要 8*2 - 1 = 15 的空间

### 线段树三个方法

时间复杂度都是 $O(log^n)$

```java
void add(int L,int R,int v,int[] arr);
void update(int L,int R,int v,int[] arr);
void get(int L,int R,int v,int[] arr);
```

### 线段树增加想要的信息 - 以求 线段累加和(sum)  信息为例

#### 线段树初始化

```java
package zs.tree;

/**
 * @author miemiehoho
 * @date 2021/12/21 9:37
 */
public class SegmentTree {

    private int MAXN;
    private int[] arr;// arr[]为原序列的信息从0开始，但在arr里是从1开始的
    private int[] sum;// sum[]模拟线段树维护区间和

    public SegmentTree(int[] origin) {
        this.MAXN = arr.length + 1;
        arr = new int[MAXN];
        for (int i = 1; i < MAXN; i++) {
            arr[i] = origin[i - 1];
        }
        sum = new int[MAXN << 2];
    }

    /**
     * 线段树初始化，填写 sum数组
     * 在 arr[l~r] 范围上 build
     * rt : 这个范围在 sum 中的下标
     *
     * @param l
     * @param r
     * @param rt
     */
    private void build(int l, int r, int rt) {
        if (l == r) {// 长度为1的线段，即元线段
            sum[rt] = arr[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);// 利用位运算加速
        build(mid + 1, r, rt << 1 | 1);
        pushUp(rt);
    }

    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    }
}
```

#### 线段树-懒更新机制

- 如果下发的任务，把当前范围全包括了（即“懒的住”）：
  - 则任务不再下发，更新当前范围（节点rt）的 sum 信息，并把 “懒住” 的信息存入 lazy 数组
- 如果下发的任务，无法把当前范围全包括（即“懒不住”）：
  1. 下发之前 “懒住”的信息给左右子树
  2. 下发新任务给 左右子树

懒更新机制 优点：

- 时间复杂度 $O(log^n)$：总是会卡着左边界或卡着右边界，所以就是$O(log^n)$

##### 懒更新机制 - 实例

假设线段树 范围是 1~1024

**1、“懒的住” 的情况**

如果要更新 1~256的信息，加 7：

1. 根结点把任务下发给左右子结点，
2. 那么对于节点 x (它是 1~256这颗子树的根结点)，它将不再把任务下发，也就是这次更新只经历了部分边界，所以 懒更新的 时间复杂度 $O(log^n)$

**2、“懒不住” 的情况**

如果又要更新 1~100的信息，加 5：

1. 结点 x 把 之前的 “懒住” 的任务下发给左右子结点
2. 接受新信息：更新 1~100,范围 小于 1~256，即 “懒不住” ，将新任务下发给左子树
3.  x 的左子树继续判断 是否“懒的住”，然后执行相应方法 



#### 线段树 - add() 方法

```java
/**
 * [L……R] 任务范围
 * [l……r] 当前节点范围
 * rt 当前节点
 */
public void add(int L, int R, int C, int l, int r, int rt) {
    // 任务范围被覆盖，直接 懒住
    if (L <= l && R >= r) {
        sum[rt] += (r - l + 1) * C;// sum[rt]累加
        lazy[rt] += C;// lazy[rt] 累加
        return;
    }
    // 任务并没有被全包，需要下发任务
    int mid = (l + r) >> 1;
    // 下发之前攒的所有 懒任务
    pushDown(rt, mid - l + 1, r - mid);
    if (L <= mid) {// 左孩子是否需要接收任务
        add(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {// 右孩子是否需要接受任务
        add(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    // 左右孩子完成任务后，更新自己的sum信息
    pushUp(rt);
}
```

#### 线段树 - update() 方法

```java
public void update(int L, int R, int C, int l, int r, int rt) {
    // 被包住
    if (L <= l && R >= r) {
        update[rt] = true;
        change[rt] = C;
        sum[rt] = C * (r - l + 1);
        lazy[rt] = 0;
        return;
    }
    // 当前任务躲不掉了
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    if (L <= mid) {
        update(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {
        update(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    pushUp(rt);
}
```

#### 线段树 - getSum() 方法

```java
public long query(int L, int R, int l, int r, int rt) {
    if (L <= l && r <= R) {
        return sum[rt];
    }
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    long ans = 0;// long型，防止越界
    if (L <= mid) {
        ans += query(L, R, l, mid, rt << 1);
    }
    if (R > mid) {
        ans += query(L, R, mid + 1, r, rt << 1 | 1);
    }
    return ans;
}
```

### 完整代码实现

```java
package zs.tree;

/**
 * @author miemiehoho
 * @date 2021/12/21 9:37
 */
public class SegmentTree {

    private int MAXN;
    private int[] arr;// arr[]为原序列的信息从0开始，但在arr里是从1开始的
    private int[] sum;// sum[]模拟线段树维护区间和
    private int[] lazy;// lazy[]为累加懒惰标记
    private int[] change;// change[]为更新的值
    private boolean[] update;// update[]为更新慵懒标记

    public SegmentTree(int[] origin) {
        MAXN = origin.length + 1;
        arr = new int[MAXN];
        for (int i = 1; i < MAXN; i++) {
            arr[i] = origin[i - 1];
        }
        sum = new int[MAXN << 2];
        lazy = new int[MAXN << 2];
        change = new int[MAXN << 2];
        update = new boolean[MAXN << 2];
    }

    /**
     * 线段树初始化，填写 sum数组
     * 在 arr[l~r] 范围上 build
     * rt : 这个范围在 sum 中的下标
     *
     * @param l
     * @param r
     * @param rt
     */
    private void build(int l, int r, int rt) {
        if (l == r) {// 长度为1的线段，即元线段
            sum[rt] = arr[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);// 利用位运算加速
        build(mid + 1, r, rt << 1 | 1);
        pushUp(rt);
    }

    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    }

    /**
     * 懒增加和懒更新，从父范围，分发给左右子范围
     * 分发策略：
     * 1.检查父范围是否有懒更新操作
     * 2.检查父范围是否有懒增加操作（如果有，说明是在更新后新增的，所以才存在）
     *
     * @param rt 当前需要下发的范围结点
     * @param ln 当前需要下发的范围结点的左结点需要更新的结点个数
     * @param rn 当前需要下发的范围结点的右结点需要更新的结点个数
     */
    private void pushDown(int rt, int ln, int rn) {
        if (update[rt]) {
            update[rt << 1] = true;
            update[rt << 1 | 1] = true;
            change[rt << 1] = change[rt];
            change[rt << 1 | 1] = change[rt];
            lazy[rt << 1] = 0;
            lazy[rt << 1 | 1] = 0;
            sum[rt << 1] = change[rt] * ln;
            sum[rt << 1 | 1] = change[rt] * rn;
            update[rt] = false;
        }
        if (lazy[rt] != 0) {
            lazy[rt << 1] += lazy[rt];
            sum[rt << 1] += lazy[rt] * ln;
            lazy[rt << 1 | 1] += lazy[rt];
            sum[rt << 1 | 1] += lazy[rt] * rn;
            lazy[rt] = 0;// 已经下发了，清零
        }
    }

    /**
     * [L……R] 任务范围
     * [l……r] 当前节点范围
     * rt 当前节点
     */
    public void add(int L, int R, int C, int l, int r, int rt) {
        // 任务范围被覆盖，直接 懒住
        if (L <= l && R >= r) {
            sum[rt] += (r - l + 1) * C;// sum[rt]累加
            lazy[rt] += C;// lazy[rt] 累加
            return;
        }
        // 任务并没有被全包，需要下发任务
        int mid = (l + r) >> 1;
        // 下发之前攒的所有 懒任务
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {// 左孩子是否需要接收任务
            add(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {// 右孩子是否需要接受任务
            add(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        // 左右孩子完成任务后，更新自己的sum信息
        pushUp(rt);
    }

    public void update(int L, int R, int C, int l, int r, int rt) {
        // 被包住
        if (L <= l && R >= r) {
            update[rt] = true;
            change[rt] = C;
            sum[rt] = C * (r - l + 1);
            lazy[rt] = 0;
            return;
        }
        // 当前任务躲不掉了
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            update(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {
            update(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        pushUp(rt);
    }

    public long query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) {
            return sum[rt];
        }
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        long ans = 0;// long型，防止越界
        if (L <= mid) {
            ans += query(L, R, l, mid, rt << 1);
        }
        if (R > mid) {
            ans += query(L, R, mid + 1, r, rt << 1 | 1);
        }
        return ans;
    }


    public static class Right {
        public int[] arr;

        public Right(int[] origin) {
            arr = new int[origin.length + 1];
            for (int i = 0; i < origin.length; i++) {
                arr[i + 1] = origin[i];
            }
        }

        public void update(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] = C;
            }
        }

        public void add(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] += C;
            }
        }

        public long query(int L, int R) {
            long ans = 0;
            for (int i = L; i <= R; i++) {
                ans += arr[i];
            }
            return ans;
        }

    }

    public static int[] genarateRandomArray(int len, int max) {
        int size = (int) (Math.random() * len) + 1;
        int[] origin = new int[size];
        for (int i = 0; i < size; i++) {
            origin[i] = (int) (Math.random() * max) - (int) (Math.random() * max);
        }
        return origin;
    }

    public static boolean test() {
        int len = 100;
        int max = 1000;
        int testTimes = 5000;
        int addOrUpdateTimes = 1000;
        int queryTimes = 500;
        for (int i = 0; i < testTimes; i++) {
            int[] origin = genarateRandomArray(len, max);
            SegmentTree seg = new SegmentTree(origin);
            int S = 1;
            int N = origin.length;
            int root = 1;
            seg.build(S, N, root);
            Right rig = new Right(origin);
            for (int j = 0; j < addOrUpdateTimes; j++) {
                int num1 = (int) (Math.random() * N) + 1;
                int num2 = (int) (Math.random() * N) + 1;
                int L = Math.min(num1, num2);
                int R = Math.max(num1, num2);
                int C = (int) (Math.random() * max) - (int) (Math.random() * max);
                if (Math.random() < 0.5) {
                    seg.add(L, R, C, S, N, root);
                    rig.add(L, R, C);
                } else {
                    seg.update(L, R, C, S, N, root);
                    rig.update(L, R, C);
                }
            }
            for (int k = 0; k < queryTimes; k++) {
                int num1 = (int) (Math.random() * N) + 1;
                int num2 = (int) (Math.random() * N) + 1;
                int L = Math.min(num1, num2);
                int R = Math.max(num1, num2);
                long ans1 = seg.query(L, R, S, N, root);
                long ans2 = rig.query(L, R);
                if (ans1 != ans2) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int[] origin = {2, 1, 1, 2, 3, 4, 5};
        SegmentTree seg = new SegmentTree(origin);
        int S = 1; // 整个区间的开始位置，规定从1开始，不从0开始 -> 固定
        int N = origin.length; // 整个区间的结束位置，规定能到N，不是N-1 -> 固定
        int root = 1; // 整棵树的头节点位置，规定是1，不是0 -> 固定
        int L = 2; // 操作区间的开始位置 -> 可变
        int R = 5; // 操作区间的结束位置 -> 可变
        int C = 4; // 要加的数字或者要更新的数字 -> 可变
        // 区间生成，必须在[S,N]整个范围上build
        seg.build(S, N, root);
        // 区间修改，可以改变L、R和C的值，其他值不可改变
        seg.add(L, R, C, S, N, root);
        // 区间更新，可以改变L、R和C的值，其他值不可改变
        seg.update(L, R, C, S, N, root);
        // 区间查询，可以改变L和R的值，其他值不可改变
        long sum = seg.query(L, R, S, N, root);
        System.out.println(sum);

        System.out.println("对数器测试开始...");
        System.out.println("测试结果 : " + (test() ? "通过" : "未通过"));

    }
}
```



## 堆