# 总结

# 学习笔记

## 树

#### 树的高度和深度

高度和深度是相反的表示，深度是从上到下数的，而高度是从下往上数

**高度：**指从该节点到叶子节点的最长简单路径边的条数
**深度：**指从根节点到该节点的最长简单路径边的条数

**注意：**

- 这里边的条数是规定根节点的深度和叶子节点的高度是0

- 树的深度和高度是相等的，而对其他节点来说深度和高度不一定相等

**实例**

![123](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101647565.jpg)

如 B和C节点深度都为1，因为从根节点到到该节点的边数为1，B的高度为2，而C的高度为1。

当然树的深度是3高度也是3。树的高度和深度是相等的。

#### 树的其他定义

兄弟节点：具有相同父节点的节点互称为兄弟节点；



## 树形dp解题套路

> ZS语录：Morris遍历可以解决的问题，递归套路一定能解；不是什么题目都能用Morris遍历；

**套路：**

```
设 x 为 头结点（可能是任意子树的头结点，包括根结点），思路：
1. 设定：结点 x 可以从左右子树获得信息
2. 思考列出得到答案的可能性
3. 列出所有可能性
4. 根据列出的可能性，确定需要从左右子树分别获得什么信息
5. 根据需要的所有信息，设定（全集）信息体
6. 写递归
```

##### 题目一：二叉树结点间的最大距离问题

- 列出所有可能性
  1. 与 结点 x 有关时的最大距离: 左树高度+右树高度+ 1 (结点 X)
     - 结点 x 的左子树中距离 x 最远的结点，经过 结点 x 到达 结点 x 的右子树距离 x 最远的结点
  2. 与 结点 x 无关，最大距离不经过 x:  即为左子树或右子树的最大距离

- 根据列出的可能性，确定需要从左右子树获得的信息：左右子树的最大距离、高度
- 设计递归：
  1. 定义 Info
  2. 设定递归函数的返回值为 Info
  3. 空树 return null
  4. 获得左右子树 Info
  5. 加工获得 当前结点的 Info，并返回（注意：判空）

##### 代码实现

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

// 信息体
private static class Info {
    public int maxDistance;
    public int height;

    public Info(int maxDistance, int height) {
        this.maxDistance = maxDistance;
        this.height = height;
    }
}

private static Info process(Node x) {
    if (x == null) {
        return null;
    }
    Info left = process(x.left);
    Info right = process(x.right);

    int maxDistance = 0;
    int height = 0;
    if (left != null) {
        maxDistance = left.maxDistance;
        height = left.height;
    }
    if (right != null) {
        maxDistance = Math.max(maxDistance, right.maxDistance);
        height = Math.max(height, right.height) + 1;
    }
    maxDistance = Math.max(maxDistance,
            (left == null ? 0 : left.height) + (right == null ? 0 : right.height) + 1);
    return new Info(maxDistance, height);
}

public static int maxDistance(Node x) {
    return process(x).maxDistance;
}
```

##### 题目二：最大二叉搜索子树的大小

套用树形dp套路：

1. 列出所有可能性
   - 与 x 结点 无关
     - 左子树最大二叉搜索子树的大小
     - 右子树最大二叉搜索子树的大小
   - 与 x 结点 有关
     - 左树必须是 BST
     - 右树必须是 BST
     - 左子树最大值小于 x，右子树最小值大于 x
2. 根据列出的可能性，确定需要从左右子树获得的信息：
3. 设计递归
   1. 定义信息 Info
   2. 设定递归函数返回值为 Info
   3. 空树返回null
   4. 获得左右子树信息
   5. 加工获得当前结点Info（注意判空）并返回



#### 树形dp递归套路与非递归dp的比较

- 树形结构利用递归实现了dp，与dp相同的是都是用空间换时间，但在某些情况下，使用递归dp比非递归dp还要省空间：

  - 例：求二叉树结点间的最大距离问题，树形递归dp的空间复杂度为O(h)，非递归dp空间复杂度为O(N)

  - 树形递归dp的空间复杂度为O(h)，如图

    <img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112112007136.png" alt="image-20211211200728561" style="zoom:25%;" />

- 树形dp递归套路在递归过程中维持了dp的信息，利用的是dp的思想，只是实现方式是递归

  - 不是所有的递归都是dp，对于有空间换时间的递归才是dp，没有空间换时间（比如N皇后问题）就是暴力



#### 什么题目可以用Morris得到最优解，什么题目必须用 递归套路

- 必须同时获得左右子树的信息的题只能用递归套路
- 不要求第三次回到目标结点（不需要同时拿到左右子树信息），Morris是最优解
  - 例：必须判断是否BST，只要中序遍历之前的结点都小于当前结点



## 二叉树

树 是一种经常用到的数据结构，用来模拟具有树状结构性质的数据集合。

树里的每一个节点有一个值和一个包含所有子节点的列表。从图的观点来看，树也可视为一个拥有N 个节点和N-1 条边的一个有向无环图。

二叉树是一种更为典型的树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。

### 二叉树的高度和深度的区别

高度和深度是相反的表示，深度是从上到下数的，而高度是从下往上数

**高度：**指从该节点到叶子节点的最长简单路径边的条数
**深度：**指从根节点到该节点的最长简单路径边的条数

**注意：**

- 这里边的条数是规定根节点的深度和叶子节点的高度是0

- 树的深度和高度是相等的，而对其他节点来说深度和高度不一定相等

**实例**

![123](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101647565.jpg)

如 B和C节点深度都为1，因为从根节点到到该节点的边数为1，B的高度为2，而C的高度为1。

当然树的深度是3高度也是3。树的高度和深度是相等的。



### 二叉树的遍历

**二叉树的遍历方法：**

- 递归方法解决树的前序遍历、中序遍历和后序遍历问题
- 迭代方法解决树的为前序遍历、中序遍历和后序遍历问题
- 广度优先搜索解决树的层序遍历问题

#### 前序遍历

前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树

#### 中序遍历

中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树

通常来说，对于[二叉搜索树](https://leetcode-cn.com/leetbook/detail/introduction-to-data-structure-binary-search-tree/)，我们可以通过中序遍历得到一个递增的有序序列

#### 后序遍历

后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点

- 值得注意的是，当你删除树中的节点时，删除过程将按照后序遍历的顺序进行。 也就是说，当你删除一个节点时，你将首先删除它的左节点和它的右边的节点，然后再删除节点本身
- 后序在数学表达中被广泛使用，编写程序来解析后缀表示法更为容易
- 如果你想对这棵树进行后序遍历，使用栈来处理表达式会变得更加容易。 每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中

**递归：调用递归栈，时间复杂度O(N),空间复杂度O(h)**

**迭代：时间复杂度O(N),空间复杂度O(h)**

#### Morris遍历

**Morris遍历**：**时间复杂度O(N),空间复杂度O(1)**：笔试别装逼，写递归、迭代，简单能AC就好，面试可以喝面试官聊下Morris（和KMP中的M是同一个人）

![image-20211105092457427](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111050924090.png)

| 题目                                                         | 是否一次过 | 待解决问题       |
| ------------------------------------------------------------ | ---------- | ---------------- |
| [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 否         | Morris遍历       |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 否         | Morris遍历       |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 否         | 迭代、Morris遍历 |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | 是         |                  |

先序遍历：压栈顺序：中左右

后序遍历：压栈顺序：中右左  -> 逆序打印就是后序遍历

中序遍历：阶段一：子树整条左边界依次进栈，如没有进入阶段二

​					阶段二：栈中弹出节点cur，并打印，cur的右子树重复阶段一



### 二叉树的序列化与反序列化

二叉树的序列号与反序列化可以用先序、后序、层次遍历实现，但是中序遍历只能序列化，无法反序列化（因为先序后序方式知道头节点位置，中序方式不知道）

![image-20211212103831264](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112121038520.png)



### 二叉树 - Morris遍历

> 左神视频直通车：https://www.bilibili.com/video/BV1tX4y1G715?p=5

#### Morris遍历介绍

morris 序在模拟递归遍历的递归序，对于递归序，由于利用了系统栈，对于每个结点一定能来到自己三次，而对于morris序，对于没有左树的结点，只能来到自己一次，对于有左树的结点能来到自己两次

**Morris遍历应用场景：**

给定⼀棵⼆叉树的头节点head，完成⼆叉树的先序、中序和后序遍历。如果⼆叉树的节点数为N ，要求时间复杂度为O (N )，额外空 间复杂度为O (1)

**解答：**

1. 递归与迭代遍历二叉树的空间复杂度都是O(h)

   这是因为遍历⼆叉树的递归⽅法实际使⽤了函数 栈，非递归的⽅法使⽤了申请的栈，两者的额外空间都与树的⾼度相 关，所以空间复杂度为O (h )，h 为⼆叉树的⾼度

2. 如何完全不⽤栈结构能完成三种遍历：使⽤⼆叉树节点中⼤量指向 null的指针。就是⼤名⿍⿍的Morris遍历

**Morris遍历实质**

Morris遍历的实质就是避免⽤栈结构，⽽是让下层到上层有指针，具体是通过让底层节点指向null的空闲指针指回上层的某个节 点，从⽽完成下层到上层的移动。我们知道，⼆叉树上的很多节点都 有⼤量的空闲指针，⽐如，某些节点没有右孩⼦，那么这个节点的 right指针就指向null，我们称为空闲状态，Morris遍历正是利⽤了这 些空闲指针

#### Morris序

Morris序遍历规则：

1. cur 无左树，cur = cur.right
2. cur 有左树，找到左树的最右节点 mostRight
   1. mostRight 的右指针指向 null 的，mostRight.right = cur，cur = cur.left
   2. mostRight 的右指针指向cur的，mostRight.right = null，cur = cur.right

```java
// morris遍历规则：
// 1）cur无左树，cur = cur.right
// 2) cur有左树，找到左树最右节点，mostRight
//   ① mostRight的右指针指向null的，mostRight.right = cur ,cur= cur.left
//   ② mostRight的右指针指向cur，mostRight.right = null,cur = cur.right
public void morris(TreeNode head) {
    if (head == null) {
        return;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        // cur有左树
        if (mostRight != null) {
            // 找到左树真实的最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 第一次来到cur的左子树的最右节点，将mostRight.right = cur,cur = cur.left
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
                // 第二次来到cur的左子树的最右节点，此时mostRight.right = cur,将mostRight.rigth = null
            } else {
                mostRight.right = null;
            }
        }
        // cur没有左子树或者第二次来到cur的左子树的最右节点，使cur = cur.right
        cur = cur.right;
    }
}
```

#### 时间复杂度

时间复杂度：O(N)

证明：

1. cur来到所有节点的次数是N
2. 所有节点遍历所有节点的左树的右边界的代价是 2
3. 所以总代价是O(N)

![image-20211105165613857](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111051656030.png)

#### Morris前序、中序、后序遍历

第一次来到一个节点时候打印：先序，第二次来到一个节点的时候打印：中序；只有一次到达的节点：遇到它就打印

#### 先序遍历

第一次来到节点时打印，第二次来到节点时不打印，只有一次到达的节点，直接打印（它没有左子树）

![image-20211105170856416](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111051708389.png)

```java
// 先序遍历，如果一个节点能到达自己两次（即有左子树），第一次到达时打印
public void morrisPre(TreeNode head) {
    if (head == null) {
        return;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        // 如果 cur 有左子树
        if (mostRight != null) {
            // 找到cur左子树的真实最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 第一次到达cur左子树的最右节点
            if (mostRight.right == null) {
                // cur 有左子树，第一次到达时打印
                System.out.println(cur.val);
                mostRight.right = cur;
                cur = cur.left;
                ;
                continue;
            } else {
                // 第二次到达cur左子树的最右节点，恢复指针
                mostRight.right = null;
            }
        } else {
            // cur没有左子树，直接打印
            System.out.println(cur.val);
        }
        // cur 没有左子树或者 cur第二次到达cur
        cur = cur.right;
    }
}
```



#### 中序遍历

对于能到达自己两次的节点（也就是有左树的节点），第二次到达时打印，只有一次到达的节点，直接打印就是中序遍历

![image-20211105171141270](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111051711262.png)

```java
// 中序遍历，如果一个节点能到达自己两次（即有左子树），第二次到达时打印
public void morrisIn(TreeNode head) {
    if (head == null) {
        return;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        // cur 有左树
        if (mostRight != null) {
            // 找到cur左树真实的最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 第一次来到cur的左子树的最右节点，将mostRight.right = cur,cur = cur.left
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                // 第二次来到cur的左子树的最右节点，此时mostRight.right = cur,将mostRight.rigth = null
                mostRight.right = null;
            }
        }
        // cur没有左子树或者第二次来到cur的左子树的最右节点，使cur = cur.right

        // cur没有左子树或者第二次来到cur，打印
        System.out.println(cur.val);
        cur = cur.right;
    }
}
```

#### 后序遍历

**打印时机：**

- 能回到自己两次，且第二次回到自己的时候
  - 不是打印cur，**逆序**打印cur的左树的右边界
  - 所有过程完成后单独**逆序**打印整棵树的右边界

![image-20211105174713028](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111051747066.png)

```java
// 后序遍历：如果一个节点能到达自己两次，第二次到达时逆序打印其左子树的右边界，整个树打印完后，单独逆序打印整棵树的右边界
public void morrisPost(TreeNode head) {
    if (head == null) {
        return;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        // 如果 cur 有左子树
        if (mostRight != null) {
            // 找到cur左子树的真实最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 第一次到达cur左子树的最右节点
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                // 第二次到达cur左子树的最右节点，恢复指针
                mostRight.right = null;
                // 第二次到达cur，逆序打印其左子树的右边界
                printEdge(cur.left);
            }
        }
        // cur 没有左子树或者 cur第二次到达cur
        cur = cur.right;
    }
    // 整个过程完成后逆序打印整棵树的右边界
    printEdge(head);
}

private void printEdge(TreeNode head){
    head = reverseTree(head);
    TreeNode node = head;
    while (node!=null){
        System.out.println(node.val);
        node = node.right;
    }
    reverseTree(head);
}

// 反转右子树-双指针
private TreeNode reverseTree(TreeNode head) {
    if (head.right == null) {
        return head;
    }
    // 反转右边界
    TreeNode cur = head, prev = null;
    while (cur != null) {
        TreeNode next = cur.right;
        cur.right = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}

// 反转右子树-递归
private TreeNode reverseTree(TreeNode head) {
    if (head == null || head.right == null) {
        return head;
    }
    TreeNode node = reverseTree(head.right);
    head.right.right = head;
    head.right = null;
    return node;
}
```

#### Morris遍历拓展

#### 判断搜索二叉树

搜索二叉树定义：每个节点中的值必须大于（或等于）其左侧子树中的任何值，但小于（或等于）其右侧子树中的任何值。（即其中序遍历时递增序列）

```java
public boolean morrisIsBinarySearch(TreeNode head) {
    if (head == null) {
        return true;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    Integer pre = null;
    while (cur != null) {
        mostRight = cur.left;
        // cur有左树
        if (mostRight != null) {
            // 找到左树真实的最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            // 第一次来到cur的左子树的最右节点，将mostRight.right = cur,cur = cur.left
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
                // 第二次来到cur的左子树的最右节点，此时mostRight.right = cur,将mostRight.rigth = null
            } else {
                mostRight.right = null;
            }
        }
        // 中序遍历前一个节点值大于当前节点值，返回false
        if (pre != null && pre > cur.val) {
            return false;
        }
        pre = cur.val;
        // cur没有左子树或者第二次来到cur的左子树的最右节点，使cur = cur.right
        cur = cur.right;
    }
    return true;
}
```

#### 返回二叉树叶节点的最小高度

**关键问题：**

1. 如何指定cur节点此时的高度
2. 如果cur是叶节点，更新高度最小值

**情况分析：**

1. 如果cur无左树（即只有一次到达自己）,level++ 
2. 如果cur 有左树，区分cur是第一次来到自己还是第二次来到自己
   1. 如果第一次来到自己，level++，即获得cur的高度
   2. 如果是第二次来到自己
      1. 判断左子树的最右节点是不是叶子节点，是则更新最小高度
      2. cur的高度等于当前高度减去左子树右边界长度： level -=rightEdgeSize
3. 整颗树遍历完成后，判断一下树的右边界的最右节点是不是叶子节点，是的话更新一下最小高度

![image-20211105215752871](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111052157276.png)

```java
public int morrisMinHeight(TreeNode head) {
    if (head == null) {
        return 0;
    }
    TreeNode cur = head;
    TreeNode mostRight = null;
    Integer minHeight = Integer.MAX_VALUE, curLevel = 0;
    while (cur != null) {
        mostRight = cur.left;
        // cur有左树
        if (mostRight != null) {
            int rightEdgeSize = 1;// 左子树右边界长度
            // 找到左树真实的最右节点
            while (mostRight.right != null && mostRight.right != cur) {
                rightEdgeSize++; // 统计左子树右边界长度
                mostRight = mostRight.right;
            }
            // 第一次来到cur的左子树的最右节点，将mostRight.right = cur,cur = cur.left
            if (mostRight.right == null) {
                curLevel++; // 第一次回到cur，curLevel++ 获得cur的高度
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {    // 第二次来到cur的左子树的最右节点，此时mostRight.right = cur,将mostRight.rigth = null
                if (mostRight.left == null) {   // 左子树最右节点是叶子节点，更新最小高度
                    minHeight = Math.min(minHeight, curLevel);
                }
                curLevel -= rightEdgeSize; // 左子树最右节点高度减去左子树右边界长度即为cur节点高度
                mostRight.right = null;
            }
        } else {
            // cur 没有左子树，curLevel++ 获得当前高度
            curLevel++;
        }
        // cur没有左子树或者第二次来到cur的左子树的最右节点，使cur = cur.right
        cur = cur.right;
    }
    // 整棵树遍历完后判断树的右边界最右节点是否叶子节点，更新最小高度
    cur = head;
    curLevel = 1;
    // 找到最右节点
    while (cur.right != null) {
        cur = cur.right;
        curLevel++;
    }
    // 是叶子节点则更新最小高度
    if (cur.left == null) {
        minHeight = Math.min(minHeight, curLevel);
    }
    return minHeight;
}
```

#### 总结

Morris遍历适用情况：

当既需要当前节点的左子树提供信息，又需要当前节点的右子树提供信息，做整合，则没有办法使用Morris遍历(因为既需要左子树提供信息又需要右子树提供信息)，空间一定不是O(1)

如果求解流程不是递归的不需要左右子树同时提供信息，则可以用Morris遍历

也就是说对于需要收集完全信息才能解决的题目就不能用Morris遍历

对于可以往下推理的，不需要保留之前信息的题目，可以用Morris遍历



#### 算法常数复杂度

对于一个给定范围的数据，比如是 10 0000 的，遇到要用哈希表的题目，一定要用数组结构替代哈希表，（虽然哈希表增删改查是O(1),但其实它的常数项是很大的）因为哈希表调用离散函数，这个离散化函数的常数项是很高的，没有自己用数组代替哈希表速度快 

## 二叉搜索树

**性质：**每个节点中的值必须大于其左侧子树中的任何值，但小于其右侧子树中的任何值。也就是中序遍历是**单调递增序列**



在二叉搜索树中搜索特定的值，根据BST的特性，对于每个节点：

1. 如果目标值等于节点的值，则返回节点
2. 如果目标值小于节点的值，则继续在左子树中搜索
3. 如果目标值大于节点的值，则继续在右子树中搜索

二叉搜索树插入节点：

1. 根据节点值与目标节点值的关系，搜索左子树或右子树
2. 重复步骤 1 直到到达外部节点
3. 根据节点的值与目标节点的值的关系，将新节点添加为其左侧或右侧的子节点

二叉搜索树删除节点：

1. 如果目标节点没有子节点，我们可以直接移除该目标节点
2. 如果目标节只有一个子节点，我们可以用其子节点作为替换
3. 如果目标节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点

### 小结

二叉搜索树的有优点是，即便在最坏的情况下，也允许你在O(h)的时间复杂度内执行所有的搜索、插入、删除操作。

通常来说，如果你想有序地存储数据或者需要同时执行搜索、插入、删除等多步操作，二叉搜索树这个数据结构是一个很好的选择。

使用场景：求数据流第K大的数：在BST每个节点中放置一个计数器，以计算以此节点为根的子树中有多少个节点

### 拓展

**二叉搜索树中操作的复杂性，是根据树的高度而变化**



### 高度平衡的二叉搜索树

**树结构中的常见用语:**

- 节点的深度 - 从树的根节点到该节点的边数
- 节点的高度 - 该节点和叶子之间最长路径上的边数
- 树的高度 - 其根节点的高度

**高度平衡的二叉搜索树定义：**

一个高度平衡的二叉搜索树（平衡二叉搜索树）是在插入和删除任何节点之后可以自动保持其高度最小。也就是说，有N个节点的平衡二叉搜索树，它的高度是logN，并且，每个节点的两个子树的高度不会相差超过1。

> 为什么是 `logN` 呢?
>
> - 一个高度为 `h` 的二叉树 
>   <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/25/height_balanced_bst_equation_1.png" alt="img" style="zoom:33%;" />.
> - 换言之，一个有 `N` 个节点，且高度为 `h` 的二叉树
>   ![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101645230.png)
> - 所以： 
>   <img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/01/26/height_balanced_bst_equation_3.png" alt="img" style="zoom:33%;" />.

### 为什么需要用到高度平衡的二叉搜索树?

- 以搜索操作为例，如果二叉搜索树的高度为 h ，则时间复杂度为 O(h) 
- 对于一个节点总数N，高度为h的平衡二叉树，![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101646092.png)
- 但对于一个普通的二叉搜索树，在最坏的情况下，它可以退化成一个链
- 因此，具有 N 个节点的二叉搜索树的高度在 logN 到 N 区间变化。也就是说，搜索操作的时间复杂度可以从 logN 变化到 N 。这是一个巨大的性能差异。
- 所以说，高度平衡的二叉搜索树对提高性能起着重要作用

### 如何实现一个高度平衡的二叉搜索树?

1. 采用的数据结构应该满足二分查找属性和高度平衡属性

2. 采用的数据结构应该支持二叉搜索树的基本操作，包括在 **O(logN)** 时间内的搜索、插入和删除，即使在最坏的情况下也是如此

**常见的的高度平衡二叉树列表：**

- [红黑树](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin)
- [AVL树](https://baike.baidu.com/item/AVL树/10986648?fr=aladdin)
- [伸展树](https://baike.baidu.com/item/伸展树/7003945?fromtitle=Splay+Tree&fromid=6987714&fr=aladdin)
- [树堆](https://baike.baidu.com/item/Treap/4321536?fr=aladdin)

### 高度平衡的二叉搜索树的实际应用

平衡二叉搜索树的概念经常运用在 Set 和 Map 中，Set 和 Map 的原理相似

> Set（集合）是另一种数据结构，它可以存储大量 key（键）而不需要任何特定的顺序或任何重复的元素。 它应该支持的基本操作是将新元素插入到 Set 中，并检查元素是否存在于其中。

通常，有两种最广泛使用的集合：散列集合（Hash Set）和 树集合（Tree Set）

- 树集合，Java 中的 Treeset 或者 C++ 中的 set ，是由高度平衡的二叉搜索树实现的。因此，搜索、插入和删除的时间复杂度都是 O(logN) 。


- 散列集合，Java 中的 HashSet 或者 C++ 中的 unordered_set ，是由哈希实现的，但是平衡二叉搜索树也起到了至关重要的作用。当存在具有相同哈希键的元素过多时，将花费 O(N) 时间复杂度来查找特定元素，其中N是具有相同哈希键的元素的数量。 通常情况下，使用高度平衡的二叉搜索树将把时间复杂度从 O(N) 改善到 O(logN) 。


**哈希集和树集之间的本质区别在于树集中的键是有序的**

**总结:**高度平衡的二叉搜索树是二叉搜索树的特殊表示形式，旨在提高二叉搜索树的性能

## B 树

**B树**（英语：B-tree）是一种自平衡的[树](https://zh.wikipedia.org/wiki/树_(数据结构))，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在[对数时间](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)内完成。B树，概括来说是一个一般化的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)（binary search tree）一个节点可以拥有2个以上的子节点。与[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在[数据库](https://zh.wikipedia.org/wiki/数据库)和[文件系统](https://zh.wikipedia.org/wiki/文件系统)的实现上。



B树，是为磁盘存储而专门设计的一类**平衡搜索树**。由于磁盘操作比随机存储取存器慢得多，因此衡量B树的性能，不仅要考虑动态集合操作消耗了多少计算时间，而且还要考虑这些操作执行了多少次磁盘存取。对每个B树操作，磁盘存取的次数随着B树的高度而增加。

B树与红黑树的不同之处在于B树的结点可以有很多孩子，也就是说一个B树的“分支因子”可以相当大

### 定义

B树也称多路平衡查找树，是一种组织和维护外存文件系统的非常有效的数据结构。



一个 *m* 阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 *k* − 1 个键
5. 所有的叶子节点都在同一层。B树是所有结点的平衡因子均等于0的多路查找树。

- 在计算B树的高度时，需要计入最底层的外部结点

### 操作

#### 搜索

B树的搜索和二叉搜索树类似，从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

#### 插入

将关键字K插入B树的过程分两步完成：

1. 查找该关键字的插入节点（B树的插入节点一定是叶子节点层的节点）

2. 插入关键字

   1. 如果插入节点有空位置，即关键字个数 n<m-1:直接把关键字k有序插入到该节点的合适位置上

   2. 插入节点没有空位置，即原插入节点关键字个数 n = m-1 =》分裂

      - 分裂过程：

        - 如果没有双亲节点，新建一个双亲节点，树的高度增加一层
        - 如果有双亲节点，将k插入到双亲节点中

        ![image-20211202215511715](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022155437.png)

**插入实例：**

![image-20211202215759546](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022158935.png)



![image-20211202215911844](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022159842.png)

![image-20211202220039714](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022200528.png)



![image-20211202220214743](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022202444.png)



![image-20211202220245063](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204816.png)



![image-20211202220325109](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204557.png)



![image-20211202220404989](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204896.png)



**思考题：**

1. 在B树中每插入一个关键字，都要新建一个节点吗？
   1. 不一定，如果找到的叶子节点的关键字的个数小于 m-1，就可以直接有序插入
2. 在B树中插入一个关键字，若引起分裂，树高一定会升高一层吗
   1. 不一定，如果父节点的关键字的个数小于 m-1，就不会升高
   2. 如果没有父节点，就需要升高
   3. 如果父节点的关键字的个数超过了 m-1，就需要升高

#### 删除

在B树上删除关键字K的过程分两步完成：

1. 查找关键字K所在的节点
2. 删除关键字K

删除关键字K分两种情况：

- 在叶子节点层删除关键字K
- 在非叶子节点层删除关键字K

**注意：**非根、非叶子节点的关键字个数最少为 (m/2)-1



##### 删除叶子节点中的元素

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

##### 删除内部节点中的元素

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

##### 删除后的重新平衡

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点

**删除实例**

![image-20211202222451739](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227992.png)



![image-20211202222513166](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227159.png)



![image-20211202222528308](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227454.png)



![image-20211202222553712](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227728.png)



![image-20211202222617747](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227715.png)

![image-20211202222731909](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227569.png)



**思考题：**

1. 在B树中每删除一个关键字，都要删除一个节点吗?
   1. 不一定，删除后如果节点个数仍大于等于最小个数就不需要删除
2. 在B树中删除一个关键字若引起合并，树高度一定会降低吗？
   1. 不一定

#### 为什么要使用B树？

**Disk Structure**

块的定义：轨道和扇区的相交位置；块可以通过轨道号和扇区号对磁盘进行寻址

块地址的形式（轨道号，扇区号）

块大小通常为 512字节，以达到稳定的目的

在块中每个字节可以有自己的地址，成为偏移量，因此读取磁盘上特定点的文件需要轨道号、扇区号、偏移量

**数据库表在硬盘中的组织存储形式**

假设现在有一个张 员工信息表 ，这张表有5个字段，共占用128个字节，每个块可以存储4条数据，那么存储100条数据就需要25个块



设想一下，如果我们现在需要获取某条记录，那么我们必须访问所有的25个块，以查找我们需要的数据，因为我们不知道数据存储在什么位置



那么如何可以减少我们的访问时间？

答案是索引，索引将存储表中对应记录的key和指向记录的指针



索引也存储在硬盘中



**多级指数**

在拥有更多条记录比如上千条记录时，索引的规模也就更大了，那么访问索引也将需要更多的时间，那么如何解决这个问题呢？

为索引表添加索引（稀疏索引），这就是B和B+ 树的基本思想。



## B+ 树

**B+ 树**是一种[树数据结构](https://zh.wikipedia.org/wiki/树_(数据结构))，通常用于[数据库](https://zh.wikipedia.org/wiki/数据库)和[操作系统](https://zh.wikipedia.org/wiki/操作系统)的[文件系统](https://zh.wikipedia.org/wiki/文件系统)中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素**自底向上插入**，这与[二叉树](https://zh.wikipedia.org/wiki/二叉树)恰好相反。

### 定义

![image-20211202222932829](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022229854.png)

一颗m阶B+树需要满足下列要求：

1. 每个分支节点至多有m颗子树（这里m=4）
2. 根节点或者没有子树，或者至少有两颗子树
3. 除根节点外，其他每个分支节点至少有 m/2 颗子树
4. 有 n 颗子树的节点恰好有n个关键字
5. 所有的叶子节点包含了全部关键字及指向相应记录的指针，而且叶子节点按照关键字大小顺序链接。并且将所有叶子节点链接起来。
6. 所有分支节点（可以看成时索引的索引）中仅包含它的各个子节点（即下级索引的索引块）中最大关键字及指向子节点的指针。



## 2-3-4树

### 定义 

2-3-4树是四阶的 B树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制： 

- 所有叶子节点都拥有相同的深度。 
- 节点只能是 2-节点、3-节点、4-节点之一。
  - 2-节点：包含 1 个元素的节点，有 2 个子节点； 
  - 3-节点：包含 2 个元素的节点，有 3 个子节点；
  - 4-节点：包含 3 个元素的节点，有 4 个子节点； 
  - 所有节点必须至少包含1个元素
- 2-3-4 树的生长（分裂）是**自底向上**生长的
- 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点； 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。
- 2-3-4树是一颗完全数
- 下图是一个典型的 2-3-4树（来自维基百科）：

![2-3-4_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022252449.png)



2-3-4 树在多数编程语言中实现起来相对困难，因为在树上的操作涉及大量特殊情况。[红黑树](https://zh.wikipedia.org/wiki/红黑树)实现起来更简单一些，所以可以用它来替代。

一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树

## 红黑树

**红黑树**（英语：Red–black tree）是一种[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)，是在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中用到的一种[数据结构](https://zh.wikipedia.org/wiki/数据结构)，典型用途是实现[关联数组](https://zh.wikipedia.org/wiki/关联数组)。

红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/算法分析)，并且在实践中高效：它可以在$[{\displaystyle {\text{O}}(\log n)}]$时间内完成查找、插入和删除，这里的${\displaystyle n}$是树中元素的数目。

### 性质

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。（黑色平衡）

下面是一个具体的红黑树的图例：

![Red-black_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022255662.svg)



### 红黑树与 2-3-4树的关系

- 一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树
- 红黑树起源于2-3-4树，它的本质就是2-3-4树
- 红黑树的叶子节点及其父节点构成了2-3-4树的叶子节点

#### 2-3-4树与红黑树的等价关系

- 2 节点

  - 只有一种对应关系，只对应红黑树中的黑色节点

    ![image-20211202232427551](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022324203.png)

- 3节点

  - 有两种对应关系，但位于上层的节点一定要是黑色节点

    ![image-20211202232537390](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022325245.png)

- 4节点

  - 只有一种对应关系，处于中间位置的节点位于上层，（中间黑，两边红）

    ![image-20211202232646005](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022326105.png)

- 裂变状态

  - （中间红，两边黑，新加入的节点为红色，但如果是根节点，仍需转变为黑色）

    ![image-20211202233104555](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022331461.png)

#### 推理红黑树5大性质

1. **节点是红色或黑色**
   - 无需推理


2. **根是黑色**

   1. 第一种情况：2-3-4 树的根是2节点

      ![image-20211203081359030](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030814021.png)


   2. 第二种情况：2-3-4 树的根是3节点

      ![image-20211203081724578](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030817972.png)

   3. 第三种情况：2-3-4 树的根是4节点

      ![image-20211203081936381](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030819784.png)

4. **所有叶子节点都是黑色**（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）

所有叶子节点都是null，所以无需推理

4. **每个红色节点都必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）**

   根据2-3-4树和红黑树的等价关系，可知，每个红色节点都必须有两个黑色的子节点

5. **从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点**

- 已知2-3-4树的性质：所有叶子节点都拥有相同的深度，2-3-4 树转换为红黑树后，任何一个节点都包含一个黑色节点

  ![image-20211203083529809](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030835150.png)



### 红黑树的操作

#### 左旋和右旋

同二叉树

#### 新增操作

红黑树的新增都可以转换为2-3-4树的新增，2-3-4树的新增操作全部在叶子节点完成。

**创建头节点**

此时，不需要合并，新增的节点作为头节点，成为2节点，颜色由红色变成黑色。

![image-20211203101414301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031014724.png)

**新增一个节点与 2 节点合并**

新增节点与2节点合并，直接合并，变为3节点

有两种情况

![image-20211203102543660](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031358886.png)



**新增一个节点 与 3 节点合并**

新增节点与3节点合并，直接合并，变为4节点

分六种情况

![image-20211203103555957](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031035015.png)



新增一个节点与 4 节点合并，此时需要分裂

新增一个节点与 4 节点合并，此时需要分裂；原来的4节点由 上黑下红 变成 上红下黑（如果是根节点还要变回黑色）

分四种情况

![image-20211203104754388](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031047585.png)

#### 新增节点后的调整操作

 2-3-4树新增元素的四种情况：

 1. 新增根节点

    对应红黑树：调整根节点为黑色

 2. 新增一个节点与2节点合并，成为一个3节点
    对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整

 3. 新增一个节点与3节点合并，成为一个4节点
    分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
       对应红黑树：调整后上黑下红

        1. 左左左
           - 目标节点的爷爷节点右旋，目标节点的父亲节点染色为黑色，爷爷节点染色为红色
         2. 左左右
            - 对目标节点的父节点左旋，使之变为左左左的情况，同时指向目标节点的指针也应指向父节点
         3. 右右右
         4. 右右左
         5. 左中右
            - 无需调整
         6. 左中右
            - 无需调整

 4. 新增一个节点与4节点合并，此时需要裂变

    - 新增节点的插入位置有四种
    - 目标节点的爷爷节点不是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点变红
    - 目标节点的爷爷节点是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点不变（还是黑色）

#### 删除操作

- 红黑树的平衡是黑色平衡，只有删除的节点是黑色，才需要调整平衡
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作（当然，这个“叶子节点”可能会有左或右孩子）
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作，也就是2-3-4树的叶子节点

##### 寻找继任结点

如果被删除节点的右子树不为空，返回右子树的最小节点，否则返回第一个大于被删除节点的父类节点

##### 删除操作

1. 被删除的节点是叶子节点，则直接删除
2. 被删除的节点有一个子节点，用子节点来替代
3. 被删除的节点有两个子节点，找到被删除节点的后驱节点（也可以是前驱节点）来替代
   1. 后驱节点没有右子节点的情况
   2. 后驱节点有右子节点的情况清除链接，以便 fixAfterDeletion 可以使用它们

##### 删除后的调整

- 红黑树的删除操作最终都会转换为对 2-3-4树 的叶子节点的删除操作
- 2-3-4数 是一颗满树

对于 3节点和4节点，删除一个叶子节点元素后，仍然满足2-3-4树定义；

对于2节点，删除一个叶子节点元素后无法满足2-3-4树定义

![image-20211204100244379](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041012800.png)



对应 红黑树：

1. 对于 3节点和4节点，删除一个叶子节点元素后，可以通过自我调整满足红黑树定义
2. 对于2节点，删除一个叶子节点元素后，需要进行平衡性调整

##### 调整思路

![image-20211204103528763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041035015.png)

- ”自己搞不定“

  - 对于2节点的删除：需要调整平衡性，以被删除的节点是左孩子节点为例：

    - 如果被删除节点的父节点的右节点是红色，则这个右节点不是被删除节点的兄弟节点（证明它是2-3-4树中的父节点）

      ​	![image-20211204174339812](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041743436.png)

    - 对于被删除节点的父节点的右节点是红色的情况，将父节点左旋一次，根据2-3-4树性质，父节点的右节点必有左右孩子节点，所以左旋后右节点的左节点成为父节点的右节点（也就是真正的兄弟节点）；将父节点染红，父节点的原右节点染黑

      ![image-20211204174623434](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041746163.png)

    - 此时有两种情况：①兄弟节点有的借（是2节点 ）

      ​								②兄弟节点没的借（是3节点或4节点）

    - 对于兄弟节点有的借的情况：被删除节点找父亲节点借，父亲节点空缺用兄弟节点补上

      1. 如果兄弟节点是3节点，也分两种情况：

         - 第一种情况：兄弟节点左子树为空
         - 第二种情况：兄弟节点右子树为空

         对于第二种情况先转换成第一种情况，然后按照第一种情况统一处理

         ![image-20211204180205763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041802581.png)

         ![image-20211204180257855](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041803311.png)

      2. 如果兄弟节点是4节点：

         - 此时有两种处理办法：

           第一种办法：把父亲节点和兄弟节点的左孩子都借给被删除节点（需要旋转两次）

           第二种办法：只借父亲节点给被删除节点（需要旋转一次）

           ![image-20211204200655011](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112042006697.png)

    - 对于兄弟节点没得借的情况：

      - (有难同当)兄弟节点染红，递归处理

- ”自己能搞定“

  - 对于3节点的删除：可以自我调整的删除（比如删除 7.5，则无需调整；删除7，则会用 7.5 代替，即把 7.5 染黑）
  - 对于4节点的删除：不存在删除 4节点中 黑色节点的情况（其实对4节点的删除就是对3节点的删除，个人理解）

#### 代码实现

```java
package zs.order_list;


/**
 * @author miemiehoho
 * @date 2021/12/3 9:09
 */
public class RedBlackTree<K extends Comparable<K>, V> {


    public RedBlackNode<K, V> root;

    /**
     * 左旋
     *
     * @param node
     */
    private void rotateLeft(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.right;
            node.right = newNode.left;
            if (newNode.left != null) {
                newNode.left.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.left = node;
            node.parent = newNode;
        }
    }


    /**
     * 右旋
     *
     * @param node
     * @return
     */
    private void rotateRight(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.left;
            node.left = newNode.right;
            if (newNode.right != null) {
                newNode.right.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.right = node;
            node.parent = newNode;
        }
    }


    /**
     * 对外提供的新增节点操作
     *
     * @param key
     * @param value
     */
    public void put(K key, V value) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> t = root;
        if (t == null) {
            root = new RedBlackNode<>(key, value, null);
            return;
        }
        RedBlackNode<K, V> parent;
        int cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) {
                t = t.left;
            } else if (cmp > 0) {
                t = t.right;
            } else {
                t.setValue(value);
                return;
            }
        } while (t != null);

        RedBlackNode<K, V> newNode = new RedBlackNode<>(key, value, parent);
        if (cmp < 0) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }
        fixAfterInsertion(newNode);
    }

    public V remove(K key) {
        RedBlackNode<K, V> node = getNode(key);
        if (node == null) {
            return null;
        }
        V oldValue = node.value;
        deleteNode(node);
        return oldValue;
    }

    // 删除节点node，然后重新平衡树
    private void deleteNode(RedBlackNode<K, V> node) {
        if (node.left != null && node.right != null) {
            RedBlackNode<K, V> successor = preSuccessor(node);
            node.key = successor.key;
            node.value = successor.value;
            node = successor;// 指向新的被删除节点（后继结点）
        }

        // 我的理解：
        // 1. 对于有左右子节点的情况：这样写是为了拿到后继结点的右子节点
        // 2. 对于只有左子树或右子树的情况，可以兼容
        RedBlackNode<K, V> replacement = node.left != null ? node.left : node.right;

        if (replacement != null) {
            replacement.parent = node.parent;
            if (node.parent == null) {// 被删除节点只有左子树或右子树，且被删除节点是根节点
                root = replacement;
            } else if (node == node.parent.left) {// 被删除节点有左右子树或者只有左或右子树三种情况下，repalcement的归属
                node.parent.left = replacement;
            } else {
                node.parent.right = replacement;
            }
            // 释放链接-源码注释为：清除链接，以便 fixAfterDeletion 可以使用它们
            node.left = node.right = node.parent = null;
            // 从 replacement 节点开始进行平衡性调整
            if (node.color == BLACK) {
                //replacement节点一定是红色
                fixAfterDeletion(replacement);
            }
        } else if (node.parent == null) {// 删除的是根节点
            root = null;
        } else {// 被删除节点是叶子节点，没有孩子节点，使用自己代替自己，并删除
            if (node.color == BLACK) {
                fixAfterDeletion(node);
            }

            if (node.parent != null) {// 存疑
                if (node == node.parent.left) {
                    node.parent.left = null;
                } else {
                    node.parent.right = null;
                }
                node.parent = null;
            }
        }
    }


    /**
     * 从替代节点位置开始调整
     *
     * @param node
     */
    private void fixAfterDeletion(RedBlackNode<K, V> node) {
        while (node != root && colorOf(node) == BLACK) {// 被删除的是2节点
            if (node == leftOf(parentOf(node))) {// 被删除的是左节点

                RedBlackNode<K, V> right = rightOf(parentOf(node));// 兄弟节点
                if (colorOf(right) == RED) {// 如果兄弟节点是红色，说明它不是真正的兄弟节点，而是兄弟节点的父节点
                    // 把兄弟节点染黑，父节点染红，然后父节点左旋
                    setColor(right, BLACK);
                    setColor(parentOf(right), RED);
                    rotateLeft(parentOf(node));
                    right = rightOf(parentOf(node));// 指向真的兄弟节点
                }

                // 找兄弟借，兄弟没得借
                if (colorOf(leftOf(right)) == BLACK && colorOf(rightOf(right)) == BLACK) {
                    setColor(right, RED);
                    node = parentOf(node);// 递归处理
                } else {// 找兄弟借，兄弟有的借
                    // 两种小情况：1.兄弟节点是三节点或四节点
                    if (colorOf(rightOf(right)) == BLACK) {// 兄弟节点的右孩子为空
                        setColor(leftOf(right), BLACK);
                        setColor(right, RED);
                        rotateRight(right);
                        right = rightOf(parentOf(node));
                    }
                    // 对于兄弟节点是四节点的情况，这里用了只旋转一次的方法（还有一种旋转两次的方法）
                    // 还兼顾了三节点的情况：对于三节点，右孩子为空的转化为左孩子为空的情况（也就是上面的if方法）
                    // 实在是妙！
                    setColor(right, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(rightOf(right), BLACK);
                    rotateLeft(parentOf(node));
                    node = root;
                }
            } else {// 被删除的是右节点
                RedBlackNode<K, V> left = leftOf(parentOf(node));
                if (colorOf(left) == RED) {// 父节点右旋，找到真正的兄弟节点
                    setColor(left, BLACK);
                    setColor(parentOf(node), RED);
                    rotateRight(parentOf(node));
                    left = leftOf(parentOf(node));
                }

                if (colorOf(left.left) == BLACK && colorOf(left.right) == BLACK) {// 兄弟节点没得借
                    setColor(left, RED);
                    node = parentOf(node);
                } else {
                    if (colorOf(leftOf(left)) == BLACK) {
                        setColor(rightOf(left), BLACK);
                        setColor(left, RED);
                        rotateLeft(left);
                        left = leftOf(parentOf(node));
                    }
                    setColor(left, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(leftOf(left), BLACK);
                    rotateRight(parentOf(node));
                    node = root;
                }
            }
        }
        // 对于2节点，兄弟没得借的情况，递归到根节点，把根节点染黑
        // 对于3、4节点直接染黑，补偿被删除的黑色节点
        setColor(node, BLACK);
    }

    private RedBlackNode<K, V> getNode(K key) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> cur = root;
        while (cur != null) {
            int cmp = key.compareTo(cur.key);
            if (cmp < 0) {
                cur = cur.left;
            } else if (cmp > 0) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return null;
    }

    /**
     * 返回目标节点的后继节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> successor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {
            RedBlackNode<K, V> p = node.right;
            while (p.left != null) {
                p = p.left;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 返回目标节点的前驱节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> preSuccessor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.left != null) {
            RedBlackNode<K, V> p = node.left;
            while (p.right != null) {
                p = p.right;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.left) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 2-3-4树新增元素的四种情况：
     * 1. 新增根节点
     * 2. 新增一个节点与2节点合并，成为一个3节点
     * 对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整
     * 3. 新增一个节点与3节点合并，成为一个4节点
     * 分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
     * 对应红黑树：调整后上黑下红
     *
     * @param node
     */
    private void fixAfterInsertion(RedBlackNode<K, V> node) {
        node.color = RED;
        // 父节点是黑色的不需要调整
        while (node != null && node != root && node.parent.color == RED) {
            // n爹 = n爹的爹的左孩子：左左左/左左右
            if (parentOf(node) == leftOf(parentOf(parentOf(node)))) {
                RedBlackNode<K, V> y = rightOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在4节点上新增节点的情况
                    setColor(parentOf(node), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == rightOf(parentOf(node))) {// 左左右转换为左左左
                        node = parentOf(node);// 注意这里，node指针指向也要变
                        rotateLeft(parentOf(node));
                    }
                    // 左左左
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateRight(parentOf(parentOf(node)));
                }
            } else {//右右右/右右左
                RedBlackNode<K, V> y = leftOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在四节点上新增节点的情况
                    setColor(y, BLACK);
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == leftOf(parentOf(node))) {
                        node = parentOf(node);
                        rotateRight(node);
                    }
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateLeft(parentOf(parentOf(node)));
                }
            }
        }
        root.color = BLACK;
    }

    private void setColor(RedBlackNode<K, V> node, boolean c) {
        if (node != null) {
            node.color = c;
        }
    }

    private boolean colorOf(RedBlackNode<K, V> node) {
        return node == null ? BLACK : node.color;// node为null则返回nil节点
    }

    private RedBlackNode<K, V> parentOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.parent;
    }

    private RedBlackNode<K, V> leftOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.left;
    }

    private RedBlackNode<K, V> rightOf(RedBlackNode node) {
        return node == null ? null : node.right;
    }

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    // 静态内部类
    static final class RedBlackNode<K extends Comparable<K>, V> {
        K key;
        V value;
        RedBlackNode<K, V> parent;
        RedBlackNode<K, V> left;

        public RedBlackNode<K, V> getLeft() {
            return left;
        }

        public RedBlackNode<K, V> getRight() {
            return right;
        }

        public boolean isColor() {
            return color;
        }

        RedBlackNode<K, V> right;
        boolean color = BLACK;


        public RedBlackNode(K key, V value, RedBlackNode<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }

    }


}
```

## 前缀树

`前缀树` ，又称 `字典树` ，是 `N 叉树` 的特殊形式。

### 简介

#### 什么是前缀树

`前缀树` 是 `N叉树` 的一种特殊形式。通常来说，一个前缀树是用来 `存储字符串` 的。前缀树的每一个节点代表一个 `字符串`（`前缀`）。每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。子节点代表的字符串是由节点本身的 `原始字符串` ，以及 `通往该子节点路径上所有的字符` 组成的。

下面是前缀树的一个例子：

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111210832143.png)

在上图示例中，我们在节点中标记的值是该节点对应表示的字符串。例如，我们从根节点开始，选择第二条路径 'b'，然后选择它的第一个子节点 'a'，接下来继续选择子节点 'd'，我们最终会到达叶节点 "bad"。节点的值是由从根节点开始，与其经过的路径中的字符按顺序形成的。

值得注意的是，根节点表示 `空字符串` 。

前缀树的一个重要的特性是，节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是 `前缀树` 名称的由来。

我们再来看这个例子。例如，以节点 "b" 为根的子树中的节点表示的字符串，都具有共同的前缀 "b"。反之亦然，具有公共前缀 "b" 的字符串，全部位于以 "b" 为根的子树中，并且具有不同前缀的字符串来自不同的分支。

前缀树有着广泛的应用，例如自动补全，拼写检查等等。

#### 如何表示一个前缀树

前缀树的特别之处在于字符和子节点之间的对应关系。有许多不同的表示前缀树节点的方法，这里我们只介绍其中的两种方法。

##### 方法一 - 数组

第一种方法是用 `数组` 存储子节点。

例如，如果我们只存储含有字母 a 到 z 的字符串，我们可以在每个节点中声明一个大小为 26 的数组来存储其子节点。对于特定字符 c ，我们可以使用 c - 'a' 作为索引来查找数组中相应的子节点。

访问子节点十分 `快捷` 。访问一个特定的子节点比较 `容易` ，因为在大多数情况下，我们很容易将一个字符转换为索引。但并非所有的子节点都需要这样的操作，所以这可能会导致 `空间的浪费` 。

##### 方法二 - Map

第二种方法是使用 `Hashmap` 来存储子节点。

我们可以在每个节点中声明一个 Hashmap 。Hashmap 的键是字符，值是相对应的子节点。

通过相应的字符来访问特定的子节点 `更为容易` 。但它可能比使用数组 `稍慢一些` 。但是，由于我们只存储我们需要的子节点，因此 `节省了空间` 。这个方法也更加 `灵活` ，因为我们不受到固定长度和固定范围的限制。

##### 补充

我们已经提到过如何表示前缀树中的子节点。除此之外，我们也需要用到一些其他的值。

例如，我们知道，前缀树的每个节点表示一个字符串，但并不是所有由前缀树表示的字符串都是有意义的。如果我们只想在前缀树中存储单词，那么我们可能需要在每个节点中声明一个布尔值（Boolean）作为标志，来表明该节点所表示的字符串是否为一个单词。

### 基本操作

#### 插入

如果我们在前缀树中插入一个字符串 S，我们要从根节点开始。 我们将根据 S[0]（S中的第一个字符），选择一个子节点或添加一个新的子节点。然后到达第二个节点，并根据 S[1] 做出选择。 再到第三个节点，以此类推。 最后，我们依次遍历 S 中的所有字符并到达末尾。 末端节点将是表示字符串 S 的节点。

通常情况情况下，你需要自己构建前缀树。构建前缀树实际上就是多次调用插入函数。但请记住在插入字符串之前要 `初始化根节点` 。

#### 搜索

正如我们在前缀树的简介中提到的，所有节点的后代都与该节点相对应字符串的有着共同前缀。因此，很容易搜索以特定前缀开头的任何单词。

同样地，我们可以根据给定的前缀沿着树形结构搜索下去。一旦我们找不到我们想要的子节点，搜索就以失败终止。否则，搜索成功。

##### 搜索单词

如何搜索特定的单词，而不是前缀。我们可以将这个词作为前缀，并同样按照上述同样的方法进行搜索。

- 如果搜索失败，那么意味着没有单词以目标单词开头，那么目标单词绝对不会存在于前缀树中。

- 如果搜索成功，我们需要检查目标单词是否是前缀树中单词的前缀，或者它本身就是一个单词。为了进一步解决这个问题，你可能需要稍对节点的结构做出修改。

**提示：**往每个节点中加入布尔值可能会有效地帮助你解决这个问题。

| 题目                                                         | 是否一次过 | 待解决问题                         |
| ------------------------------------------------------------ | ---------- | ---------------------------------- |
| [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) | 否         | ElasticSearch-倒排索引、二维数组法 |
| [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/) | 否         |                                    |
| [648. 单词替换](https://leetcode-cn.com/problems/replace-words/) | 否         |                                    |
| [642. 设计搜索自动补全系统](https://leetcode-cn.com/problems/design-search-autocomplete-system/) | 否         | 前缀树+自定义比较器                |
| [211. 添加与搜索单词 - 数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/) | 否         | 注意条件                           |
| [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) | 否         | 前缀树模板题                       |
| [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/) | 否         | 复习！！！                         |
| [425. 单词方块](https://leetcode-cn.com/problems/word-squares/) | 否         | 46. 全排列 + 422. 有效的单词方块   |
| [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/) | 否         |                                    |

- [*T**r**i**e* 第一部（Trie 模板题）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488490&idx=1&sn=db2998cb0e5f08684ee1b6009b974089&chksm=fd9cb8f5caeb31e3f7f67dba981d8d01a24e26c93ead5491edb521c988adc0798d8acb6f9e9d&scene=178&cur_album_id=2049538161285955584#rd)
- [Trie*T**r**i**e* 第二部（Trie 优化 DFS 搜索）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489083&idx=1&sn=1971fdceb180ef3c7d51f8fbb81527d0&chksm=fd9cbd24caeb34321076e3f34bae0c001c9032b2b1814d15badab26cd4e8cddf48ac051550f6&scene=178&cur_album_id=2049538161285955584#rd)
- [Trie*T**r**i**e* 第三部（结合贪心的 Trie）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489106&idx=1&sn=b7c1d4864f42e8a54f4b4754ff9ba8d7&chksm=fd9cbd4dcaeb345b5e39e799bdbeb2e89ed424c763e2af2a23fcb8eab228acc46d10f0395686&token=1901895674&lang=zh_CN#rd)
- [Trie*T**r**i**e* 第四部（可删除/可计数的 Trie）](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489259&idx=1&sn=042ee479cebfbcf1f3b517461b32ddac&chksm=fd9cbdf4caeb34e2254783b211bac795eb0c9bd9b4be844cf48450ca5afa7ca5694fd98f7d39&token=1848397639&lang=zh_CN#rd)

### 前缀树小结

Trie 树（又叫「前缀树」或「字典树」）是一种用于快速查询「某个字符串/字符前缀」是否存在的数据结构。

其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111211114260.png)


#### Trie 的应用面

在纯算法领域，前缀树算是一种较为常用的数据结构。

不过如果在工程中，不考虑前缀匹配的话，基本上使用 hash 就能满足。

如果考虑前缀匹配的话，工程也不会使用 Trie 。

一方面是字符集大小不好确定（题目只考虑 26 个字母，字符集大小限制在较小的 26 内）因此可以使用 Trie，但是工程一般兼容各种字符集，一旦字符集大小很大的话，Trie 将会带来很大的空间浪费。

另外，对于个别的超长字符 Trie 会进一步变深。

这时候如果 Trie 是存储在硬盘中，Trie 结构过深带来的影响是多次随机 IO，随机 IO 是成本很高的操作。

同时 Trie 的特殊结构，也会为分布式存储将会带来困难。

因此在工程领域中 Trie 的应用面不广。

至于一些诸如「联想输入」、「模糊匹配」、「全文检索」的典型场景在工程主要是通过 ES (ElasticSearch) 解决的。

而 ES 的实现则主要是依靠「倒排索引」。

## N叉树

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/nary_tree_example.png)

1. 前序遍历
   在 N 叉树中，前序遍历指先访问根节点，然后逐个遍历以其子节点为根的子树。
   例如，上述三叉树的前序遍历是：A->B->C->E->F->D->G.
2. 后序遍历
   在 N 叉树中，后序遍历指前先逐个遍历以根节点的子节点为根的子树，最后访问根节点。
   例如，上述三叉树的后序遍历是：B->E->F->C->G->D->A.
3. 层序遍历
   N 叉树的层序遍历与二叉树的一致。通常，当我们在树中进行广度优先搜索时，我们将按层序的顺序进行遍历。
   例如，上述三叉树的层序遍历是：A->B->C->D->E->F->G.

| 题目                                                         | 是否一次过 | 待解决问题 |
| ------------------------------------------------------------ | ---------- | ---------- |
| [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) | 是         |            |
| [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) | 是         |            |
| [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) | 是         |            |
| [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) | 否         | 迭代解法   |
| [428. 序列化和反序列化 N 叉树](https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree/) | 是         |            |

## 线段树-区间修改树

### 定义

**线段树**（英语：Segment tree）是一种[二叉树](https://zh.wikipedia.org/wiki/二元樹)形数据结构，用以存储[区间](https://zh.wikipedia.org/wiki/區間)或[线段](https://zh.wikipedia.org/wiki/線段)，并且允许快速查询结构内包含某一点的所有区间。

一个包含${\displaystyle n}$个区间的线段树，空间复杂度为${\displaystyle O(n)}$，查询的时间复杂度则为${\displaystyle O(\log n+k)}$，其中${\displaystyle k}$是符合条件的区间数量。

此数据结构亦可推广到高维度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，[时间复杂度](https://baike.baidu.com/item/时间复杂度)为O(logN）

使用线段树可以快速 修改、查询区间的某些东西



### **完全二叉树与数组的转换**

**数组下标从 1 开始**，这样可以方便的转换，且可以用位运算加速

1. 如何找到节点n的父节点？
   - 父节点下标 = n/2
2. 如何找到节点n的左孩子节点和右孩子节点
   - $左孩子节点下标 = 2*n$
   - $右孩子节点下标 = 2*n +1$
3. 如何确定长度为n的完全二叉树的一个节点是否是叶子节点
   - $长度为n的完全二叉树的叶子节点下标 大于 n/2$

![image-20211114172207301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141722372.png)

### 线段树空间复杂度

对于 n 个节点，建立满二叉树，**最多**需要 4n 空间：

对于最差情况，满二叉树左子树叶子节点有 n - 1 个（逼近 n ），右子树叶子节点有 1 个，为了补成 满二叉树，右子树 也应有 n-1个叶子节点（逼近 n），那么构建满二叉树，最多需要 4n 空间（可能会有些浪费，没关系，）

![image-20211221095525649](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112210955051.png)

最省空间情况：n 正好是 $2^k$

最不省空间情况：n 是 $2^k-1$

**实例：**

- 最省空间情况： 对于 n = 8 的情况，建立满二叉树，需要 8*2 - 1 = 15 的空间

- 最不省空间情况：对于 n = 5 的情况，建立满二叉树，需要 8*2 - 1 = 15 的空间

### 线段树三个方法

时间复杂度都是 $O(log^n)$

```java
void add(int L,int R,int v,int[] arr);
void update(int L,int R,int v,int[] arr);
void get(int L,int R,int v,int[] arr);
```

### 线段树增加想要的信息 - 以求 线段累加和(sum)  信息为例

#### 线段树初始化

```java
package zs.tree;

/**
 * @author miemiehoho
 * @date 2021/12/21 9:37
 */
public class SegmentTree {

    private int MAXN;
    private int[] arr;// arr[]为原序列的信息从0开始，但在arr里是从1开始的
    private int[] sum;// sum[]模拟线段树维护区间和

    public SegmentTree(int[] origin) {
        this.MAXN = arr.length + 1;
        arr = new int[MAXN];
        for (int i = 1; i < MAXN; i++) {
            arr[i] = origin[i - 1];
        }
        sum = new int[MAXN << 2];
    }

    /**
     * 线段树初始化，填写 sum数组
     * 在 arr[l~r] 范围上 build
     * rt : 这个范围在 sum 中的下标
     *
     * @param l
     * @param r
     * @param rt
     */
    private void build(int l, int r, int rt) {
        if (l == r) {// 长度为1的线段，即元线段
            sum[rt] = arr[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);// 利用位运算加速
        build(mid + 1, r, rt << 1 | 1);
        pushUp(rt);
    }

    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    }
}
```

#### 线段树-懒更新机制

- 如果下发的任务，把当前范围全包括了（即“懒的住”）：
  - 则任务不再下发，更新当前范围（节点rt）的 sum 信息，并把 “懒住” 的信息存入 lazy 数组
- 如果下发的任务，无法把当前范围全包括（即“懒不住”）：
  1. 下发之前 “懒住”的信息给左右子树
  2. 下发新任务给 左右子树

懒更新机制 优点：

- 时间复杂度 $O(log^n)$：总是会卡着左边界或卡着右边界，所以就是$O(log^n)$

##### 懒更新机制 - 实例

假设线段树 范围是 1~1024

**1、“懒的住” 的情况**

如果要更新 1~256的信息，加 7：

1. 根结点把任务下发给左右子结点，
2. 那么对于节点 x (它是 1~256这颗子树的根结点)，它将不再把任务下发，也就是这次更新只经历了部分边界，所以 懒更新的 时间复杂度 $O(log^n)$

**2、“懒不住” 的情况**

如果又要更新 1~100的信息，加 5：

1. 结点 x 把 之前的 “懒住” 的任务下发给左右子结点
2. 接受新信息：更新 1~100,范围 小于 1~256，即 “懒不住” ，将新任务下发给左子树
3. x 的左子树继续判断 是否“懒的住”，然后执行相应方法 



#### 线段树 - add() 方法

```java
/**
 * [L……R] 任务范围
 * [l……r] 当前节点范围
 * rt 当前节点
 */
public void add(int L, int R, int C, int l, int r, int rt) {
    // 任务范围被覆盖，直接 懒住
    if (L <= l && R >= r) {
        sum[rt] += (r - l + 1) * C;// sum[rt]累加
        lazy[rt] += C;// lazy[rt] 累加
        return;
    }
    // 任务并没有被全包，需要下发任务
    int mid = (l + r) >> 1;
    // 下发之前攒的所有 懒任务
    pushDown(rt, mid - l + 1, r - mid);
    if (L <= mid) {// 左孩子是否需要接收任务
        add(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {// 右孩子是否需要接受任务
        add(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    // 左右孩子完成任务后，更新自己的sum信息
    pushUp(rt);
}
```

#### 线段树 - update() 方法

```java
public void update(int L, int R, int C, int l, int r, int rt) {
    // 被包住
    if (L <= l && R >= r) {
        update[rt] = true;
        change[rt] = C;
        sum[rt] = C * (r - l + 1);
        lazy[rt] = 0;
        return;
    }
    // 当前任务躲不掉了
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    if (L <= mid) {
        update(L, R, C, l, mid, rt << 1);
    }
    if (R > mid) {
        update(L, R, C, mid + 1, r, rt << 1 | 1);
    }
    pushUp(rt);
}
```

#### 线段树 - getSum() 方法

```java
public long query(int L, int R, int l, int r, int rt) {
    if (L <= l && r <= R) {
        return sum[rt];
    }
    int mid = (l + r) >> 1;
    pushDown(rt, mid - l + 1, r - mid);
    long ans = 0;// long型，防止越界
    if (L <= mid) {
        ans += query(L, R, l, mid, rt << 1);
    }
    if (R > mid) {
        ans += query(L, R, mid + 1, r, rt << 1 | 1);
    }
    return ans;
}
```

### 完整代码实现

```java
package zs.tree;

/**
 * @author miemiehoho
 * @date 2021/12/21 9:37
 */
public class SegmentTree {

    private int MAXN;
    private int[] arr;// arr[]为原序列的信息从0开始，但在arr里是从1开始的
    private int[] sum;// sum[]模拟线段树维护区间和
    private int[] lazy;// lazy[]为累加懒惰标记
    private int[] change;// change[]为更新的值
    private boolean[] update;// update[]为更新慵懒标记

    public SegmentTree(int[] origin) {
        MAXN = origin.length + 1;
        arr = new int[MAXN];
        for (int i = 1; i < MAXN; i++) {
            arr[i] = origin[i - 1];
        }
        sum = new int[MAXN << 2];
        lazy = new int[MAXN << 2];
        change = new int[MAXN << 2];
        update = new boolean[MAXN << 2];
    }

    /**
     * 线段树初始化，填写 sum数组
     * 在 arr[l~r] 范围上 build
     * rt : 这个范围在 sum 中的下标
     *
     * @param l
     * @param r
     * @param rt
     */
    private void build(int l, int r, int rt) {
        if (l == r) {// 长度为1的线段，即元线段
            sum[rt] = arr[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);// 利用位运算加速
        build(mid + 1, r, rt << 1 | 1);
        pushUp(rt);
    }

    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    }

    /**
     * 懒增加和懒更新，从父范围，分发给左右子范围
     * 分发策略：
     * 1.检查父范围是否有懒更新操作
     * 2.检查父范围是否有懒增加操作（如果有，说明是在更新后新增的，所以才存在）
     *
     * @param rt 当前需要下发的范围结点
     * @param ln 当前需要下发的范围结点的左结点需要更新的结点个数
     * @param rn 当前需要下发的范围结点的右结点需要更新的结点个数
     */
    private void pushDown(int rt, int ln, int rn) {
        if (update[rt]) {
            update[rt << 1] = true;
            update[rt << 1 | 1] = true;
            change[rt << 1] = change[rt];
            change[rt << 1 | 1] = change[rt];
            lazy[rt << 1] = 0;
            lazy[rt << 1 | 1] = 0;
            sum[rt << 1] = change[rt] * ln;
            sum[rt << 1 | 1] = change[rt] * rn;
            update[rt] = false;
        }
        if (lazy[rt] != 0) {
            lazy[rt << 1] += lazy[rt];
            sum[rt << 1] += lazy[rt] * ln;
            lazy[rt << 1 | 1] += lazy[rt];
            sum[rt << 1 | 1] += lazy[rt] * rn;
            lazy[rt] = 0;// 已经下发了，清零
        }
    }

    /**
     * [L……R] 任务范围
     * [l……r] 当前节点范围
     * rt 当前节点
     */
    public void add(int L, int R, int C, int l, int r, int rt) {
        // 任务范围被覆盖，直接 懒住
        if (L <= l && R >= r) {
            sum[rt] += (r - l + 1) * C;// sum[rt]累加
            lazy[rt] += C;// lazy[rt] 累加
            return;
        }
        // 任务并没有被全包，需要下发任务
        int mid = (l + r) >> 1;
        // 下发之前攒的所有 懒任务
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {// 左孩子是否需要接收任务
            add(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {// 右孩子是否需要接受任务
            add(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        // 左右孩子完成任务后，更新自己的sum信息
        pushUp(rt);
    }

    public void update(int L, int R, int C, int l, int r, int rt) {
        // 被包住
        if (L <= l && R >= r) {
            update[rt] = true;
            change[rt] = C;
            sum[rt] = C * (r - l + 1);
            lazy[rt] = 0;
            return;
        }
        // 当前任务躲不掉了
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            update(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {
            update(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        pushUp(rt);
    }

    public long query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) {
            return sum[rt];
        }
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        long ans = 0;// long型，防止越界
        if (L <= mid) {
            ans += query(L, R, l, mid, rt << 1);
        }
        if (R > mid) {
            ans += query(L, R, mid + 1, r, rt << 1 | 1);
        }
        return ans;
    }


    public static class Right {
        public int[] arr;

        public Right(int[] origin) {
            arr = new int[origin.length + 1];
            for (int i = 0; i < origin.length; i++) {
                arr[i + 1] = origin[i];
            }
        }

        public void update(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] = C;
            }
        }

        public void add(int L, int R, int C) {
            for (int i = L; i <= R; i++) {
                arr[i] += C;
            }
        }

        public long query(int L, int R) {
            long ans = 0;
            for (int i = L; i <= R; i++) {
                ans += arr[i];
            }
            return ans;
        }

    }

    public static int[] genarateRandomArray(int len, int max) {
        int size = (int) (Math.random() * len) + 1;
        int[] origin = new int[size];
        for (int i = 0; i < size; i++) {
            origin[i] = (int) (Math.random() * max) - (int) (Math.random() * max);
        }
        return origin;
    }

    public static boolean test() {
        int len = 100;
        int max = 1000;
        int testTimes = 5000;
        int addOrUpdateTimes = 1000;
        int queryTimes = 500;
        for (int i = 0; i < testTimes; i++) {
            int[] origin = genarateRandomArray(len, max);
            SegmentTree seg = new SegmentTree(origin);
            int S = 1;
            int N = origin.length;
            int root = 1;
            seg.build(S, N, root);
            Right rig = new Right(origin);
            for (int j = 0; j < addOrUpdateTimes; j++) {
                int num1 = (int) (Math.random() * N) + 1;
                int num2 = (int) (Math.random() * N) + 1;
                int L = Math.min(num1, num2);
                int R = Math.max(num1, num2);
                int C = (int) (Math.random() * max) - (int) (Math.random() * max);
                if (Math.random() < 0.5) {
                    seg.add(L, R, C, S, N, root);
                    rig.add(L, R, C);
                } else {
                    seg.update(L, R, C, S, N, root);
                    rig.update(L, R, C);
                }
            }
            for (int k = 0; k < queryTimes; k++) {
                int num1 = (int) (Math.random() * N) + 1;
                int num2 = (int) (Math.random() * N) + 1;
                int L = Math.min(num1, num2);
                int R = Math.max(num1, num2);
                long ans1 = seg.query(L, R, S, N, root);
                long ans2 = rig.query(L, R);
                if (ans1 != ans2) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int[] origin = {2, 1, 1, 2, 3, 4, 5};
        SegmentTree seg = new SegmentTree(origin);
        int S = 1; // 整个区间的开始位置，规定从1开始，不从0开始 -> 固定
        int N = origin.length; // 整个区间的结束位置，规定能到N，不是N-1 -> 固定
        int root = 1; // 整棵树的头节点位置，规定是1，不是0 -> 固定
        int L = 2; // 操作区间的开始位置 -> 可变
        int R = 5; // 操作区间的结束位置 -> 可变
        int C = 4; // 要加的数字或者要更新的数字 -> 可变
        // 区间生成，必须在[S,N]整个范围上build
        seg.build(S, N, root);
        // 区间修改，可以改变L、R和C的值，其他值不可改变
        seg.add(L, R, C, S, N, root);
        // 区间更新，可以改变L、R和C的值，其他值不可改变
        seg.update(L, R, C, S, N, root);
        // 区间查询，可以改变L和R的值，其他值不可改变
        long sum = seg.query(L, R, S, N, root);
        System.out.println(sum);

        System.out.println("对数器测试开始...");
        System.out.println("测试结果 : " + (test() ? "通过" : "未通过"));

    }
}
```



## 堆

堆：高效快速地取得当前数据集中最大或者最小的元素

在介绍 **堆** 之前，我们需要首先介绍下 **优先队列**

> 维基百科：优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。

在很多书中会认为 堆 就是 优先队列 。但是， 优先队列 是一种抽象的数据类型，而 堆 是一种数据结构。所以 堆 并不是 优先队列 ， **堆 是实现 优先队列 的一种方式**。

实现 优先队列 的方式有很多种，比如数组和链表。但是，这些实现方式只能保证插入操作和删除操作中的一种操作可以在 O(1) 的时间复杂度内完成，而另外一个操作则需要在 O(N)的时间复杂度内完成。而 堆 能够使 优先队列 的插入操作在 O(log N)的时间复杂度内完成，删除操作在 O(log N)的时间复杂度内完成。

### 堆的定义与分类

#### 堆的定义

根据 维基百科 的定义，堆 是一种特别的二叉树，满足以下条件的二叉树，可以称之为 堆：

1. 完全二叉树

   - **完美二叉树：**

     - 一棵深度为k，且有{\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}![{\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}](https://wikimedia.org/api/rest_v1/media/math/render/svg/40e7e2aed4ee10bc92e2fd88afda4b76da298a48)个节点的[二叉树](https://zh.wikipedia.org/wiki/二元樹)，称为[完美二叉树](https://zh.wikipedia.org/w/index.php?title=完美二元樹&action=edit&redlink=1)（Perfect Binary Tree)。这种树的特点是每一层上的节点数都是最大节点数。

   - **完全二叉树：**

     - 在一颗[二叉树](https://zh.wikipedia.org/wiki/二元樹)中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此[二叉树](https://zh.wikipedia.org/wiki/二元樹)为[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)（Complete Binary Tree）。具有n个节点的[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)的深度为${\displaystyle log_{2}n+1}$。深度为k的[完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)，至少有${\displaystyle 2^{\begin{aligned}k-1\end{aligned}}}$个节点，至多有${\displaystyle 2^{\begin{aligned}k\end{aligned}}-1}$个节点。

     ![image-20211114170608776](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141706732.png)

     |           | [ 完全二叉树](https://zh.wikipedia.org/wiki/完全二叉树)  | 完美二叉树                         |
     | :-------: | :------------------------------------------------------: | ---------------------------------- |
     | 总节点$k$ | ${\displaystyle 2^{h-1}}<= k <= {\displaystyle 2^{h}-1}$ | $k = {\displaystyle 2^{h}-1}$      |
     |  树高$h$  |             $h = {\displaystyle log_{2}k+1}$             | $h = {\displaystyle log_{2}(k+1)}$ |

2. 每一个节点的值都必须 大于等于或者小于等于 其孩子节点的值。

**堆 具有以下的特点：**

1. 可以在 O(logN) 的时间复杂度内向 堆 中插入元素；

2. 可以在 O(logN) 的时间复杂度内向 堆 中删除元素；
3. 可以在 O(1) 的时间复杂度内获取 堆 中的最大值或最小值。

#### 堆的分类

堆 有两种类型：最大堆 和 最小堆。

- 最大堆：堆中每一个节点的值 都大于等于 其孩子节点的值。所以最大堆的特性是 堆顶元素（根节点）是堆中的最大值。


- 最小堆：堆中每一个节点的值 都小于等于 其孩子节点的值。所以最小堆的特性是 堆顶元素（根节点）是堆中的最小值。


![image.png](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141656518.png)

#### 基于数组实现堆

**完全二叉树与数组的转换**

1. 如何找到节点n的父节点？
   - 父节点下标 = n/2
2. 如何找到节点n的左孩子节点和右孩子节点
   - $左孩子节点下标 = 2*n$
   - $右孩子节点下标 = 2*n +1$
3. 如何确定长度为n的完全二叉树的一个节点是否是叶子节点
   - $长度为n的完全二叉树的叶子节点下标 大于 n/2$

![image-20211114172207301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111141722372.png)

#### 算法实现

```java
/**
 * 最大堆
 *
 * @author miemiehoho
 * @date 2021/11/14 17:33
 */
public class MaxHeap {
    // 使用数组创建完全二叉树的结构，然后使用二叉树构建一个堆
    int[] maxHeap;
    // 数组的大小
    int heapSize;
    // 记录堆的元素个数
    int realSize;

    public MaxHeap(int heapSize) {
        this.heapSize = heapSize;
        maxHeap = new int[heapSize + 1];
        // 为了便于完全二叉树的管理，数组的第0个索引将不会被使用，其值可以设置成堆中的元素个数
        maxHeap[0] = 0;
    }

    /**
     * 添加元素
     *
     * @param val
     */
    public void add(int val) {
        realSize++;
        if (realSize > heapSize) {
            System.out.println("Add too many values!");
            realSize--;
            return;
        }
        // 将新的val添加到数组中
        maxHeap[realSize] = val;
        // 新增元素的索引位置
        int idx = realSize;
        // 新增元素的父节点的索引位置
        int parentIdx = idx / 2;
        // 当新增元素的值大于父节点值时，交换父子节点的值
        while (maxHeap[idx] > maxHeap[parentIdx] && idx > 1) {
            int temp = maxHeap[parentIdx];
            maxHeap[parentIdx] = maxHeap[idx];
            maxHeap[idx] = temp;
            idx = parentIdx;
            parentIdx = idx / 2;
        }
    }

    // 获得堆顶元素
    public int peek() {
        return maxHeap[1];
    }

    // 删除堆顶元素
    public int pop() {
        if (realSize < 1) {
            System.out.println("Don't have any value!");
            return Integer.MIN_VALUE;
        }
        // 需要删除的堆顶元素
        int removeVal = maxHeap[1];
        // 将堆中的最后一个元素赋值给堆顶
        maxHeap[1] = maxHeap[realSize];
        realSize--;
        // 需要调整的元素下标
        int idx = 1;
        // 当需要调整的元素不是叶子节点时
        while (idx < realSize && idx <= realSize / 2) {
            // 左孩子节点
            int left = idx * 2;
            // 右孩子节点
            int right = left + 1;
            // 当需要调整的元素小于其左（右）孩子，将其与左（右）孩子交换
            if (maxHeap[idx] < maxHeap[left] || maxHeap[idx] < maxHeap[right]) {
                if (maxHeap[left] > maxHeap[right]) {
                    swap(left, idx);
                    idx = left;
                } else {
                    swap(right, idx);
                    idx = right;
                }
            } else {
                break;
            }
        }
        return removeVal;
    }

    private void swap(int i, int j) {
        if (maxHeap[i] != maxHeap[j]) {
            maxHeap[j] ^= maxHeap[i];
            maxHeap[i] ^= maxHeap[j];
            maxHeap[j] ^= maxHeap[i];
        }
    }

}
```

### 堆的常用方法

#### 创建堆

时间复杂度：O(n)

空间复杂度：O(n)

```java
public static void main(String[] args) {
    // Java中的堆可以用优先队列来表示
    // 创建一个空的最小堆
    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    // 创建一个空的最大堆
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>((v1, v2) -> v1 - v2);
    // 创建带初始值的最小堆
    PriorityQueue<Integer> minHeadWithValues = new PriorityQueue<>(Arrays.asList(7, 4, 2, 9, 6));
}
```

| 「堆」的用法     | 时间复杂度 | 空间复杂度 |
| ---------------- | ---------- | ---------- |
| 创建「堆」       | O(N)       | O(N)       |
| 插入元素         | O(logN)    | O(1)       |
| 获取堆顶元素     | O(1)       | O(1)       |
| 删除堆顶元素     | O(logN)    | O(1)       |
| 获取「堆」的长度 | O(1)       | O(1)       |

### 堆的应用

#### 堆排序

**理论**：堆排序指的是利用**堆**的数据结构对一组无序元素进行排序。

**最小堆排序算法：**

1. 将所有元素堆化成一个 最小堆 ；

2. 取出并删除堆顶元素，并将该堆顶元素放置在存储有序元素的数据集 T 中；
3. 此时，堆 会调整成新的 最小堆；
4. 重复 3 和 4 步骤，直到 堆 中没有元素；
5. 此时得到一个新的数据集 T，其中的元素按照 从小到大 的顺序排列。

**最大堆排序算法：**

1. 将所有元素堆化成一个 最大堆；

2. 取出并删除堆顶元素，并将该堆顶元素放置在存储有序元素的数据集 T 中；
3. 此时，堆 会调整成新的 最大堆；
4. 重复 3 和 4 步骤，直到 堆 中没有元素；
5. 此时得到一个新的数据集 T，其中的元素按照从大到小的顺序排列。

**时间复杂度：**$O(Nlog^N)$，N 是 **堆** 中的元素个数。

**空间复杂度：**$O(N)$，N 是 **堆** 中的元素个数。

### Top K问题

**Top K 问题:** 获取Top K 大的元素

#### 解法一：最大堆

解法步骤：

1. 创建一个最大堆
2. 将所有元素加入到最大堆中
3. 通过边删除边遍历的方式，将堆顶元素删除并保存到结果集T中
4. 重复步骤3 K次，直到获取前K大的元素

**时间复杂度：** $O(Klog^N)$

**空间复杂度：**$O(N)$

#### 解法二：最小堆

解法步骤：

1. 创建一个大小为K的最小堆
2. 依次将元素添加到最小堆中
3. 当最小堆的个数达到K时，将堆顶元素与当前元素对比：
   1. 如果当前元素小于堆顶，则放弃当前元素，继续进行下一轮比较
   2. 如果当前元素大于堆顶，则删除堆顶元素，将当前元素加入到最小堆中
4. 重复步骤 2 和 3 ，直到所有元素遍历完毕
5. 此时 最小堆 中的 K个元素就是前 K 个最大的元素

**时间复杂度：** $O(Nlog^K)$

**空间复杂度：**$O(K)$

### The Kth 问题

参照上面的Top K问题解法

![image-20211114200754976](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111142007171.png)