# 二叉树



## 学习笔记

### 树

#### 树的高度和深度

高度和深度是相反的表示，深度是从上到下数的，而高度是从下往上数

**高度：**指从该节点到叶子节点的最长简单路径边的条数
**深度：**指从根节点到该节点的最长简单路径边的条数

**注意：**

- 这里边的条数是规定根节点的深度和叶子节点的高度是0

- 树的深度和高度是相等的，而对其他节点来说深度和高度不一定相等

**实例**

![123](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111101647565.jpg)

如 B和C节点深度都为1，因为从根节点到到该节点的边数为1，B的高度为2，而C的高度为1。

当然树的深度是3高度也是3。树的高度和深度是相等的。

#### 树的其他定义

兄弟节点：具有相同父节点的节点互称为兄弟节点；



## 树形dp解题套路

> ZS语录：Morris遍历可以解决的问题，递归套路一定能解；不是什么题目都能用Morris遍历；

**套路：**

```
设 x 为 头结点（可能是任意子树的头结点，包括根结点），思路：
1. 设定：结点 x 可以从左右子树获得信息
2. 思考列出得到答案的可能性
3. 列出所有可能性
4. 根据列出的可能性，确定需要从左右子树分别获得什么信息
5. 根据需要的所有信息，设定（全集）信息体
6. 写递归
```

##### 题目一：二叉树结点间的最大距离问题

- 列出所有可能性
  1. 与 结点 x 有关时的最大距离: 左树高度+右树高度+ 1 (结点 X)
     - 结点 x 的左子树中距离 x 最远的结点，经过 结点 x 到达 结点 x 的右子树距离 x 最远的结点
  2. 与 结点 x 无关，最大距离不经过 x:  即为左子树或右子树的最大距离

- 根据列出的可能性，确定需要从左右子树获得的信息：左右子树的最大距离、高度
- 设计递归：
  1. 定义 Info
  2. 设定递归函数的返回值为 Info
  3. 空树 return null
  4. 获得左右子树 Info
  5. 加工获得 当前结点的 Info，并返回（注意：判空）

##### 代码实现

```java
public static class Node {
    public int value;
    public Node left;
    public Node right;

    public Node(int data) {
        this.value = data;
    }
}

// 信息体
private static class Info {
    public int maxDistance;
    public int height;

    public Info(int maxDistance, int height) {
        this.maxDistance = maxDistance;
        this.height = height;
    }
}

private static Info process(Node x) {
    if (x == null) {
        return null;
    }
    Info left = process(x.left);
    Info right = process(x.right);

    int maxDistance = 0;
    int height = 0;
    if (left != null) {
        maxDistance = left.maxDistance;
        height = left.height;
    }
    if (right != null) {
        maxDistance = Math.max(maxDistance, right.maxDistance);
        height = Math.max(height, right.height) + 1;
    }
    maxDistance = Math.max(maxDistance,
            (left == null ? 0 : left.height) + (right == null ? 0 : right.height) + 1);
    return new Info(maxDistance, height);
}

public static int maxDistance(Node x) {
    return process(x).maxDistance;
}
```

##### 题目二：最大二叉搜索子树的大小

套用树形dp套路：

1. 列出所有可能性
   - 与 x 结点 无关
     - 左子树最大二叉搜索子树的大小
     - 右子树最大二叉搜索子树的大小
   - 与 x 结点 有关
     - 左树必须是 BST
     - 右树必须是 BST
     - 左子树最大值小于 x，右子树最小值大于 x
2. 根据列出的可能性，确定需要从左右子树获得的信息：
3. 设计递归
   1. 定义信息 Info
   2. 设定递归函数返回值为 Info
   3. 空树返回null
   4. 获得左右子树信息
   5. 加工获得当前结点Info（注意判空）并返回



#### 树形dp递归套路与非递归dp的比较

- 树形结构利用递归实现了dp，与dp相同的是都是用空间换时间，但在某些情况下，使用递归dp比非递归dp还要省空间：

  - 例：求二叉树结点间的最大距离问题，树形递归dp的空间复杂度为O(h)，非递归dp空间复杂度为O(N)

  - 树形递归dp的空间复杂度为O(h)，如图

    <img src="https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112112007136.png" alt="image-20211211200728561" style="zoom:25%;" />

- 树形dp递归套路在递归过程中维持了dp的信息，利用的是dp的思想，只是实现方式是递归

  - 不是所有的递归都是dp，对于有空间换时间的递归才是dp，没有空间换时间（比如N皇后问题）就是暴力



#### 什么题目可以用Morris得到最优解，什么题目必须用 递归套路

- 必须同时获得左右子树的信息的题只能用递归套路
- 不要求第三次回到目标结点（不需要同时拿到左右子树信息），Morris是最优解
  - 例：必须判断是否BST，只要中序遍历之前的结点都小于当前结点











## 二叉树

### 二叉树的序列化与反序列化

二叉树的序列号与反序列化可以用先序、后序、层次遍历实现，但是中序遍历只能序列化，无法反序列化（因为先序后序方式知道头节点位置，中序方式不知道）

![image-20211212103831264](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112121038520.png)

### 二叉搜索树

### 平衡二叉搜索树



## B 树

**B树**（英语：B-tree）是一种自平衡的[树](https://zh.wikipedia.org/wiki/树_(数据结构))，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在[对数时间](https://zh.wikipedia.org/wiki/时间复杂度#对数时间)内完成。B树，概括来说是一个一般化的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)（binary search tree）一个节点可以拥有2个以上的子节点。与[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在[数据库](https://zh.wikipedia.org/wiki/数据库)和[文件系统](https://zh.wikipedia.org/wiki/文件系统)的实现上。



B树，是为磁盘存储而专门设计的一类**平衡搜索树**。由于磁盘操作比随机存储取存器慢得多，因此衡量B树的性能，不仅要考虑动态集合操作消耗了多少计算时间，而且还要考虑这些操作执行了多少次磁盘存取。对每个B树操作，磁盘存取的次数随着B树的高度而增加。

B树与红黑树的不同之处在于B树的结点可以有很多孩子，也就是说一个B树的“分支因子”可以相当大

### 定义

B树也称多路平衡查找树，是一种组织和维护外存文件系统的非常有效的数据结构。



一个 *m* 阶的B树是一个有以下属性的树：

1. 每一个节点最多有 *m* 个子节点
2. 每一个非叶子节点（除根节点）最少有 ⌈*m*/2⌉ 个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 *k* 个子节点的非叶子节点拥有 *k* − 1 个键
5. 所有的叶子节点都在同一层。B树是所有结点的平衡因子均等于0的多路查找树。

- 在计算B树的高度时，需要计入最底层的外部结点

### 操作

#### 搜索

B树的搜索和二叉搜索树类似，从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。

#### 插入

将关键字K插入B树的过程分两步完成：

1. 查找该关键字的插入节点（B树的插入节点一定是叶子节点层的节点）

2. 插入关键字

   1. 如果插入节点有空位置，即关键字个数 n<m-1:直接把关键字k有序插入到该节点的合适位置上

   2. 插入节点没有空位置，即原插入节点关键字个数 n = m-1 =》分裂

      - 分裂过程：

        - 如果没有双亲节点，新建一个双亲节点，树的高度增加一层
        - 如果有双亲节点，将k插入到双亲节点中

        ![image-20211202215511715](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022155437.png)

**插入实例：**

![image-20211202215759546](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022158935.png)



![image-20211202215911844](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022159842.png)

![image-20211202220039714](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022200528.png)



![image-20211202220214743](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022202444.png)



![image-20211202220245063](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204816.png)



![image-20211202220325109](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204557.png)



![image-20211202220404989](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022204896.png)



**思考题：**

1. 在B树中每插入一个关键字，都要新建一个节点吗？
   1. 不一定，如果找到的叶子节点的关键字的个数小于 m-1，就可以直接有序插入
2. 在B树中插入一个关键字，若引起分裂，树高一定会升高一层吗
   1. 不一定，如果父节点的关键字的个数小于 m-1，就不会升高
   2. 如果没有父节点，就需要升高
   3. 如果父节点的关键字的个数超过了 m-1，就需要升高

#### 删除

在B树上删除关键字K的过程分两步完成：

1. 查找关键字K所在的节点
2. 删除关键字K

删除关键字K分两种情况：

- 在叶子节点层删除关键字K
- 在非叶子节点层删除关键字K

**注意：**非根、非叶子节点的关键字个数最少为 (m/2)-1



##### 删除叶子节点中的元素

1. 搜索要删除的元素
2. 如果它在叶子节点，将它从中删除
3. 如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树

##### 删除内部节点中的元素

内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：

1. 选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。
2. 前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。

##### 删除后的重新平衡

重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 **合并**。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：

- 如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转
  1. 将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转
  1. 将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）
  2. 将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）
  3. 树又重新平衡
- 否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并
  1. 将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）
  2. 将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）
  3. 将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）
     - 如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）
     - 否则，如果父节点的元素数量小于最小值，重新平衡父节点

**删除实例**

![image-20211202222451739](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227992.png)



![image-20211202222513166](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227159.png)



![image-20211202222528308](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227454.png)



![image-20211202222553712](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227728.png)



![image-20211202222617747](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227715.png)

![image-20211202222731909](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022227569.png)



**思考题：**

1. 在B树中每删除一个关键字，都要删除一个节点吗?
   1. 不一定，删除后如果节点个数仍大于等于最小个数就不需要删除
2. 在B树中删除一个关键字若引起合并，树高度一定会降低吗？
   1. 不一定

#### 为什么要使用B树？

**Disk Structure**

块的定义：轨道和扇区的相交位置；块可以通过轨道号和扇区号对磁盘进行寻址

块地址的形式（轨道号，扇区号）

块大小通常为 512字节，以达到稳定的目的

在块中每个字节可以有自己的地址，成为偏移量，因此读取磁盘上特定点的文件需要轨道号、扇区号、偏移量

**数据库表在硬盘中的组织存储形式**

假设现在有一个张 员工信息表 ，这张表有5个字段，共占用128个字节，每个块可以存储4条数据，那么存储100条数据就需要25个块



设想一下，如果我们现在需要获取某条记录，那么我们必须访问所有的25个块，以查找我们需要的数据，因为我们不知道数据存储在什么位置



那么如何可以减少我们的访问时间？

答案是索引，索引将存储表中对应记录的key和指向记录的指针



索引也存储在硬盘中



**多级指数**

在拥有更多条记录比如上千条记录时，索引的规模也就更大了，那么访问索引也将需要更多的时间，那么如何解决这个问题呢？

为索引表添加索引（稀疏索引），这就是B和B+ 树的基本思想。



## B+ 树

**B+ 树**是一种[树数据结构](https://zh.wikipedia.org/wiki/树_(数据结构))，通常用于[数据库](https://zh.wikipedia.org/wiki/数据库)和[操作系统](https://zh.wikipedia.org/wiki/操作系统)的[文件系统](https://zh.wikipedia.org/wiki/文件系统)中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素**自底向上插入**，这与[二叉树](https://zh.wikipedia.org/wiki/二叉树)恰好相反。

### 定义

![image-20211202222932829](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022229854.png)

一颗m阶B+树需要满足下列要求：

1. 每个分支节点至多有m颗子树（这里m=4）
2. 根节点或者没有子树，或者至少有两颗子树
3. 除根节点外，其他每个分支节点至少有 m/2 颗子树
4. 有 n 颗子树的节点恰好有n个关键字
5. 所有的叶子节点包含了全部关键字及指向相应记录的指针，而且叶子节点按照关键字大小顺序链接。并且将所有叶子节点链接起来。
6. 所有分支节点（可以看成时索引的索引）中仅包含它的各个子节点（即下级索引的索引块）中最大关键字及指向子节点的指针。



## 2-3-4树

### 定义 

2-3-4树是四阶的 B树(Balance Tree)，他属于一种多路查找树，它的结构有以下限制： 

- 所有叶子节点都拥有相同的深度。 
- 节点只能是 2-节点、3-节点、4-节点之一。
  - 2-节点：包含 1 个元素的节点，有 2 个子节点； 
  - 3-节点：包含 2 个元素的节点，有 3 个子节点；
  - 4-节点：包含 3 个元素的节点，有 4 个子节点； 
  - 所有节点必须至少包含1个元素
- 2-3-4 树的生长（分裂）是**自底向上**生长的
- 元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点； 而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。
- 2-3-4树是一颗完全数
- 下图是一个典型的 2-3-4树（来自维基百科）：

![2-3-4_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022252449.png)



2-3-4 树在多数编程语言中实现起来相对困难，因为在树上的操作涉及大量特殊情况。[红黑树](https://zh.wikipedia.org/wiki/红黑树)实现起来更简单一些，所以可以用它来替代。

一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树

## 红黑树

**红黑树**（英语：Red–black tree）是一种[自平衡二叉查找树](https://zh.wikipedia.org/wiki/自平衡二叉查找树)，是在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中用到的一种[数据结构](https://zh.wikipedia.org/wiki/数据结构)，典型用途是实现[关联数组](https://zh.wikipedia.org/wiki/关联数组)。

红黑树的结构复杂，但它的操作有着良好的最坏情况[运行时间](https://zh.wikipedia.org/wiki/算法分析)，并且在实践中高效：它可以在$[{\displaystyle {\text{O}}(\log n)}]$时间内完成查找、插入和删除，这里的${\displaystyle n}$是树中元素的数目。

### 性质

红黑树是每个节点都带有*颜色*属性的[二叉查找树](https://zh.wikipedia.org/wiki/二元搜尋樹)，颜色为*红色*或*黑色*。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
5. 从任一节点到其每个叶子的所有[简单路径](https://zh.wikipedia.org/wiki/道路_(图论))都包含相同数目的黑色节点。（黑色平衡）

下面是一个具体的红黑树的图例：

![Red-black_tree_example](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022255662.svg)



### 红黑树与 2-3-4树的关系

- 一个2-3-4 树 对应多个红黑树，一个红黑树对应一个2-3-4 树
- 红黑树起源于2-3-4树，它的本质就是2-3-4树
- 红黑树的叶子节点及其父节点构成了2-3-4树的叶子节点

#### 2-3-4树与红黑树的等价关系

- 2 节点

  - 只有一种对应关系，只对应红黑树中的黑色节点

    ![image-20211202232427551](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022324203.png)

- 3节点

  - 有两种对应关系，但位于上层的节点一定要是黑色节点

    ![image-20211202232537390](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022325245.png)

- 4节点

  - 只有一种对应关系，处于中间位置的节点位于上层，（中间黑，两边红）

    ![image-20211202232646005](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022326105.png)

- 裂变状态

  - （中间红，两边黑，新加入的节点为红色，但如果是根节点，仍需转变为黑色）

    ![image-20211202233104555](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112022331461.png)

#### 推理红黑树5大性质

1. **节点是红色或黑色**
   - 无需推理


2. **根是黑色**

   1. 第一种情况：2-3-4 树的根是2节点

      ![image-20211203081359030](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030814021.png)


   2. 第二种情况：2-3-4 树的根是3节点

      ![image-20211203081724578](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030817972.png)

   3. 第三种情况：2-3-4 树的根是4节点

      ![image-20211203081936381](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030819784.png)

4. **所有叶子节点都是黑色**（叶子是NIL节点，这类节点不可以忽视，否则源码会看不懂）

所有叶子节点都是null，所以无需推理

4. **每个红色节点都必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）**

   根据2-3-4树和红黑树的等价关系，可知，每个红色节点都必须有两个黑色的子节点

5. **从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点**

- 已知2-3-4树的性质：所有叶子节点都拥有相同的深度，2-3-4 树转换为红黑树后，任何一个节点都包含一个黑色节点

  ![image-20211203083529809](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112030835150.png)



### 红黑树的操作

#### 左旋和右旋

同二叉树

#### 新增操作

红黑树的新增都可以转换为2-3-4树的新增，2-3-4树的新增操作全部在叶子节点完成。

**创建头节点**

此时，不需要合并，新增的节点作为头节点，成为2节点，颜色由红色变成黑色。

![image-20211203101414301](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031014724.png)

**新增一个节点与 2 节点合并**

新增节点与2节点合并，直接合并，变为3节点

有两种情况

![image-20211203102543660](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031358886.png)



**新增一个节点 与 3 节点合并**

新增节点与3节点合并，直接合并，变为4节点

分六种情况

![image-20211203103555957](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031035015.png)



新增一个节点与 4 节点合并，此时需要分裂

新增一个节点与 4 节点合并，此时需要分裂；原来的4节点由 上黑下红 变成 上红下黑（如果是根节点还要变回黑色）

分四种情况

![image-20211203104754388](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112031047585.png)

#### 新增节点后的调整操作

 2-3-4树新增元素的四种情况：

 1. 新增根节点

    对应红黑树：调整根节点为黑色

 2. 新增一个节点与2节点合并，成为一个3节点
    对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整

 3. 新增一个节点与3节点合并，成为一个4节点
    分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
       对应红黑树：调整后上黑下红

      1. 左左左
         - 目标节点的爷爷节点右旋，目标节点的父亲节点染色为黑色，爷爷节点染色为红色
       2. 左左右
          - 对目标节点的父节点左旋，使之变为左左左的情况，同时指向目标节点的指针也应指向父节点
       3. 右右右
       4. 右右左
       5. 左中右
          - 无需调整
       6. 左中右
          - 无需调整

 4. 新增一个节点与4节点合并，此时需要裂变

    - 新增节点的插入位置有四种
    - 目标节点的爷爷节点不是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点变红
    - 目标节点的爷爷节点是根节点
      - 目标节点的父亲和叔叔节点变黑，爷爷节点不变（还是黑色）

#### 删除操作

- 红黑树的平衡是黑色平衡，只有删除的节点是黑色，才需要调整平衡
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作（当然，这个“叶子节点”可能会有左或右孩子）
- 红黑树的删除操作最终都会转换为对**“叶子节点”**的删除操作，也就是2-3-4树的叶子节点

##### 寻找继任结点

如果被删除节点的右子树不为空，返回右子树的最小节点，否则返回第一个大于被删除节点的父类节点

##### 删除操作

1. 被删除的节点是叶子节点，则直接删除
2. 被删除的节点有一个子节点，用子节点来替代
3. 被删除的节点有两个子节点，找到被删除节点的后驱节点（也可以是前驱节点）来替代
   1. 后驱节点没有右子节点的情况
   2. 后驱节点有右子节点的情况清除链接，以便 fixAfterDeletion 可以使用它们

##### 删除后的调整

- 红黑树的删除操作最终都会转换为对 2-3-4树 的叶子节点的删除操作
- 2-3-4数 是一颗满树

对于 3节点和4节点，删除一个叶子节点元素后，仍然满足2-3-4树定义；

对于2节点，删除一个叶子节点元素后无法满足2-3-4树定义

![image-20211204100244379](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041012800.png)



对应 红黑树：

1. 对于 3节点和4节点，删除一个叶子节点元素后，可以通过自我调整满足红黑树定义
2. 对于2节点，删除一个叶子节点元素后，需要进行平衡性调整

##### 调整思路

![image-20211204103528763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041035015.png)

- ”自己搞不定“

  - 对于2节点的删除：需要调整平衡性，以被删除的节点是左孩子节点为例：

    - 如果被删除节点的父节点的右节点是红色，则这个右节点不是被删除节点的兄弟节点（证明它是2-3-4树中的父节点）

      ​	![image-20211204174339812](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041743436.png)

    - 对于被删除节点的父节点的右节点是红色的情况，将父节点左旋一次，根据2-3-4树性质，父节点的右节点必有左右孩子节点，所以左旋后右节点的左节点成为父节点的右节点（也就是真正的兄弟节点）；将父节点染红，父节点的原右节点染黑

      ![image-20211204174623434](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041746163.png)

    - 此时有两种情况：①兄弟节点有的借（是2节点 ）

      ​								②兄弟节点没的借（是3节点或4节点）

    - 对于兄弟节点有的借的情况：被删除节点找父亲节点借，父亲节点空缺用兄弟节点补上

      1. 如果兄弟节点是3节点，也分两种情况：

         - 第一种情况：兄弟节点左子树为空
         - 第二种情况：兄弟节点右子树为空

         对于第二种情况先转换成第一种情况，然后按照第一种情况统一处理

         ![image-20211204180205763](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041802581.png)

         ![image-20211204180257855](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112041803311.png)

      2. 如果兄弟节点是4节点：

         - 此时有两种处理办法：

           第一种办法：把父亲节点和兄弟节点的左孩子都借给被删除节点（需要旋转两次）

           第二种办法：只借父亲节点给被删除节点（需要旋转一次）

           ![image-20211204200655011](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/12/202112042006697.png)

    - 对于兄弟节点没得借的情况：

      - (有难同当)兄弟节点染红，递归处理

- ”自己能搞定“

  - 对于3节点的删除：可以自我调整的删除（比如删除 7.5，则无需调整；删除7，则会用 7.5 代替，即把 7.5 染黑）
  - 对于4节点的删除：不存在删除 4节点中 黑色节点的情况（其实对4节点的删除就是对3节点的删除，个人理解）

#### 代码实现

```java
package zs.order_list;


/**
 * @author miemiehoho
 * @date 2021/12/3 9:09
 */
public class RedBlackTree<K extends Comparable<K>, V> {


    public RedBlackNode<K, V> root;

    /**
     * 左旋
     *
     * @param node
     */
    private void rotateLeft(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.right;
            node.right = newNode.left;
            if (newNode.left != null) {
                newNode.left.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.left = node;
            node.parent = newNode;
        }
    }


    /**
     * 右旋
     *
     * @param node
     * @return
     */
    private void rotateRight(RedBlackNode<K, V> node) {
        if (node != null) {
            RedBlackNode<K, V> newNode = node.left;
            node.left = newNode.right;
            if (newNode.right != null) {
                newNode.right.parent = node;
            }
            newNode.parent = node.parent;
            if (node.parent == null) {
                root = newNode;
            } else if (node.parent.left == node) {
                node.parent.left = newNode;
            } else {
                node.parent.right = newNode;
            }
            newNode.right = node;
            node.parent = newNode;
        }
    }


    /**
     * 对外提供的新增节点操作
     *
     * @param key
     * @param value
     */
    public void put(K key, V value) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> t = root;
        if (t == null) {
            root = new RedBlackNode<>(key, value, null);
            return;
        }
        RedBlackNode<K, V> parent;
        int cmp;
        do {
            parent = t;
            cmp = key.compareTo(t.key);
            if (cmp < 0) {
                t = t.left;
            } else if (cmp > 0) {
                t = t.right;
            } else {
                t.setValue(value);
                return;
            }
        } while (t != null);

        RedBlackNode<K, V> newNode = new RedBlackNode<>(key, value, parent);
        if (cmp < 0) {
            parent.left = newNode;
        } else {
            parent.right = newNode;
        }
        fixAfterInsertion(newNode);
    }

    public V remove(K key) {
        RedBlackNode<K, V> node = getNode(key);
        if (node == null) {
            return null;
        }
        V oldValue = node.value;
        deleteNode(node);
        return oldValue;
    }

    // 删除节点node，然后重新平衡树
    private void deleteNode(RedBlackNode<K, V> node) {
        if (node.left != null && node.right != null) {
            RedBlackNode<K, V> successor = preSuccessor(node);
            node.key = successor.key;
            node.value = successor.value;
            node = successor;// 指向新的被删除节点（后继结点）
        }

        // 我的理解：
        // 1. 对于有左右子节点的情况：这样写是为了拿到后继结点的右子节点
        // 2. 对于只有左子树或右子树的情况，可以兼容
        RedBlackNode<K, V> replacement = node.left != null ? node.left : node.right;

        if (replacement != null) {
            replacement.parent = node.parent;
            if (node.parent == null) {// 被删除节点只有左子树或右子树，且被删除节点是根节点
                root = replacement;
            } else if (node == node.parent.left) {// 被删除节点有左右子树或者只有左或右子树三种情况下，repalcement的归属
                node.parent.left = replacement;
            } else {
                node.parent.right = replacement;
            }
            // 释放链接-源码注释为：清除链接，以便 fixAfterDeletion 可以使用它们
            node.left = node.right = node.parent = null;
            // 从 replacement 节点开始进行平衡性调整
            if (node.color == BLACK) {
                //replacement节点一定是红色
                fixAfterDeletion(replacement);
            }
        } else if (node.parent == null) {// 删除的是根节点
            root = null;
        } else {// 被删除节点是叶子节点，没有孩子节点，使用自己代替自己，并删除
            if (node.color == BLACK) {
                fixAfterDeletion(node);
            }

            if (node.parent != null) {// 存疑
                if (node == node.parent.left) {
                    node.parent.left = null;
                } else {
                    node.parent.right = null;
                }
                node.parent = null;
            }
        }
    }


    /**
     * 从替代节点位置开始调整
     *
     * @param node
     */
    private void fixAfterDeletion(RedBlackNode<K, V> node) {
        while (node != root && colorOf(node) == BLACK) {// 被删除的是2节点
            if (node == leftOf(parentOf(node))) {// 被删除的是左节点

                RedBlackNode<K, V> right = rightOf(parentOf(node));// 兄弟节点
                if (colorOf(right) == RED) {// 如果兄弟节点是红色，说明它不是真正的兄弟节点，而是兄弟节点的父节点
                    // 把兄弟节点染黑，父节点染红，然后父节点左旋
                    setColor(right, BLACK);
                    setColor(parentOf(right), RED);
                    rotateLeft(parentOf(node));
                    right = rightOf(parentOf(node));// 指向真的兄弟节点
                }

                // 找兄弟借，兄弟没得借
                if (colorOf(leftOf(right)) == BLACK && colorOf(rightOf(right)) == BLACK) {
                    setColor(right, RED);
                    node = parentOf(node);// 递归处理
                } else {// 找兄弟借，兄弟有的借
                    // 两种小情况：1.兄弟节点是三节点或四节点
                    if (colorOf(rightOf(right)) == BLACK) {// 兄弟节点的右孩子为空
                        setColor(leftOf(right), BLACK);
                        setColor(right, RED);
                        rotateRight(right);
                        right = rightOf(parentOf(node));
                    }
                    // 对于兄弟节点是四节点的情况，这里用了只旋转一次的方法（还有一种旋转两次的方法）
                    // 还兼顾了三节点的情况：对于三节点，右孩子为空的转化为左孩子为空的情况（也就是上面的if方法）
                    // 实在是妙！
                    setColor(right, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(rightOf(right), BLACK);
                    rotateLeft(parentOf(node));
                    node = root;
                }
            } else {// 被删除的是右节点
                RedBlackNode<K, V> left = leftOf(parentOf(node));
                if (colorOf(left) == RED) {// 父节点右旋，找到真正的兄弟节点
                    setColor(left, BLACK);
                    setColor(parentOf(node), RED);
                    rotateRight(parentOf(node));
                    left = leftOf(parentOf(node));
                }

                if (colorOf(left.left) == BLACK && colorOf(left.right) == BLACK) {// 兄弟节点没得借
                    setColor(left, RED);
                    node = parentOf(node);
                } else {
                    if (colorOf(leftOf(left)) == BLACK) {
                        setColor(rightOf(left), BLACK);
                        setColor(left, RED);
                        rotateLeft(left);
                        left = leftOf(parentOf(node));
                    }
                    setColor(left, colorOf(parentOf(node)));
                    setColor(parentOf(node), BLACK);
                    setColor(leftOf(left), BLACK);
                    rotateRight(parentOf(node));
                    node = root;
                }
            }
        }
        // 对于2节点，兄弟没得借的情况，递归到根节点，把根节点染黑
        // 对于3、4节点直接染黑，补偿被删除的黑色节点
        setColor(node, BLACK);
    }

    private RedBlackNode<K, V> getNode(K key) {
        if (key == null) {
            throw new NullPointerException();
        }
        RedBlackNode<K, V> cur = root;
        while (cur != null) {
            int cmp = key.compareTo(cur.key);
            if (cmp < 0) {
                cur = cur.left;
            } else if (cmp > 0) {
                cur = cur.right;
            } else {
                return cur;
            }
        }
        return null;
    }

    /**
     * 返回目标节点的后继节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> successor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.right != null) {
            RedBlackNode<K, V> p = node.right;
            while (p.left != null) {
                p = p.left;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 返回目标节点的前驱节点，找不到就返回null
     *
     * @param node
     * @return
     */
    private RedBlackNode<K, V> preSuccessor(RedBlackNode<K, V> node) {
        if (node == null) {
            return null;
        }
        if (node.left != null) {
            RedBlackNode<K, V> p = node.left;
            while (p.right != null) {
                p = p.right;
            }
            return p;
        } else {
            RedBlackNode<K, V> p = node.parent;
            RedBlackNode<K, V> ch = node;
            while (p != null && ch == p.left) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }

    /**
     * 2-3-4树新增元素的四种情况：
     * 1. 新增根节点
     * 2. 新增一个节点与2节点合并，成为一个3节点
     * 对应红黑树：原节点（黑节点）新增一个红色子节点，上黑下红，这种情况无需调整
     * 3. 新增一个节点与3节点合并，成为一个4节点
     * 分为6种情况：左左左、左左右、右右右、右右左、左中右（无需调整）、左中右（无需调整）
     * 对应红黑树：调整后上黑下红
     *
     * @param node
     */
    private void fixAfterInsertion(RedBlackNode<K, V> node) {
        node.color = RED;
        // 父节点是黑色的不需要调整
        while (node != null && node != root && node.parent.color == RED) {
            // n爹 = n爹的爹的左孩子：左左左/左左右
            if (parentOf(node) == leftOf(parentOf(parentOf(node)))) {
                RedBlackNode<K, V> y = rightOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在4节点上新增节点的情况
                    setColor(parentOf(node), BLACK);
                    setColor(y, BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == rightOf(parentOf(node))) {// 左左右转换为左左左
                        node = parentOf(node);// 注意这里，node指针指向也要变
                        rotateLeft(parentOf(node));
                    }
                    // 左左左
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateRight(parentOf(parentOf(node)));
                }
            } else {//右右右/右右左
                RedBlackNode<K, V> y = leftOf(parentOf(parentOf(node)));
                if (colorOf(y) == RED) {// 在四节点上新增节点的情况
                    setColor(y, BLACK);
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    node = parentOf(parentOf(node));
                } else {// 在3节点上新增节点
                    if (node == leftOf(parentOf(node))) {
                        node = parentOf(node);
                        rotateRight(node);
                    }
                    setColor(parentOf(node), BLACK);
                    setColor(parentOf(parentOf(node)), RED);
                    rotateLeft(parentOf(parentOf(node)));
                }
            }
        }
        root.color = BLACK;
    }

    private void setColor(RedBlackNode<K, V> node, boolean c) {
        if (node != null) {
            node.color = c;
        }
    }

    private boolean colorOf(RedBlackNode<K, V> node) {
        return node == null ? BLACK : node.color;// node为null则返回nil节点
    }

    private RedBlackNode<K, V> parentOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.parent;
    }

    private RedBlackNode<K, V> leftOf(RedBlackNode<K, V> node) {
        return node == null ? null : node.left;
    }

    private RedBlackNode<K, V> rightOf(RedBlackNode node) {
        return node == null ? null : node.right;
    }

    private static final boolean RED = false;
    private static final boolean BLACK = true;

    // 静态内部类
    static final class RedBlackNode<K extends Comparable<K>, V> {
        K key;
        V value;
        RedBlackNode<K, V> parent;
        RedBlackNode<K, V> left;

        public RedBlackNode<K, V> getLeft() {
            return left;
        }

        public RedBlackNode<K, V> getRight() {
            return right;
        }

        public boolean isColor() {
            return color;
        }

        RedBlackNode<K, V> right;
        boolean color = BLACK;


        public RedBlackNode(K key, V value, RedBlackNode<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public void setValue(V value) {
            this.value = value;
        }

    }


}
```