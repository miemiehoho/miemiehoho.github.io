#### [å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

é¢ï¼Œé”™è¯¯çš„é¢˜è§£ï¼Œè‡ªå·±æƒ³çš„ğŸ¥²

```java
// å…ˆæŒ‰ä¸ªä½æ•°å¤§å°ä»å°åˆ°å¤§æ’åºï¼Œæœ‰é«˜ä½çš„å†ç”¨é«˜ä½æ’åº
public String minNumber(int[] nums) {
    int max = -1;// numsä¸­æœ€å¤§çš„æ•°
    for (int i = 0; i < nums.length; i++) {// é¦–å…ˆéå†ä¸€æ¬¡ï¼Œæ‰¾å‡ºæœ€å¤§çš„æ•°
        max = Math.max(nums[i], max);
    }
    int x = 0;// numsä¸­æœ€å¤§çš„æ•°æ˜¯å‡ ä½
    while (max != 0) {
        max /= 10;
        x++;
    }
    int m = 1;
    while (x-- > 0) {
        m *= 10;
        for (int i = nums.length - 1; i >= 0; i--) {
            for (int j = 0; j < i; j++) {
                int a = val(nums[j], m);
                int b = val(nums[j + 1], m);
                if (a > b) {// å¦‚æœaçš„xä½å¤§äºbï¼Œåˆ™äº¤æ¢
                    swap(nums, j, j + 1);
                } else if (a == b) {
                    if (Long.valueOf(nums[j] + "" + nums[j + 1]) > Long.valueOf(nums[j + 1] + "" + nums[j])) {
                        swap(nums, j, j + 1);
                    }
                }
            }
        }
    }
    StringBuilder sb = new StringBuilder();
    for (int num : nums) {
        sb.append(num);
    }
    return sb.toString();
}

private int val(int num, int m) {
    if (num >= m) {
        num %= m;
    }
    while (num >= 10) {
        num /= 10;
    }
    return num;
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

##### â­æ­£ç¡®çš„é¢˜è§£

* è¿™é“é¢˜æœ€ç›´æ¥çš„è§£æ³•å°±æ˜¯å…ˆæ±‚æ•°ç»„ä¸­æ‰€æœ‰æ•°å­—çš„å…¨æ’åˆ—ï¼Œç„¶åæŠŠæ¯ä¸ªæ’åˆ—æ‹¼æ¥èµ·æ¥ï¼Œæœ€åæ±‚æ‹¼èµ·æ¥çš„æ’åˆ—ä¸­çš„æœ€å°å€¼
* æ€è·¯ï¼š
  * è¿™é“é¢˜å®é™…æ˜¯å¸Œæœ›æˆ‘ä»¬èƒ½å¤Ÿæ‰¾åˆ°ä¸€ä¸ªæ’åºè§„åˆ™ï¼šå¦‚æœ: mn>nm,åˆ™ç­”æ¡ˆå°±åº”è¯¥æ˜¯nm
  * æ¥ä¸‹æ¥å°±æ˜¯æ€è€ƒå¦‚ä½•æ‹¼æ¥æ•°å­—çš„é—®é¢˜äº†ï¼Œmå’Œnéƒ½æ˜¯intç±»å‹ï¼Œä½†æ˜¯æ‹¼æ¥èµ·æ¥çš„mnå’Œnmå¯èƒ½ä¼šæº¢å‡º
  * ä¸€ä¸ªéå¸¸ç›´è§‚çš„è§£å†³å¤§æ•°çš„é—®é¢˜çš„æ–¹æ³•å°±æ˜¯æŠŠæ•°å­—è½¬æ¢æˆå­—ç¬¦ä¸²ï¼Œç”±äºmnå’Œnmé•¿åº¦è‚¯å®šæ˜¯ç›¸åŒçš„ï¼Œå› æ­¤åªéœ€è¦æŒ‰ç…§å­—ç¬¦ä¸²å¤§å°çš„æ¯”è¾ƒè§„åˆ™å»æ¯”è¾ƒä»–ä»¬çš„å¤§å°å°±å¯ä»¥äº†

```java
/**
 * å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°
 * <p>
 * å†’æ³¡æ’åº
 *
 * @param nums
 * @return
 */
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];
    for (int i = 0; i < strs.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    for (int i = strs.length - 1; i >= 0; i--) {
        boolean isSorted = false;
        for (int j = 0; j < i; j++) {
            String mn = strs[j] + strs[j + 1];
            String nm = strs[j + 1] + strs[j];
            if (mn.compareTo(nm) > 0) {
                swap(strs, j, j + 1);
                isSorted = true;
            }
        }
        if (!isSorted) {
            break;
        }
    }
    StringBuilder sb = new StringBuilder();
    for (String str : strs) {
        sb.append(str);
    }
    return sb.toString();
}

private void swap(String[] strs, int i, int j) {
    String temp = strs[j];
    strs[j] = strs[i];
    strs[i] = temp;
}
```

```java
/**
 * å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°
 * <p>
 * ç›´æ¥æ’å…¥æ’åº
 *
 * @param nums
 * @return
 */
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];
    for (int i = 0; i < strs.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    for (int i = 1; i < strs.length; i++) {
        String temp = strs[i];
        for (int j = i; j >= 0; j--) {
            if (j > 0 && (strs[j - 1] + temp).compareTo(temp + strs[j - 1]) > 0) {
                strs[j] = strs[j - 1];
            } else {
                strs[j] = temp;
                break;
            }
        }
    }
    StringBuilder sb = new StringBuilder();
    for (String str : strs) {
        sb.append(str);
    }
    return sb.toString();
}
```

```java
/**
 * å‰‘æŒ‡ Offer 45. æŠŠæ•°ç»„æ’æˆæœ€å°çš„æ•°
 * <p>
 * å¸Œå°”æ’åº
 *
 * @param nums
 * @return
 */
public String minNumber(int[] nums) {
    String[] strs = new String[nums.length];
    for (int i = 0; i < strs.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    int len = strs.length;
    String temp;
    for (int step = len / 2; step >= 1; step /= 2) {// æ­¥é•¿,ä¸æ–­ç¼©å‡ç›´åˆ°1ä¸ºæ­¢
        // å¯¹æ‰€æœ‰åˆ—è¿›è¡Œç›´æ¥æ’å…¥æ’åºï¼Œé€è¡Œæ’åº
        for (int i = step; i < len; i++) {//å½“å‰æ­¥é•¿ä¸‹ï¼Œå½“å‰æ’åºæ¬¡æ•°ä¸‹ï¼Œæ‰€æœ‰åˆ—çš„å¾…æ’åºå…ƒç´ ä¸‹æ ‡
            temp = strs[i];//å½“å‰éœ€è¦æ’åºçš„å…ƒç´ 
            int j = i - step;//å¾…æ’åºå…ƒç´ çš„å‰ä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
            while (j >= 0 && (strs[j] + temp).compareTo(temp + strs[j]) > 0) {
                strs[j + step] = strs[j];//å¡«å‘
                j -= step;
            }
            strs[j + step] = temp;
        }
    }
    StringBuilder sb = new StringBuilder();
    for (String str : strs) {
        sb.append(str);
    }
    return sb.toString();
}
```

#### [283. ç§»åŠ¨é›¶](https://leetcode-cn.com/problems/move-zeroes/)

```java
/**
 * å†’æ³¡ä¼˜åŒ–
 *
 * @param nums
 */
public void moveZeroes(int[] nums) {
    for (int i = nums.length - 1; i >= 0; i--) {
        boolean isSorted = false;
        for (int j = 0; j < i; j++) {
            if (nums[j] == 0 && nums[j + 1] != 0) {
                swap(nums, j, j + 1);
                isSorted = true;
            }
        }
        if (!isSorted) {
            break;
        }
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[j];
    nums[j] = nums[i];
    nums[i] = temp;
}
```

```java
/**
 * å†’æ³¡å†ä¼˜åŒ–
 *
 * @param nums
 */
public void moveZeroes(int[] nums) {
    boolean isSorted = true;
    int sortedIdx = -1;
    int lastUnSortedIdx = nums.length - 1;
    while (isSorted) {
        isSorted = false;
        for (int i = 0; i < lastUnSortedIdx; i++) {
            if (nums[i] == 0 && nums[i + 1] != 0) {
                swap(nums, i, i + 1);
                sortedIdx = i;
                isSorted = true;
            }
        }
        lastUnSortedIdx = sortedIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[j];
    nums[j] = nums[i];
    nums[i] = temp;
}
```

```java
/**
 * åŒæŒ‡é’ˆ
 *
 * @param nums
 */
public void moveZeroes(int[] nums) {
    if (nums == null || nums.length == 0) {
        return;
    }
    int l = 0, r = 0;
    while (r < nums.length) {
        if (nums[r] != 0) {
            int temp = nums[r];
            nums[r] = 0;
            nums[l++] = temp;
        }
        r++;
    }
}
```



#### [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```java
// é€‰æ‹©æ’åº
public int findKthLargest(int[] nums, int k) {
    for (int i = 0; i < k; i++) {
        int maxIdx = i;
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[j] > nums[maxIdx]) {
                maxIdx = j;
            }
        }
        swap(nums, i, maxIdx);
    }
    return nums[k - 1];
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[j];
    nums[j] = nums[i];
    nums[i] = temp;
}
```

#### [912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)

```java
public int[] sortArray(int[] nums) {
    for (int i = 0; i < nums.length / 2; i++) {
        int minIdx = i;
        int maxIdx = i;
        for (int j = i + 1; j < nums.length - i; j++) {
            if (nums[j] < nums[minIdx]) {
                minIdx = j;
            }
            if (nums[j] > nums[maxIdx]) {
                maxIdx = j;
            }
        }
        if (minIdx == maxIdx) {
            break;
        }
        swap(nums, i, minIdx);
        if (maxIdx == i) {
            maxIdx = minIdx;
        }
        swap(nums, nums.length - i - 1, maxIdx);
    }
    return nums;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[j];
    nums[j] = nums[i];
    nums[i] = temp;
}
```

```java
public int[] sortArray(int[] nums) {
    Arrays.sort(nums);
    return nums;
}
```

```java
// ç›´æ¥æ’å…¥æ’åº-ç§»åŠ¨æ³•
public int[] sortArray(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        int temp = nums[i];
        for (int j = i; j >= 0; j--) {
            if (j > 0 && nums[j - 1] > temp) {
                nums[j] = nums[j - 1];
            } else {
                nums[j] = temp;
                break;
            }
        }
    }
    return nums;
}
```

```java
// ç›´æ¥æ’å…¥æ’åº-äº¤æ¢æ³•
public int[] sortArray(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        for (int j = i; j > 0; j--) {
            if (nums[j] < nums[j - 1]) {
                swap(nums, j, j - 1);
            } else {
                break;
            }
        }
    }
    return nums;
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[j];
    nums[j] = nums[i];
    nums[i] = temp;
}
```

```java
// å¸Œå°”æ’åº
public int[] sortArray(int[] nums) {
    int len = nums.length;
    for (int step = len / 2; step >= 1; step /= 2) {// æ­¥é•¿ï¼Œä¸æ–­ç¼©å‡ç›´åˆ°1
        for (int i = step; i < nums.length; i++) {// å¾…æ’åºåˆ—çš„ç¬¬äºŒä¸ªå…ƒç´ ä¸‹æ ‡
            int cur = nums[i];//å¾…æ’åºæ•°å­—
            int idx = i - step;
            while (idx >= 0 && nums[idx] > cur) {
                nums[idx + step] = nums[idx];
                idx -= step;
            }
            nums[idx + step] = cur;
        }
    }
    return nums;
}
```

#### [147. å¯¹é“¾è¡¨è¿›è¡Œæ’å…¥æ’åº](https://leetcode-cn.com/problems/insertion-sort-list/)

â­

```java
public ListNode insertionSortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode dummy = new ListNode();//å“‘èŠ‚ç‚¹
    dummy.next = head;
    ListNode cur = head.next;//éœ€è¦æ’åºçš„èŠ‚ç‚¹
    ListNode lastSorted = head;//å·²æ’åºé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
    while (cur != null) {
        if (cur.val >= lastSorted.val) {//å¦‚æœå¾…æ’å…¥èŠ‚ç‚¹å¤§äºå·²æ’åºé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç›´æ¥å°¾æ’å…¥ ç­‰äºå·ä¸èƒ½å»æ‰ï¼Œå¦åˆ™ä¼šå½±å“ç¨³å®šæ€§
            lastSorted = lastSorted.next;
        } else {
            ListNode pre = dummy;//ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†å·²æ’åºé“¾è¡¨ï¼Œå¯»æ‰¾æ’å…¥ä½ç½®
            while (pre.next.val <= cur.val) {// ç­‰äºå·ä¸èƒ½å»æ‰ï¼Œå¦åˆ™ä¼šå½±å“ç¨³å®šæ€§
                pre = pre.next;
            }
            lastSorted.next = cur.next;//ä¿å­˜curçš„nextèŠ‚ç‚¹
            cur.next = pre.next;//æ’å…¥curèŠ‚ç‚¹
            pre.next = cur;
        }
        cur = lastSorted.next;
    }
    return dummy.next;
}
```

#### [506. ç›¸å¯¹åæ¬¡](https://leetcode-cn.com/problems/relative-ranks/)

```java
public String[] findRelativeRanks(int[] score) {
    Map<Integer, Integer> map = new HashMap<>();
    int len = score.length;
    for (int i = 0; i < len; i++) {
        map.put(score[i], i);
    }
    int kunth = 1;
    while (kunth <= len / 3) {
        kunth = kunth * 3 + 1;
    }
    for (int step = kunth; step >= 1; step = (step - 1) / 3) {
        for (int i = step; i < len; i++) {
            int cur = score[i];
            int preIdx = i - step;
            while (preIdx >= 0 && score[preIdx] <= cur) {
                score[preIdx + step] = score[preIdx];
                preIdx -= step;
            }
            score[preIdx + step] = cur;
        }
    }
    String[] res = new String[len];
    String[] rewards = new String[]{"Gold Medal", "Silver Medal", "Bronze Medal"};
    for (int i = 0; i < len; i++) {
        res[map.get(score[i])] = String.valueOf(i + 1);
    }
    for (int i = 0; i < 3 && i < len; i++) {
        res[map.get(score[i])] = rewards[i];
    }
    return res;
}
```

#### [215. æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

```java
// æœ€å¤§å †
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>((v1, v2) -> v2 - v1);
    for (int num : nums) {
        heap.add(num);
    }
    for (int i = 0; i < k - 1; i++) {
        heap.remove();
    }
    return heap.remove();
}
```

```java
// æœ€å°å †
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    for (int num : nums) {
        if (heap.size() < k) {
            heap.add(num);
        } else if (num > heap.peek()) {
            heap.poll();
            heap.add(num);
        }
    }
    return heap.peek();
}
```

```java
// å¤§é¡¶å †
public int findKthLargest(int[] nums, int k) {
    int length = nums.length;
    // åˆå§‹åŒ–å¤§é¡¶å †,ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹
    for (int i = nums.length / 2 - 1; i >= 0; i--) {
        maxHeapify(nums, i, length);
    }
    // è°ƒæ•´kæ¬¡å¤§é¡¶å †ï¼Œæ¯æ¬¡æŠŠå †é¡¶å…ƒç´ ä¸å †å°¾å…ƒç´ äº’æ¢ï¼ŒåŒæ—¶å †é•¿åº¦å‡ä¸€
    for (int i = nums.length - 1; i > nums.length - k; i--) {
        swap(nums, 0, i);
        maxHeapify(nums, 0, i);
    }
    return nums[0];
}

/**
 * è°ƒæ•´å¤§é¡¶å †
 *
 * @param nums
 * @param i
 * @param heapSize
 */
private void maxHeapify(int[] nums, int i, int heapSize) {
    while (i < heapSize / 2) {// åˆ¤æ–­å¾…è°ƒæ•´èŠ‚ç‚¹æ˜¯å¦å¶å­èŠ‚ç‚¹
        int left = i * 2 + 1;// å·¦å­èŠ‚ç‚¹
        int right = left + 1;// å³å­èŠ‚ç‚¹
        int maxIdx = left;// é»˜è®¤å·¦å­èŠ‚ç‚¹ä¸ºæœ€å¤§èŠ‚ç‚¹
        if (right < heapSize && nums[right] > nums[maxIdx]) {
            maxIdx = right;
        }
        if (nums[i] > nums[maxIdx]) {
            break;// å¾…è°ƒæ•´èŠ‚ç‚¹ä¸ºæœ€å¤§èŠ‚ç‚¹ï¼Œç›´æ¥è·³å‡º
        }
        swap(nums, i, maxIdx);
        i = maxIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### [å‰‘æŒ‡ Offer 40. æœ€å°çš„kä¸ªæ•°](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```java
public int[] getLeastNumbers(int[] arr, int k) {
    if (k <= 0) {
        return new int[0];
    }
    PriorityQueue<Integer> heap = new PriorityQueue<>((v1, v2) -> v2 - v1);
    for (int a : arr) {
        if (heap.size() < k) {
            heap.add(a);
        } else if (a < heap.peek()) {
            heap.poll();
            heap.add(a);
        }
    }
    Iterator<Integer> iterator = heap.iterator();
    int[] res = new int[k];
    int i = 0;
    while (iterator.hasNext()) {
        res[i++] = iterator.next();
        if (i == k) {
            break;
        }
    }
    return res;
}
```

```java
public int[] getLeastNumbers(int[] arr, int k) {
    Arrays.sort(arr);
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = arr[i];
    }
    return res;
}
```

```java
public int[] getLeastNumbers(int[] arr, int k) {
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        minHeapify(arr, i, arr.length);
    }
    for (int i = arr.length - 1; i >= arr.length - k; i--) {
        swap(arr, 0, i);
        minHeapify(arr, 0, i);
    }
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = arr[arr.length - 1 - i];
    }
    return res;
}

/**
 * è°ƒæ•´å°é¡¶å †
 *
 * @param nums
 * @param i
 * @param heapSize
 */
private void minHeapify(int[] nums, int i, int heapSize) {
    while (i < heapSize / 2) {
        int left = i * 2 + 1;
        int right = left + 1;
        int minIdx = left;
        if (right < heapSize && nums[right] < nums[minIdx]) {
            minIdx = right;
        }
        if (nums[i] <= nums[minIdx]) {
            break;
        }
        swap(nums, i, minIdx);
        i = minIdx;
    }
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### [912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)

```java
public int[] sortArray(int[] nums) {
    quickSort(nums);
    return nums;
}

// å¿«é€Ÿæ’åºé€’å½’å®ç°
public void quickSort(int[] nums) {
    if (nums.length <= 1) {
        return;
    }
    partition(nums, 0, nums.length - 1);
}

private void partition(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }
    Random rand = new Random();
    int p = rand.nextInt(end - start + 1) + start;
    swap(nums, start, p);
    int pivot = nums[start];
    int l = start, r = end + 1;
    while (l < r) {
        while (++l <= end && nums[l] < pivot) ;
        while (--r >= start && nums[r] > pivot) ;
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, r);
    partition(nums, start, r - 1);
    partition(nums, r + 1, end);
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }
}
```

#### [169. å¤šæ•°å…ƒç´ ](https://leetcode-cn.com/problems/majority-element/)

å¿«æ’

```java
public int majorityElement(int[] nums) {
    quickSort(nums);
    return nums[nums.length / 2];
}

public void quickSort(int[] nums) {
    if (nums.length <= 1) {
        return;
    }
    partition(nums, 0, nums.length - 1);
}

private void partition(int[] nums, int start, int end) {
    if (start >= end) {
        return;
    }
    int p = new Random().nextInt(end - start + 1) + start;
    swap(nums, start, p);
    int pivot = nums[start];
    int l = start, r = end + 1;
    while (l < r) {
        while (++l <= end && nums[l] < pivot) ;
        while (--r >= start && nums[r] > pivot) ;
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, r);
    partition(nums, start, r - 1);
    partition(nums, r + 1, end);
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }

}
```

##### â­å¿«æ’å˜å½¢-å¿«åˆ‡

```java
public int majorityElement(int[] nums) {
    return quickSearch(nums, 0, nums.length - 1, nums.length / 2);
}

public int quickSearch(int[] nums, int start, int end, int k) {
    int j = partition(nums, start, end);
    if (j == k) {
        return nums[j];
    }
    return j > k ? quickSearch(nums, start, j - 1, k) : quickSearch(nums, j + 1, end, k);
}

private int partition(int[] nums, int start, int end) {
    int p = new Random().nextInt(end - start + 1) + start;
    swap(nums, start, p);
    int pivot = nums[start];
    int l = start, r = end + 1;
    while (l < r) {
        while (++l <= end && nums[l] < pivot) ;
        while (--r >= start && nums[r] > pivot) ;
        if (l < r) {
            swap(nums, l, r);
        }
    }
    swap(nums, start, r);
    return r;
}

private void swap(int[] nums, int i, int j) {
    if (nums[i] != nums[j]) {
        nums[j] ^= nums[i];
        nums[i] ^= nums[j];
        nums[j] ^= nums[i];
    }

}
```

```java
public int majorityElement(int[] nums) {
    Arrays.sort(nums);
    return nums[nums.length / 2];
}
```

##### â­æ‘©å°”æŠ•ç¥¨æ³•

å€™é€‰äºº(cand_num)åˆå§‹åŒ–ä¸ºnums[0]ï¼Œç¥¨æ•°countåˆå§‹åŒ–ä¸º1ã€‚
å½“é‡åˆ°ä¸cand_numç›¸åŒçš„æ•°ï¼Œåˆ™ç¥¨æ•°count = count + 1ï¼Œå¦åˆ™ç¥¨æ•°count = count - 1ã€‚
å½“ç¥¨æ•°countä¸º0æ—¶ï¼Œæ›´æ¢å€™é€‰äººï¼Œå¹¶å°†ç¥¨æ•°counté‡ç½®ä¸º1ã€‚
éå†å®Œæ•°ç»„åï¼Œcand_numå³ä¸ºæœ€ç»ˆç­”æ¡ˆã€‚

ä¸ºä½•è¿™è¡Œå¾—é€šå‘¢ï¼Ÿ
æŠ•ç¥¨æ³•æ˜¯é‡åˆ°ç›¸åŒçš„åˆ™ç¥¨æ•° + 1ï¼Œé‡åˆ°ä¸åŒçš„åˆ™ç¥¨æ•° - 1ã€‚
ä¸”â€œå¤šæ•°å…ƒç´ â€çš„ä¸ªæ•° > n/2 ï¼Œå…¶ä½™å…ƒç´ çš„ä¸ªæ•°æ€»å’Œ <=  n/2 ã€‚
å› æ­¤â€œå¤šæ•°å…ƒç´ â€çš„ä¸ªæ•° - å…¶ä½™å…ƒç´ çš„ä¸ªæ•°æ€»å’Œ çš„ç»“æœ è‚¯å®š >= 1ã€‚
è¿™å°±ç›¸å½“äºæ¯ä¸ªâ€œå¤šæ•°å…ƒç´ â€å’Œå…¶ä»–å…ƒç´  ä¸¤ä¸¤ç›¸äº’æŠµæ¶ˆï¼ŒæŠµæ¶ˆåˆ°æœ€åè‚¯å®šè¿˜å‰©ä½™è‡³å°‘1ä¸ªâ€œå¤šæ•°å…ƒç´ â€ã€‚

æ— è®ºæ•°ç»„æ˜¯1 2 1 2 1ï¼Œäº¦æˆ–æ˜¯1 2 2 1 1ï¼Œæ€»èƒ½å¾—åˆ°æ­£ç¡®çš„å€™é€‰äººã€‚

```java
public int majorityElement(int[] nums) {
    int cand_num = nums[0], count = 1;
    for (int i = 1; i < nums.length; i++) {
        if (cand_num == nums[i]) {
            count++;
        } else if (--count == 0) {
            cand_num = nums[i];
            count = 1;
        }
    }
    return cand_num;
}
```

#### [é¢è¯•é¢˜ 10.01. åˆå¹¶æ’åºçš„æ•°ç»„](https://leetcode-cn.com/problems/sorted-merge-lcci/)

å½’å¹¶æ’åºï¼ˆæ­£å‘åŒæŒ‡é’ˆï¼‰

```java
// å½’å¹¶æ’åºï¼ˆæ­£å‘åŒæŒ‡é’ˆï¼‰
public void merge(int[] A, int m, int[] B, int n) {
    int[] result = new int[A.length];
    int start1 = 0, start2 = 0;
    int idx = 0;// ç»“æœæ•°ç»„æŒ‡é’ˆ
    while (start1 < m && start2 < n) {
        if (A[start1] <= B[start2]) {
            result[idx++] = A[start1++];
        } else {
            result[idx++] = B[start2++];
        }
    }
    // åˆå¹¶å‰©ä½™æ•°ç»„
    while (start1 < m) {
        result[idx++] = A[start1++];
    }
    while (start2 < n) {
        result[idx++] = B[start2++];
    }
    // å°†ç»“æœå¤åˆ¶åˆ°A
    for (int i = 0; i < A.length; i++) {
        A[i] = result[i];
    }
}
```

##### â­é€†å‘åŒæŒ‡é’ˆ

```java
    public void merge(int[] A, int m, int[] B, int n) {
        int start1 = m - 1, start2 = n - 1;
        int idx = A.length - 1;// ç»“æœæŒ‡é’ˆ
        while (start1 >= 0 && start2 >= 0) {
            if (A[start1] >= B[start2]) {
                A[idx--] = A[start1--];
            } else {
                A[idx--] = B[start2--];
            }
        }
        // æ·»åŠ å‰©ä½™æ•°å­—
//        while (start1 >= 0){
//            A[idx--] = A[start1--];
//        }
        while (start2 >= 0) {
            A[idx--] = B[start2--];
        }
    }
```

#### [å‰‘æŒ‡ Offer 51. æ•°ç»„ä¸­çš„é€†åºå¯¹](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

##### â­å½’å¹¶æ’åº

```java
int count = 0;// é€†åºå¯¹è®¡æ•°

public int reversePairs(int[] nums) {
    mergeSort(nums, 0, nums.length - 1, new int[nums.length]);
    return count;
}

private void mergeSort(int[] nums, int start, int end, int[] result) {
    if (start >= end) {
        return;
    }
    int mid = (start + end) >> 1;
    mergeSort(nums, start, mid, result);
    mergeSort(nums, mid + 1, end, result);
    merge(nums, start, end, result);
}

private void merge(int[] nums, int start, int end, int[] result) {
    int end1 = (start + end) >> 1;
    int start1 = start, start2 = end1 + 1;
    int idx = start;// ç»“æœæ•°ç»„æŒ‡é’ˆ
    while (start1 <= end1 && start2 <= end) {
        if (nums[start1] <= nums[start2]) {
            result[idx++] = nums[start1++];
        } else {
            result[idx++] = nums[start2++];
            count += end1 - start1+1;//å…ƒç´ start2æ¯” start1è‡³end1çš„å…ƒç´ éƒ½è¦å°
        }
    }
    // åˆå¹¶å‰©ä½™æ•°ç»„
    while (start1 <= end1) {
        result[idx++] = nums[start1++];
    }
    while (start2 <= end) {
        result[idx++] = nums[start2++];
    }
    // æŠŠæ“ä½œåŒºé—´æ‹·è´ç»™numsï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡æ¯”è¾ƒ
    for (int i = start; i <= end; i++) {
        nums[i] = result[i];
    }
}
```

æš´åŠ›è¶…æ—¶

```java
public int reversePairs(int[] nums) {
    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        for (int j = i + 1; j < nums.length; j++) {
            if (nums[i] > nums[j]) {
                count++;
            }
        }
    }
    return count;
}
```

#### [912. æ’åºæ•°ç»„](https://leetcode-cn.com/problems/sort-an-array/)

è®¡æ•°æ’åº

```java
public int[] sortArray(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return nums;
    }
    // æ‰¾å‡ºæœ€å¤§ã€æœ€å°å€¼
    int min = nums[0], max = nums[0];
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    // è®¡æ•°æ•°ç»„çš„è®¡æ•°èŒƒå›´
    int range = max - min + 1;
    int[] counting = new int[range];
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°åˆ°å¯¹åº”çš„è®¡æ•°æ•°ç»„æ•°å­—ä¸‹æ ‡
    for (int i = 0; i < nums.length; i++) {
        counting[nums[i] - min]++;
    }
    // è®¡ç®—æ¯ä¸ªæ•°å­—åœ¨ç»“æœæ•°ç»„ä¸­æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ä¸‹æ ‡
    counting[0]--;
    for (int i = 1; i < range; i++) {
        counting[i] += counting[i - 1];
    }
    // é€†åºéå†åŸæ•°ç»„,å°†æ•°å­—æ”¾åˆ°ç»“æœæ•°ç»„å¯¹åº”çš„ä½ç½®
    int[] result = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        result[counting[nums[i] - min]--] = nums[i];
    }
    return result;
}
```

#### [1122. æ•°ç»„çš„ç›¸å¯¹æ’åº](https://leetcode-cn.com/problems/relative-sort-array/)

```java
// æš´åŠ›
public int[] relativeSortArray(int[] arr1, int[] arr2) {
    Map<Integer, Integer> arr1Map = new HashMap<>();
    for (int a : arr1) {
        arr1Map.put(a, arr1Map.getOrDefault(a, 0) + 1);
    }
    int[] result = new int[arr1.length];
    int idx = 0;
    for (int a2 : arr2) {
        for (int i = 0; i < arr1Map.get(a2); i++) {
            result[idx++] = a2;
        }
        arr1Map.remove(a2);
    }
    List<Integer> list = new ArrayList<>();
    for (int k : arr1Map.keySet()) {
        list.add(k);
    }
    Collections.sort(list);
    for (int l : list) {
        for (int i = 0; i < arr1Map.get(l); i++) {
            result[idx++] = l;
        }
    }
    return result;
}
```

##### â­è®¡æ•°æ’åº

```java
// è®¡æ•°æ’åº
public int[] relativeSortArray(int[] arr1, int[] arr2) {
    // æ‰¾åˆ°æœ€å¤§ã€æœ€å°å€¼
    int min = arr1[0], max = arr1[0];
    for (int i = 1; i < arr1.length; i++) {
        if (arr1[i] > max) {
            max = arr1[i];
        } else if (arr1[i] < min) {
            min = arr1[i];
        }
    }
    // è®¡æ•°æ•°ç»„è®¡æ•°èŒƒå›´
    int range = max - min + 1;
    int[] counting = new int[range];
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°æ¬¡æ•°åˆ°è®¡æ•°æ•°ç»„å¯¹åº”ä¸‹æ ‡
    for (int i = 0; i < arr1.length; i++) {
        counting[arr1[i] - min]++;
    }
    // æŒ‰ç…§arr2ç»™å®šçš„é¡ºåºæ’åº
    int[] result = new int[arr1.length];
    int idx = 0;
    for (int i = 0; i < arr2.length; i++) {
        while (counting[arr2[i] - min] != 0) {
            result[idx++] = arr2[i];
            counting[arr2[i] - min]--;
        }
    }
    for (int i = 0; i < range; i++) {
        while (counting[i] != 0) {
            result[idx++] = i + min;
            counting[i]--;
        }
    }
    return result;
}
```

```java
// è®¡æ•°æ’åº,å……åˆ†åˆ©ç”¨æ‰€ç»™ä¿¡æ¯ï¼Œæ•°æ®èŒƒå›´åœ¨0~1000
public int[] relativeSortArray(int[] arr1, int[] arr2) {
    int[] counting = new int[1001];
    for (int a : arr1) {
        counting[a]++;
    }
    int[] result = new int[arr1.length];
    int index = 0;
    for (int i = 0; i < arr2.length; i++) {
        while (counting[arr2[i]] != 0) {
            result[index++] = arr2[i];
            counting[arr2[i]]--;
        }
    }
    for (int i = 0; i < 1001; i++) {
        while (counting[i] != 0) {
            result[index++] = i;
            counting[i]--;
        }
    }
    return result;
}
```

#### [164. æœ€å¤§é—´è·](https://leetcode-cn.com/problems/maximum-gap/)

```java
public int maximumGap(int[] nums) {
    if (nums.length < 2) {
        return 0;
    }
    Arrays.sort(nums);
    int max = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        max = Math.max(max, nums[i + 1] - nums[i]);
    }
    return max;
}
```

```java
public int maximumGap(int[] nums) {
    if (nums.length < 2) {
        return 0;
    }
    radixSort(nums);
    int max = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        max = Math.max(max, nums[i + 1] - nums[i]);
    }
    return max;
}

// LSD
public void radixSort(int[] nums) {
    // æ‰¾åˆ°æœ€å¤§æ•°å­—
    int max = 0;
    for (int num : nums) {
        if (num > max) {
            max = num;
        }
    }
    // è·å–æœ€å¤§æ•°å­—çš„ä½æ•°ï¼ˆå³æ•°ç»„ä¸­æ•°å­—çš„æœ€é•¿ä½æ•°ï¼‰
    int maxDigitlength = 0;
    while (max != 0) {
        max /= 10;
        maxDigitlength++;
    }
    int[] counting = new int[10];// åŸºæ•°å–å€¼èŒƒå›´0~9
    int[] result = new int[nums.length];
    int div = 1;
    for (int i = 0; i < maxDigitlength; i++) {
        // ç»Ÿè®¡åœ¨å½“å‰ä½æ•°ä¸‹ï¼Œä¸åŒåŸºæ•°çš„å…ƒç´ ä¸ªæ•°
        for (int num : nums) {
            int radix = num / div % 10;
            counting[radix]++;
        }
        // è®¡ç®—ä¸åŒåŸºæ•°æœ€åä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        for (int j = 1; j < 10; j++) {
            counting[j] += counting[j - 1];
        }
        // å€’åºéå†ï¼Œå°†æ¯ä¸ªæ•°å­—æ’åºåˆ°å¯¹åº”çš„ä½ç½®ï¼Œä»¥ä¿è¯æ’åºçš„ç¨³å®šæ€§
        for (int j = nums.length - 1; j >= 0; j--) {
            int radix = nums[j] / div % 10;
            result[--counting[radix]] = nums[j];
        }
        // ç»“æœèµ‹ç»™åŸæ•°ç»„
        for (int j = 0; j < nums.length; j++) {
            nums[j] = result[j];
        }
        // å°†è®¡æ•°æ•°ç»„é‡ç½®ä¸º0
        Arrays.fill(counting, 0);
        div *= 10;
    }
}
```

#### [561. æ•°ç»„æ‹†åˆ† I](https://leetcode-cn.com/problems/array-partition-i/)

```java
public int arrayPairSum(int[] nums) {
    Arrays.sort(nums);
    int res = 0;
    for (int i = 0; i < nums.length; i += 2) {
        res += nums[i];
    }
    return res;
}
```

```java
// LSD - å¯¹åŒ…å«è´Ÿæ•°çš„æ•°ç»„è¿›è¡ŒåŸºæ•°æ’åº
public void radixSort(int[] nums) {
    // æ‰¾åˆ°ç»å¯¹å€¼æœ€å¤§æ•°å­—
    int max = 0;
    for (int num : nums) {
        if (Math.abs(num) > max) {
            max = Math.abs(num);
        }
    }
    // è·å–æœ€å¤§æ•°å­—çš„ä½æ•°ï¼ˆå³æ•°ç»„ä¸­æ•°å­—çš„æœ€é•¿ä½æ•°ï¼‰
    int maxDigitlength = 0;
    while (max != 0) {
        max /= 10;
        maxDigitlength++;
    }
    int[] counting = new int[19];// åŸºæ•°å–å€¼èŒƒå›´-9~9
    int[] result = new int[nums.length];
    int div = 1;
    for (int i = 0; i < maxDigitlength; i++) {
        // ç»Ÿè®¡åœ¨å½“å‰ä½æ•°ä¸‹ï¼Œä¸åŒåŸºæ•°çš„å…ƒç´ ä¸ªæ•°
        for (int num : nums) {
            int radix = num / div % 10 + 9;
            counting[radix]++;
        }
        // è®¡ç®—ä¸åŒåŸºæ•°æœ€åä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        for (int j = 1; j < 19; j++) {
            counting[j] += counting[j - 1];
        }
        // å€’åºéå†ï¼Œå°†æ¯ä¸ªæ•°å­—æ’åºåˆ°å¯¹åº”çš„ä½ç½®ï¼Œä»¥ä¿è¯æ’åºçš„ç¨³å®šæ€§
        for (int j = nums.length - 1; j >= 0; j--) {
            int radix = nums[j] / div % 10 + 9;
            result[--counting[radix]] = nums[j];
        }
        // ç»“æœèµ‹ç»™åŸæ•°ç»„
        for (int j = 0; j < nums.length; j++) {
            nums[j] = result[j];
        }
        // å°†è®¡æ•°æ•°ç»„é‡ç½®ä¸º0
        Arrays.fill(counting, 0);
        div *= 10;
    }
}

public int arrayPairSum(int[] nums) {
    radixSort(nums);
    int res = 0;
    for (int i = 0; i < nums.length; i += 2) {
        res += nums[i];
    }
    return res;
}
```

```java
/**
 * è®¡æ•°æ’åº-å€’åºéå†
 *
 * @param nums
 */
public void countingSort(int[] nums) {
    if (nums == null || nums.length <= 1) {
        return;
    }
    // ç»Ÿè®¡æœ€å¤§ã€æœ€å°å€¼
    int max = nums[0], min = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    // ç¡®å®šè®¡æ•°æ•°ç»„çš„è®¡æ•°èŒƒå›´
    int range = max - min + 1;
    int[] counting = new int[range];
    // ç»Ÿè®¡æ¯ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°åˆ°å¯¹åº”çš„è®¡æ•°æ•°ç»„ä¸‹æ ‡
    for (int i = 0; i < nums.length; i++) {
        counting[nums[i] - min]++;
    }
    // è®¡ç®—æ¯ä¸ªæ•°å­—åœ¨æœ€ç»ˆç»“æœæ•°ç»„ä¸­çš„æœ€åä¸€ä¸ªä¸‹æ ‡ä½ç½®
    counting[0]--;
    for (int i = 1; i < range; i++) {
        counting[i] += counting[i - 1];
    }
    // å€’åºéå†ï¼Œå°†æ¯ä¸ªæ•°å­—æ’åºåˆ°å¯¹åº”ä½ç½®ï¼Œä»¥ä¿è¯æ’åºçš„ç¨³å®šæ€§
    int[] result = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        result[counting[nums[i] - min]--] = nums[i];
    }
    // å°†ç»“æœèµ‹ç»™åŸæ•°ç»„
    for (int i = 0; i < nums.length; i++) {
        nums[i] = result[i];
    }
}

public int arrayPairSum(int[] nums) {
    countingSort(nums);
    int res = 0;
    for (int i = 0; i < nums.length; i += 2) {
        res += nums[i];
    }
    return res;
}
```

#### [908. æœ€å°å·®å€¼ I](https://leetcode-cn.com/problems/smallest-range-i/)

```java
public int smallestRangeI(int[] nums, int k) {
    int max = nums[0], min = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    int range = max - min;
    int smallest = range;
    for (int i = 0; i <= k; i++) {
        for (int j = 0; j <= k; j++) {
            int temp = i + j;
            if (temp <= range) {
                smallest = Math.min(smallest, range - temp);
            }
        }
    }
    return smallest;
}
```

ä¼˜åŒ–

```java
public int smallestRangeI(int[] nums, int k) {
    int max = nums[0], min = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    int range = max - min;
    return range > (k << 1) ? range - (k << 1) : 0;
}
```

#### [164. æœ€å¤§é—´è·](https://leetcode-cn.com/problems/maximum-gap/)

##### â­æ¡¶æ’åºçš„åº”ç”¨

```java
/**
 * æ¡¶æ’åºï¼Œåˆ†æå¯çŸ¥ï¼Œæ’åºåç›¸é‚»å…ƒç´ é—´çš„æœ€å¤§å·®å€¼ä¸ä¼šå°äº d = (max-min)/(N-1)
 * è®¾ç½®æ¡¶å®¹é‡ä¸ºdï¼Œåˆ™ç›¸é‚»å…ƒç´ é—´æœ€å¤§å·®ä¸å¯èƒ½å‡ºç°åœ¨æ¡¶ä¸­
 * æ¯ä¸ªæ¡¶ç»´æŠ¤å…¶æ¡¶çš„æœ€å¤§ã€æœ€å°å€¼
 * æ¯”è¾ƒå‰ä¸€ä¸ªæ¡¶çš„æœ€å¤§ä¸åä¸€ä¸ªæ¡¶çš„æœ€å°å€¼çš„å·®å€¼ï¼Œä¸€å®šèƒ½å¤Ÿæ‰¾åˆ°ç›¸é‚»å…ƒç´ é—´æœ€å¤§å·®å€¼
 *
 * @param nums
 * @return
 */
public int maximumGap(int[] nums) {
    if (nums.length < 2) {
        return 0;
    }
    int min = nums[0], max = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > max) {
            max = nums[i];
        } else if (nums[i] < min) {
            min = nums[i];
        }
    }
    int range = max - min;// æ¡¶æ’åºèŒƒå›´
    int d = range / (nums.length - 1);
    double gap = Math.max(1, d);// æ¡¶é—´è·
    int bucketAmount = (int) (range / gap) + 1;// æ¡¶æ•°é‡
    int[][] buckets = new int[bucketAmount][2];// åªå­˜å‚¨æœ€å°ã€æœ€å¤§å€¼
    for (int i = 0; i < bucketAmount; i++) {
        Arrays.fill(buckets[i], -1);// åˆå§‹åŒ–æ¡¶å…ƒç´ ä¸º-1ï¼Œè¡¨ç¤ºç©ºæ¡¶
    }
    // æœ€å°ã€æœ€å¤§å€¼ï¼Œè£…æ¡¶
    for (int num : nums) {
        // å…ƒç´ æ‰€åœ¨çš„æ¡¶ä¸‹æ ‡
        int idx = (int) ((num - min) / gap);
        if (buckets[idx][0] < 0) {
            buckets[idx][0] = buckets[idx][1] = num;
        }
        if (buckets[idx][0] > num) {
            buckets[idx][0] = num;
        } else {
            buckets[idx][1] = Math.max(buckets[idx][1], num);
        }
    }
    // ç»´æŠ¤æ¯ä¸ªæ¡¶çš„æœ€å¤§ã€æœ€å°å€¼,æ¯”è¾ƒå‰ä¸€ä¸ªæ¡¶çš„æœ€å¤§ä¸åä¸€ä¸ªæ¡¶çš„æœ€å°å€¼çš„å·®å€¼ï¼Œä¸€å®šèƒ½å¤Ÿæ‰¾åˆ°ç›¸é‚»å…ƒç´ é—´æœ€å¤§å·®å€¼
    int target = 0;
    int preMax = buckets[0][1];
    for (int i = 1; i < bucketAmount; i++) {
        if (buckets[i][0] != -1) {
            target = Math.max(target, buckets[i][0] - preMax);
            preMax = buckets[i][1];
        }
    }
    return target;
}
```



