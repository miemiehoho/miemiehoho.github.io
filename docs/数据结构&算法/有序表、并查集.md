# 二叉树

### 数形DP

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=7

## 





# 前缀树

https://www.bilibili.com/video/BV1Ef4y1T7Qi?p=32



# 并查集

### 岛问题

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

**朴素解法：DFS**

时间复杂度：O(n*m) 

- `m == grid.length`
- `n == grid[i].length`

分析：大遍历时遍历一次，被上下左右调用最多4次，常数次，所以是O(n*m)

**进阶：**

设计一个并行算法解决这个问题



两个操作：issameset（查）和 union（并）

问题：设计一种结构把（1）两个集合中的元素合并到一个集合（2）查询两个样本是否一个集合

链表：union操作是O(1),但是issameset操作需要遍历两个集合

哈希表：issameset操作是O(1)，但是union操作需要把一个集合中的元素全部导到另一个集合

### 代码实现

```java
package zs;

import java.util.HashMap;
import java.util.List;
import java.util.Stack;

/**
 * 并查集
 *
 * @author miemiehoho
 * @date 2021/11/25 22:17
 */
public class DisjointSet {
    // 把基本元素封装一层
    class Element<V> {
        public V value;

        public Element(V value) {
            this.value = value;
        }
    }

    public class UnionFindSet<V> {
        // a -> a,封装基本元素
        // 把基本元素封装一层：与Java语言特性有关，比如Integer类型，如果不封装的话对map来说 3 3 3 3 这几个3 都是一个3
        public HashMap<V, Element<V>> elementMap;
        public HashMap<Element<V>, Element<V>> fatherMap;
        // sizeMap 中的key是集合的头节点（代表节点）
        public HashMap<Element<V>, Integer> sizeMap;// (rankMap)

        // 初始化
        public UnionFindSet(List<V> list) {
            elementMap = new HashMap<>();
            fatherMap = new HashMap<>();
            sizeMap = new HashMap<>();
            for (V value : list) {
                Element<V> element = new Element<>(value);
                elementMap.put(value, element);
                fatherMap.put(element, element);
                sizeMap.put(element, 1);
            }
        }

        // 黑盒：从当前节点出发，往上一直找,找到不能再往上的头节点，返回
        public Element<V> findHead(Element<V> element) {
            // 记录沿途的节点:把往上找的过程中，沿途的点都记录在path中
            Stack<Element<V>> path = new Stack<>();
            // 循环条件：element的父节点不是它自己
            while (element != fatherMap.get(element)) {
                path.push(element);
                element = fatherMap.get(element);
            }
            // 跳出上一个循环后的element就是头节点

            // 将沿途所有节点的头节点改成element节点
            while (!path.isEmpty()) {
                fatherMap.put(path.pop(), element);
            }
            return element;
        }

        public boolean isSameSet(V a, V b) {
            // 检查a、b 是否在初始化时注册进 elementMap
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                return findHead(elementMap.get(a)) == findHead(elementMap.get(b));
            }
            return false;
        }

        // 合并规则：小集合挂到大集合下面
        public void union(V a, V b) {
            if (elementMap.containsKey(a) && elementMap.containsKey(b)) {
                // 取出a、b的头节点
                Element<V> aF = findHead(elementMap.get(a));
                Element<V> bF = findHead(elementMap.get(b));
                // aF、bF不同，则合并
                if (aF != bF) {
                    // aF、bF中较大集合的头节点
                    Element<V> big = sizeMap.get(aF) >= sizeMap.get(bF) ? aF : bF;
                    // 较小集合的头节点
                    Element<V> small = big == aF ? bF : aF;
                    fatherMap.put(small, big);// 修改小集合的头节点为big
                    sizeMap.put(big, sizeMap.get(aF) + sizeMap.get(bF));// 更新集合的大小
                    sizeMap.remove(small);// small不再作为代表集合的头节点了，删除
                }
            }
        }
    }

}
```

> 拓展知识：MapReduce

**并查集的两个优化：**

1. 小集合挂大集合下面
2. 往上找的过程中沿途链做扁平化处理

#### 时间复杂度

样本数量：n

如果 isSameSet() 和 union() 整体发生的次数逼近了 n 或超过了 n,那么单次的 isSameSet() 和 union() 方法时间复杂度为 O(1)

(调用的次数越多，单次的 isSameSet() 和 union()  代价越小)







并查集（Union Find）也叫「不相交集合（Disjoint Set）」，专门用于 动态处理 不相交集合的「查询」与「合并」问题。

可以使用并查集的问题一般都可以使用基于遍历的搜索算法（深度优先搜索、广度优先搜索）完成，但是使用并查集会使得解决问题的过程更加清晰、直观。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251123145.png)



#### 并查集动态处理的两个问题

**查询（Find）**

查询图中的两个顶点是不是在同一个集合中。

> **注意**：并查集只回答两个顶点之间是否有一条路径连接，而不回答怎么连接。

**合并（Union）**

将两个不相交集合进行合并。

#### 设计并查集的两种思想

**quick-find：基于 id**

「基于 id」的思想给每一个元素（顶点）分配一个唯一标识，称为 `id`。

- 初始化的时候：所有元素的 `id` 都不一样，表示一个元素单独属于一个集合。
- 如果两个元素的 `id` 一样，标识它们同属于一个集合；
- 合并的时候，需要将其中一个集合中的 **所有元素** 的 `id` 赋值成为另一个集合的 `id`（一个集合中的所有元素的 `id` 均一样）。

类似于：给每个元素（顶点）改名字，名字一样，就表示在同一个集合中。

- 优点：查询两个元素是否在一个集合中很快，时间复杂度为 O(1)；
- 缺点：把两个集合合并成一个集合较慢，需要遍历其中一个集合中的所有元素。

**quick-union：基于 parent（重要）**

「基于 parent」的思想其实也很常见：记录每个顶点的父亲顶点是谁。这样设计「并查集」的思想也叫「代表元」法。

我们不再使用 `id` 数组，而使用 `parent` 数组。`parent` 数组的定义是：`parent[i]` 表示标识为 `i` 的结点的父亲结点的标识（可以形象地记为「找爸爸」）。在这个定义下，根结点的父亲结点是自己。

这种方式形成的「并查集」组织成了 **若干个不相交的树形结构**，并且我们在访问结点的时候，总是按照「从下到上」进行访问的。

#### 详解代表元法

**「代表元」的「三个不重要」**

以下「三个不重要」概括了「代表元法」的设计理念，大家需要结合练习体会。

- 谁作为根结点不重要：根结点与非根结点只是位置不同，并没有附加的含义；
- 树怎么形成的不重要：合并的时候任何一个集合的根结点指向另一个结合的根结点就可以；
- 树的形态不重要：理由同「谁作为根结点不重要」。

**代表元法可能造成的问题**

树的高度过高，查询性能降低。

![img](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251200945.png)



> 知识扩展：几乎所有的「树」的问题都在和「树的高度」较劲：
>
> - 「快速排序」，使用随机化 `pivot` 的方式避免递归树太深；
> - 「二叉搜索树」为了避免递归树太深，采用不同的旋转方式，得到了 AVL 树和红黑树。

解决方案有「按秩合并」与「路径压缩」，我们先介绍「按秩合并」。

#### 按秩合并

按「秩」合并的意思是：让树的「秩」较小的树的根结点，指向树的「秩」较大的树的根结点。

这里的「秩」有两种含义，分别用于不同的场景：

- 按 `size` 合并，用于需要维护每个连通分量结点个数的时候；
- 按 `rank` 合并，绝大多数时候。

**按 `size` 合并**

按 `size` 合并的意思是让树的「结点总数」较小的树的根结点，指向树的「结点总数」较大的树的根结点。

**按 `rank` 合并**

按 `rank` 合并的意思是让树的「高度」较小的树的根结点，指向树的「高度」较大的树的根结点。

之所以把「高度」称为 `rank` ，是因为同时使用「按秩合并」和「路径压缩」的时候，树的「高度」很难维护其准确的定义，但是依然可以作为合并时候的依据，因此成为「秩」。

#### 路径压缩

**路径压缩方式 1：隔代压缩**

「隔代压缩」的意思是：两步一跳，一直循环执行「把当前结点指向它的父亲结点的父亲结点」这样的操作。下面是一个例子。![image_1637826447](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251550121.gif)

这样的压缩并不彻底，但是多压缩几次，就可以达到压缩彻底的效果。



**路径压缩方式 2：完全压缩**

「完全压缩」的意思是：把从「查询结点」到「根结点」沿途经过的所有结点都指向根结点。「完全压缩」相比较于「隔代压缩」，压缩彻底。

![image_1637827685](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611341.gif)

![image_1637827856](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111251611270.gif)

#### 时间复杂度分析

**同时使用了「路径压缩」和「按秩合并」的时间复杂度**

并查集的时间复杂度分析，其理论性较强，通常只需要知道结论即可。这里我们给出结论：

同时使用按秩合并与路径压缩时，最坏情况的时间复杂度为 $O(m \alpha(n))$，这里 $\alpha(n)$ 是一个增长非常慢的函数，$\alpha(n) \le 4$

结论的具体介绍请见《算法导论》第 21.4 节《带路径压缩的按秩合并的分析》

可以 **感性** 地这样理解结论：由于路径压缩采用「一边查询，一边修改树结构」的策略，并且 **修改树的结构是不可逆的**，合并之前需要先查询再合并。如果次数非常多的话，最后并查集里所有的树的高度都只有 2，平均到每一次「合并」和「查询」操作，步骤是常数次的



# KMP

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=12  indexOf()方法：1:30,构造next数组：3:00

Java中的 **indexof()** 方法所用到的算法与KMP相似，时间复杂度也是O(n),但是在常数上有加速

**next数组：**`next[i]` 对应的下标，为 `P[0...i - 1]` 的最长公共前缀后缀的长度

#### 情景实例

现在有如下字符串 `Str1` 和 `Str2`，判断 `Str2` 是否为 `Str1` 的子串:

Str1:    A C T G P A C **T** G K A C T G P A C Y

Str2:	A C T G P A C **Y**

比较到 `Str2` 的末尾时，我们发现了不匹配的字符

注意，按照原来的思路，我们下一步应将字符串 `Str2` 的开头，与字符串 `Str1` 的第二位 `C` 重新进行比较。而 KMP 算法告诉我们，我们只需将**字符串 `Str2` 需要比较的位置重置到图中 `j` 的位置，`Str1` 保持 `i` 的位置不变**，接下来即可从 `i`，`j` 位置继续进行比较。

![image-20211125200926716](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111252009005.png)

**解释：**

 **next数组** 告诉了我们Str2中`next[i]` 对应的下标，为 `Str2[0...i - 1]` 的最长公共前缀后缀的长度

下一次无需从 `Str1`的第二个字符开始比较，也无需从 `i` 位置之前的任何一个位置开始比较，因为 `i`位置之前的任何一个位置都 **不可能**匹配出 **Str2**

- 证明：反证法：

  - 假设可以从 `i`之前的位置 比如 `k`位置匹配出 `Str2`,那么就意味着存在比 `next数组`告诉我们的最长前缀和最长后缀 更长的 最长前缀和后缀，这显然是不成立的，所以，无须从 `i`之前的位置开始比较，直接从 `i`位置继续比较即可

    ![image-20211125202338014](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111252023257.png)





#### 时间复杂度分析

**KMP分析**

设 Str1长度：n ,  `indexOf()`函数的while循环最大循环次数是2n

![image-20211125210843629](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111252108763.png)

**next数组分析**

设 Str2长度：m ,  `next()`函数的while循环最大循环次数是2m

![image-20211125213945461](https://raw.githubusercontent.com/miemiehoho/blog/master/picture/2021/11/202111252139599.png)

**总体复杂度**

一定有 n>m,所以KMP整体时间复杂度 O(n)



## Manacher算法

左神视频：https://www.bilibili.com/video/BV13g41157hK?p=13