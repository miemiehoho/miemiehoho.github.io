#### [指标A的最大值](https://www.nowcoder.com/study/live/717/4/6)

找到每个元素左右两边距离它最近的小于当前元素的元素下标，则当前元素就是这个子数组中的最小元素，对每个元素都如此计算一次指标A，必然能找到指标A max

```java
public int max(int[] arr) {
    int[][] nearLess = getNearLess(arr);
    int max = -1;
    for (int i = 0; i < arr.length; i++) {
        int l = nearLess[i][0] == -1 ? 0 : nearLess[i][0] + 1;
        int r = nearLess[i][1] == -1 ? arr.length - 1 : nearLess[i][1] - 1;
        int sum = 0;
        for (int j = l; j <= r; j++) {
            sum += arr[j];
        }
        sum *= arr[i];
        max = Math.max(max, sum);
    }
    return max;
}

private int[][] getNearLess(int[] arr) {
    int[][] res = new int[arr.length][arr.length];// 结果数组
    Deque<List<Integer>> stack = new LinkedList<>();// 单调递增栈
    for (int i = 0; i < arr.length; i++) {
        // 目标元素小于栈顶元素，栈顶元素就找到了其左右两侧小于栈顶元素的最近的元素
        while (!stack.isEmpty() && arr[stack.peekLast().get(0)] > arr[i]) {
            List<Integer> list = stack.pollLast();
            int leftLess = !stack.isEmpty() ? stack.peekLast().get(stack.peekLast().size() - 1) : -1;
            for (int v : list) {
                res[v][0] = leftLess;
                res[v][1] = i;
            }
        }
        // 目标元素等于栈顶元素
        if (!stack.isEmpty() && arr[stack.peekLast().get(0)] == arr[i]) {
            stack.peekLast().add(i);
        } else {
            // 目标元素大于栈顶元素
            List<Integer> list = new ArrayList<>();
            list.add(i);
            stack.addLast(list);
        }
    }
    // 清栈
    while (!stack.isEmpty()) {
        List<Integer> list = stack.pollLast();
        int leftLess = !stack.isEmpty() ? stack.peekLast().get(stack.peekLast().size() - 1) : -1;
        for (int v : list) {
            res[v][0] = leftLess;
            res[v][1] = -1;
        }
    }
    return res;
}
```