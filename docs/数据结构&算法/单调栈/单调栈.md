# 单调栈

## [相关题目](/docs/数据结构&算法/单调栈/单调栈-Leetcode.md)

## [题解](/docs/数据结构&算法/单调栈/单调栈-题解.md)

# 学习笔记

单调栈就是从数组中找到左右两边比你大的数或者比你小的数而且时间复杂度为O(N)。

### 什么是单调栈

**单调栈就是栈里面存放的数据都是有序的，所以可以分为单调递增栈和单调递减栈两种。**

1. 单调递增栈就是从栈底到栈顶是从大到小
2. [单调递减](https://www.zhihu.com/search?q=单调递减&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A101785785})栈就是从栈底到栈顶是从小到大



### 单调栈应用

- 在没有重复值的 数组中找到左右两边最近的比你小的数且时间复杂度为O(N)
  - 答：利用单调递增栈，所有元素依次进栈，若遇到新的进栈元素小于栈顶，那么就找到了当前栈顶左右两侧距离它最近的比它小的元素。
- 在有重复值的 数组中找到左右两边最近的比你小的数且时间复杂度为O(N)
  - 利用单调递增栈，所有元素以有序列表或链表结构依次进栈
    - 若进栈元素值与栈顶元素值相同，则进栈元素加入栈顶元素链表的末尾
    - 若遇到新的进栈元素小于栈顶，那么当前栈顶右两侧距离它最近的比它小的元素就是进栈元素，当前栈顶左侧距离最近的比它小的元素就是栈顶元素”压“着的栈元素链表的最后一个元素

### 时间复杂度

每个元素进一次栈，出一次栈，所以是 O(N)

### 算法实现

```java
/**
 * 单调递增栈获得数组中每个元素左右两边距离它最近的元素的下标
 *
 * @param arr
 * @return
 */
public int[][] getNearLess(int[] arr) {
    int len = arr.length;
    int[][] res = new int[len][2];// 结果数组
    Deque<List<Integer>> stack = new LinkedList<>();// 单调递增栈
    for (int i = 0; i < len; i++) {
        // 入栈元素小于栈顶元素，即栈顶元素找到了其左右两侧距离它最近的比它小的元素
        while (!stack.isEmpty() && arr[stack.peekLast().get(0)] > arr[i]) {
            List<Integer> list = stack.pollLast();
            int leftLess = stack.isEmpty() ? -1 : stack.peekLast().get(stack.peekLast().size() - 1);
            for (Integer idx : list) {
                res[idx][0] = leftLess;
                res[idx][1] = i;
            }
        }
        // 入栈元素等于栈顶元素
        if (!stack.isEmpty() && arr[stack.peekLast().get(0)] == arr[i]) {
            stack.peekLast().add(i);
        } else {
            // 入栈元素大于栈顶元素
            List<Integer> list = new ArrayList<>();
            list.add(i);
            stack.addLast(list);
        }
    }
    // 清栈
    while (!stack.isEmpty()) {
        List<Integer> list = stack.pollLast();
        int leftLess = stack.isEmpty() ? -1 : stack.peekLast().get(stack.peekLast().size() - 1);
        for (int i : list) {
            res[i][0] = leftLess;
            res[i][1] = -1;
        }
    }
    return res;
}
```